From 85f7b820ccdef362e40b9aed829ba1ab238e0846 Mon Sep 17 00:00:00 2001
From: Alessandro Di Federico <ale@clearmind.me>
Date: Fri, 4 Oct 2019 16:12:36 +0100
Subject: [PATCH] =?UTF-8?q?New=20frontend=20for=20Qualcomm's=20QDSP6=20(He?=
 =?UTF-8?q?xagon)=20ISA.=20Capable=20of=20running=20user=20mode=20binaries?=
 =?UTF-8?q?.=20System=20emulation=20for=20Hexagon=20is=20lacking=20still?=
 =?UTF-8?q?=20--=20the=20Hexagon=20Programmer=E2=80=99s=20Reference=20Manu?=
 =?UTF-8?q?al=20does=20not=20document=20system=20instructions.?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Hexagon Vector Extensions (HVX) are supported, FPU support is missing.

This frontend was designed and implemented by rev.ng for Comsecuris. The
code is openly licensed under a 2-clause BSD license.
---
 configure                                     |    5 +-
 default-configs/hexagon-linux-user.mak        |    1 +
 include/elf.h                                 |    2 +
 include/qemu/queue.h                          |   20 +
 linux-user/elfload.c                          |   41 +
 linux-user/hexagon/cpu_loop.c                 |   79 +
 linux-user/hexagon/signal.c                   |   68 +
 linux-user/hexagon/sockbits.h                 |    1 +
 linux-user/hexagon/syscall_nr.h               |  391 +++
 linux-user/hexagon/target_cpu.h               |   40 +
 linux-user/hexagon/target_elf.h               |   14 +
 linux-user/hexagon/target_fcntl.h             |   11 +
 linux-user/hexagon/target_signal.h            |   24 +
 linux-user/hexagon/target_structs.h           |   58 +
 linux-user/hexagon/target_syscall.h           |   23 +
 linux-user/hexagon/termbits.h                 |  214 ++
 linux-user/qemu.h                             |    3 +-
 linux-user/signal.c                           |    2 +-
 linux-user/strace.c                           |    1 +
 linux-user/syscall.c                          |    5 +
 linux-user/syscall_defs.h                     |    8 +-
 target/hexagon/Makefile.objs                  |   49 +
 target/hexagon/cpu-qom.h                      |   59 +
 target/hexagon/cpu.c                          |  157 +
 target/hexagon/cpu.h                          |  182 ++
 target/hexagon/gdbstub.c                      |   40 +
 target/hexagon/generator/README.md            |  564 ++++
 target/hexagon/generator/best-decoding.c      |  456 +++
 target/hexagon/generator/const-ext.csv        |   67 +
 target/hexagon/generator/decoder_gen.py       | 1122 +++++++
 target/hexagon/generator/instructions.csv     | 1508 +++++++++
 .../hexagon/generator/meta-instructions.csv   | 1067 +++++++
 .../hexagon/generator/semantics/semantics.lex |  592 ++++
 .../hexagon/generator/semantics/semantics.y   | 2723 +++++++++++++++++
 .../generator/semantics/semantics_struct.h    |  118 +
 target/hexagon/generator/sub-instructions.csv |   47 +
 target/hexagon/helper.c                       |   40 +
 target/hexagon/helper.h                       |    4 +
 target/hexagon/hexagon-semi.c                 |  616 ++++
 target/hexagon/op_helper.c                    |  132 +
 target/hexagon/translate.c                    |  647 ++++
 tcg/tcg.c                                     |   29 +
 tcg/tcg.h                                     |    1 +
 tests/tcg/hexagon/.gitignore                  |    4 +
 tests/tcg/hexagon/Makefile                    |  111 +
 tests/tcg/hexagon/crt.s                       |   47 +
 tests/tcg/hexagon/test_abs.s                  |   20 +
 tests/tcg/hexagon/test_add.s                  |   20 +
 tests/tcg/hexagon/test_andp.s                 |   22 +
 tests/tcg/hexagon/test_bitcnt.s               |   42 +
 tests/tcg/hexagon/test_bitsplit.s             |   25 +
 tests/tcg/hexagon/test_call.s                 |   59 +
 tests/tcg/hexagon/test_clobber.s              |   32 +
 tests/tcg/hexagon/test_cmp.s                  |   34 +
 tests/tcg/hexagon/test_cmpy.s                 |   29 +
 tests/tcg/hexagon/test_djump.s                |   19 +
 tests/tcg/hexagon/test_dotnew.s               |   37 +
 tests/tcg/hexagon/test_dstore.s               |   24 +
 tests/tcg/hexagon/test_ext.s                  |   16 +
 tests/tcg/hexagon/test_fibonacci.s            |   33 +
 tests/tcg/hexagon/test_hello.s                |   21 +
 tests/tcg/hexagon/test_hl.s                   |   19 +
 tests/tcg/hexagon/test_hwloops.s              |   24 +
 tests/tcg/hexagon/test_jmp.s                  |   25 +
 tests/tcg/hexagon/test_lsr.s                  |   39 +
 tests/tcg/hexagon/test_mem.s                  |   78 +
 tests/tcg/hexagon/test_mpyi.s                 |   20 +
 tests/tcg/hexagon/test_packet.s               |   24 +
 tests/tcg/hexagon/test_reorder.s              |   24 +
 tests/tcg/hexagon/test_round.s                |   40 +
 tests/tcg/hexagon/test_sys_access.s           |   39 +
 tests/tcg/hexagon/test_sys_clock.s            |   20 +
 tests/tcg/hexagon/test_sys_close.s            |   56 +
 tests/tcg/hexagon/test_sys_cmdline.s          |   55 +
 tests/tcg/hexagon/test_sys_fcntl.s            |   86 +
 tests/tcg/hexagon/test_sys_flen.s             |   53 +
 tests/tcg/hexagon/test_sys_ftell.s            |   99 +
 tests/tcg/hexagon/test_sys_ftrunc.s           |  109 +
 tests/tcg/hexagon/test_sys_getcwd.s           |   55 +
 tests/tcg/hexagon/test_sys_gettimeofday.s     |   34 +
 tests/tcg/hexagon/test_sys_heapinfo.s         |   33 +
 tests/tcg/hexagon/test_sys_istty.s            |  102 +
 tests/tcg/hexagon/test_sys_mkdir.s            |   33 +
 tests/tcg/hexagon/test_sys_open.s             |   39 +
 tests/tcg/hexagon/test_sys_opendir.s          |   81 +
 tests/tcg/hexagon/test_sys_read.s             |   70 +
 tests/tcg/hexagon/test_sys_readc.s            |   22 +
 tests/tcg/hexagon/test_sys_rmdir.s            |   47 +
 tests/tcg/hexagon/test_sys_seek.s             |  109 +
 tests/tcg/hexagon/test_vavgw.s                |   32 +
 tests/tcg/hexagon/test_vcmp.s                 |   17 +
 tests/tcg/hexagon/test_vcmpb.s                |   29 +
 tests/tcg/hexagon/test_vcmpw.s                |   26 +
 tests/tcg/hexagon/test_vcmpy.s                |   48 +
 tests/tcg/hexagon/test_vlsrw.s                |   23 +
 tests/tcg/hexagon/test_vmaxh.s                |   34 +
 tests/tcg/hexagon/test_vminh.s                |   34 +
 tests/tcg/hexagon/test_vpmpyh.s               |   28 +
 tests/tcg/hexagon/test_vspliceb.s             |   33 +
 99 files changed, 13559 insertions(+), 6 deletions(-)
 create mode 100644 default-configs/hexagon-linux-user.mak
 create mode 100644 linux-user/hexagon/cpu_loop.c
 create mode 100644 linux-user/hexagon/signal.c
 create mode 100644 linux-user/hexagon/sockbits.h
 create mode 100644 linux-user/hexagon/syscall_nr.h
 create mode 100644 linux-user/hexagon/target_cpu.h
 create mode 100644 linux-user/hexagon/target_elf.h
 create mode 100644 linux-user/hexagon/target_fcntl.h
 create mode 100644 linux-user/hexagon/target_signal.h
 create mode 100644 linux-user/hexagon/target_structs.h
 create mode 100644 linux-user/hexagon/target_syscall.h
 create mode 100644 linux-user/hexagon/termbits.h
 create mode 100644 target/hexagon/Makefile.objs
 create mode 100644 target/hexagon/cpu-qom.h
 create mode 100644 target/hexagon/cpu.c
 create mode 100644 target/hexagon/cpu.h
 create mode 100644 target/hexagon/gdbstub.c
 create mode 100644 target/hexagon/generator/README.md
 create mode 100644 target/hexagon/generator/best-decoding.c
 create mode 100644 target/hexagon/generator/const-ext.csv
 create mode 100755 target/hexagon/generator/decoder_gen.py
 create mode 100644 target/hexagon/generator/instructions.csv
 create mode 100644 target/hexagon/generator/meta-instructions.csv
 create mode 100644 target/hexagon/generator/semantics/semantics.lex
 create mode 100644 target/hexagon/generator/semantics/semantics.y
 create mode 100644 target/hexagon/generator/semantics/semantics_struct.h
 create mode 100644 target/hexagon/generator/sub-instructions.csv
 create mode 100644 target/hexagon/helper.c
 create mode 100644 target/hexagon/helper.h
 create mode 100644 target/hexagon/hexagon-semi.c
 create mode 100644 target/hexagon/op_helper.c
 create mode 100644 target/hexagon/translate.c
 create mode 100644 tests/tcg/hexagon/.gitignore
 create mode 100644 tests/tcg/hexagon/Makefile
 create mode 100644 tests/tcg/hexagon/crt.s
 create mode 100644 tests/tcg/hexagon/test_abs.s
 create mode 100644 tests/tcg/hexagon/test_add.s
 create mode 100644 tests/tcg/hexagon/test_andp.s
 create mode 100644 tests/tcg/hexagon/test_bitcnt.s
 create mode 100644 tests/tcg/hexagon/test_bitsplit.s
 create mode 100644 tests/tcg/hexagon/test_call.s
 create mode 100644 tests/tcg/hexagon/test_clobber.s
 create mode 100644 tests/tcg/hexagon/test_cmp.s
 create mode 100644 tests/tcg/hexagon/test_cmpy.s
 create mode 100644 tests/tcg/hexagon/test_djump.s
 create mode 100644 tests/tcg/hexagon/test_dotnew.s
 create mode 100644 tests/tcg/hexagon/test_dstore.s
 create mode 100644 tests/tcg/hexagon/test_ext.s
 create mode 100644 tests/tcg/hexagon/test_fibonacci.s
 create mode 100644 tests/tcg/hexagon/test_hello.s
 create mode 100644 tests/tcg/hexagon/test_hl.s
 create mode 100644 tests/tcg/hexagon/test_hwloops.s
 create mode 100644 tests/tcg/hexagon/test_jmp.s
 create mode 100644 tests/tcg/hexagon/test_lsr.s
 create mode 100644 tests/tcg/hexagon/test_mem.s
 create mode 100644 tests/tcg/hexagon/test_mpyi.s
 create mode 100644 tests/tcg/hexagon/test_packet.s
 create mode 100644 tests/tcg/hexagon/test_reorder.s
 create mode 100644 tests/tcg/hexagon/test_round.s
 create mode 100644 tests/tcg/hexagon/test_sys_access.s
 create mode 100644 tests/tcg/hexagon/test_sys_clock.s
 create mode 100644 tests/tcg/hexagon/test_sys_close.s
 create mode 100644 tests/tcg/hexagon/test_sys_cmdline.s
 create mode 100644 tests/tcg/hexagon/test_sys_fcntl.s
 create mode 100644 tests/tcg/hexagon/test_sys_flen.s
 create mode 100644 tests/tcg/hexagon/test_sys_ftell.s
 create mode 100644 tests/tcg/hexagon/test_sys_ftrunc.s
 create mode 100644 tests/tcg/hexagon/test_sys_getcwd.s
 create mode 100644 tests/tcg/hexagon/test_sys_gettimeofday.s
 create mode 100644 tests/tcg/hexagon/test_sys_heapinfo.s
 create mode 100644 tests/tcg/hexagon/test_sys_istty.s
 create mode 100644 tests/tcg/hexagon/test_sys_mkdir.s
 create mode 100644 tests/tcg/hexagon/test_sys_open.s
 create mode 100644 tests/tcg/hexagon/test_sys_opendir.s
 create mode 100644 tests/tcg/hexagon/test_sys_read.s
 create mode 100644 tests/tcg/hexagon/test_sys_readc.s
 create mode 100644 tests/tcg/hexagon/test_sys_rmdir.s
 create mode 100644 tests/tcg/hexagon/test_sys_seek.s
 create mode 100644 tests/tcg/hexagon/test_vavgw.s
 create mode 100644 tests/tcg/hexagon/test_vcmp.s
 create mode 100644 tests/tcg/hexagon/test_vcmpb.s
 create mode 100644 tests/tcg/hexagon/test_vcmpw.s
 create mode 100644 tests/tcg/hexagon/test_vcmpy.s
 create mode 100644 tests/tcg/hexagon/test_vlsrw.s
 create mode 100644 tests/tcg/hexagon/test_vmaxh.s
 create mode 100644 tests/tcg/hexagon/test_vminh.s
 create mode 100644 tests/tcg/hexagon/test_vpmpyh.s
 create mode 100644 tests/tcg/hexagon/test_vspliceb.s

diff --git a/configure b/configure
index 8af2be959f..6e503d8e40 100755
--- a/configure
+++ b/configure
@@ -7033,6 +7033,8 @@ case "$target_name" in
     mttcg="yes"
     target_compiler=$cross_cc_hppa
   ;;
+  hexagon)
+  ;;
   lm32)
     target_compiler=$cross_cc_lm32
   ;;
@@ -7415,12 +7417,13 @@ if test "$ccache_cpp2" = "yes"; then
 fi
 
 # build tree in object directory in case the source is not in the current directory
-DIRS="tests tests/tcg tests/tcg/cris tests/tcg/lm32 tests/libqos tests/qapi-schema tests/tcg/xtensa tests/qemu-iotests tests/vm"
+DIRS="tests tests/tcg tests/tcg/hexagon tests/tcg/cris tests/tcg/lm32 tests/libqos tests/qapi-schema tests/tcg/xtensa tests/qemu-iotests tests/vm"
 DIRS="$DIRS tests/fp"
 DIRS="$DIRS docs docs/interop fsdev scsi"
 DIRS="$DIRS pc-bios/optionrom pc-bios/spapr-rtas pc-bios/s390-ccw"
 DIRS="$DIRS roms/seabios roms/vgabios"
 FILES="Makefile tests/tcg/Makefile qdict-test-data.txt"
+FILES="$FILES tests/tcg/hexagon/Makefile"
 FILES="$FILES tests/tcg/cris/Makefile tests/tcg/cris/.gdbinit"
 FILES="$FILES tests/tcg/lm32/Makefile tests/tcg/xtensa/Makefile po/Makefile"
 FILES="$FILES tests/fp/Makefile"
diff --git a/default-configs/hexagon-linux-user.mak b/default-configs/hexagon-linux-user.mak
new file mode 100644
index 0000000000..ad55af021e
--- /dev/null
+++ b/default-configs/hexagon-linux-user.mak
@@ -0,0 +1 @@
+# Default configuration for hexagon-linux-user
diff --git a/include/elf.h b/include/elf.h
index 312f68af81..e22cd2b597 100644
--- a/include/elf.h
+++ b/include/elf.h
@@ -173,6 +173,8 @@ typedef int64_t  Elf64_Sxword;
 #define EM_MOXIE           223     /* Moxie processor family */
 #define EM_MOXIE_OLD       0xFEED
 
+#define EM_HEXAGON  164 /* QUALCOMM Hexagon */
+
 /* This is the info that is needed to parse the dynamic section of the file */
 #define DT_NULL		0
 #define DT_NEEDED	1
diff --git a/include/qemu/queue.h b/include/qemu/queue.h
index ac418efc43..ba72358f44 100644
--- a/include/qemu/queue.h
+++ b/include/qemu/queue.h
@@ -409,6 +409,16 @@ struct {                                                                \
         (listelm)->field.tqe_prev = &(elm)->field.tqe_next;             \
 } while (/*CONSTCOND*/0)
 
+#define QTAILQ_INSERT_RANGE_AFTER(head, listelm, begin, end, field) do {\
+        if (((end)->field.tqe_next = (listelm)->field.tqe_next) != NULL)\
+                (end)->field.tqe_next->field.tqe_prev =                 \
+                    &(end)->field.tqe_next;                             \
+        else                                                            \
+                (head)->tqh_last = &(end)->field.tqe_next;              \
+        (listelm)->field.tqe_next = (begin);                            \
+        (begin)->field.tqe_prev = &(listelm)->field.tqe_next;           \
+} while (/*CONSTCOND*/0)
+
 #define QTAILQ_REMOVE(head, elm, field) do {                            \
         if (((elm)->field.tqe_next) != NULL)                            \
                 (elm)->field.tqe_next->field.tqe_prev =                 \
@@ -419,6 +429,16 @@ struct {                                                                \
         (elm)->field.tqe_prev = NULL;                                   \
 } while (/*CONSTCOND*/0)
 
+#define QTAILQ_REMOVE_RANGE(head, begin, end, field) do {               \
+        if (((end)->field.tqe_next) != NULL)                            \
+                (end)->field.tqe_next->field.tqe_prev =                 \
+                    (begin)->field.tqe_prev;                            \
+        else                                                            \
+                (head)->tqh_last = (begin)->field.tqe_prev;             \
+        *(begin)->field.tqe_prev = (end)->field.tqe_next;               \
+        (begin)->field.tqe_prev = NULL;                                 \
+} while (/*CONSTCOND*/0)
+
 #define QTAILQ_FOREACH(var, head, field)                                \
         for ((var) = ((head)->tqh_first);                               \
                 (var);                                                  \
diff --git a/linux-user/elfload.c b/linux-user/elfload.c
index 10bca65b99..cf1a577d96 100644
--- a/linux-user/elfload.c
+++ b/linux-user/elfload.c
@@ -978,6 +978,35 @@ static void elf_core_copy_regs(target_elf_gregset_t *regs, const CPUMBState *env
 
 #endif /* TARGET_MICROBLAZE */
 
+#ifdef TARGET_HEXAGON
+
+#define ELF_START_MMAP 0x80000000
+
+#define elf_check_arch(x) ( (x) == EM_HEXAGON )
+
+#define ELF_CLASS   ELFCLASS32
+#define ELF_ARCH    EM_HEXAGON
+
+static inline void init_thread(struct target_pt_regs *regs,
+                               struct image_info *infop)
+{
+    regs->gpr[29] = infop->start_stack;
+    regs->cr[9] = infop->entry;
+}
+
+#define ELF_EXEC_PAGESIZE        4096
+
+#define USE_ELF_CORE_DUMP
+#define ELF_NREG 38 /* TODO */
+typedef target_elf_greg_t target_elf_gregset_t[ELF_NREG];
+
+static void elf_core_copy_regs(target_elf_gregset_t *regs, const CPUHexagonState *env)
+{
+    /* TODO */
+}
+
+#endif /* TARGET_HEXAGON */
+
 #ifdef TARGET_NIOS2
 
 #define ELF_START_MMAP 0x80000000
@@ -1645,6 +1674,9 @@ static abi_ulong setup_arg_pages(struct linux_binprm *bprm,
 {
     abi_ulong size, error, guard;
 
+#ifdef TARGET_HEXAGON
+    guest_stack_size = 8 * 1024 * 1024;
+#endif
     size = guest_stack_size;
     if (size < STACK_LOWER_LIMIT) {
         size = STACK_LOWER_LIMIT;
@@ -1654,8 +1686,13 @@ static abi_ulong setup_arg_pages(struct linux_binprm *bprm,
         guard = qemu_real_host_page_size;
     }
 
+#ifdef TARGET_HEXAGON
+    error = target_mmap(0x3f0e000, size + guard, PROT_READ | PROT_WRITE,
+                        MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
+#else
     error = target_mmap(0, size + guard, PROT_READ | PROT_WRITE,
                         MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
+#endif
     if (error == -1) {
         perror("mmap stack");
         exit(-1);
@@ -2622,6 +2659,10 @@ int load_elf_binary(struct linux_binprm *bprm, struct image_info *info)
        change some of these later */
     bprm->p = setup_arg_pages(bprm, info);
 
+#ifdef TARGET_HEXAGON
+    bprm->p += 0x480;
+#endif
+
     scratch = g_new0(char, TARGET_PAGE_SIZE);
     if (STACK_GROWS_DOWN) {
         bprm->p = copy_elf_strings(1, &bprm->filename, scratch,
diff --git a/linux-user/hexagon/cpu_loop.c b/linux-user/hexagon/cpu_loop.c
new file mode 100644
index 0000000000..02b16cdc11
--- /dev/null
+++ b/linux-user/hexagon/cpu_loop.c
@@ -0,0 +1,79 @@
+/*
+ *  qemu user cpu loop
+ *
+ *  Copyright (c) 2003-2008 Fabrice Bellard
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "qemu/osdep.h"
+#include "qemu.h"
+#include "cpu_loop-common.h"
+
+void cpu_loop(CPUHexagonState *env)
+{
+    CPUState *cs = CPU(hexagon_env_get_cpu(env));
+    int trapnr;
+    target_siginfo_t info;
+
+    while (1) {
+        cpu_exec_start(cs);
+        trapnr = cpu_exec(cs);
+        cpu_exec_end(cs);
+        process_queued_cpu_work(cs);
+
+        switch (trapnr) {
+        case 0xaa:
+            {
+                info.si_signo = TARGET_SIGSEGV;
+                info.si_errno = 0;
+                /* XXX: check env->error_code */
+                info.si_code = TARGET_SEGV_MAPERR;
+                info._sifields._sigfault._addr = 0;
+                queue_signal(env, info.si_signo, QEMU_SI_FAULT, &info);
+            }
+            break;
+        case EXCP_TRAP_INSN:
+            /* Semihosing syscall.  */
+            env->cr[CR_PC] += 4;
+            env->gpr[0] = do_hexagon_semihosting(env);
+            break;
+        default:
+            //printf ("Unhandled trap: 0x%x\n", trapnr);
+            //cpu_dump_state(cs, stderr, fprintf, 0);
+            //exit(EXIT_FAILURE);
+            ;
+        }
+        process_pending_signals (env);
+    }
+}
+
+void target_cpu_copy_regs(CPUArchState *env, struct target_pt_regs *regs)
+{
+   for(int i = 0; i < 32; i++) {
+       env->gpr[i] = regs->gpr[i];
+       env->cr[i] = regs->cr[i];
+   }
+   for(int i = 0; i < 64; i++) {
+       env->sr[i] = regs->sr[i];
+   }
+
+    CPUState *cpu = ENV_GET_CPU(env);
+    TaskState *ts = cpu->opaque;
+    struct image_info *info = ts->info;
+    ts->stack_base = info->start_stack;
+    ts->heap_base = info->brk;
+    /* This will be filled in on the first SYS_HEAPINFO call.  */
+    ts->heap_limit = 0;
+}
diff --git a/linux-user/hexagon/signal.c b/linux-user/hexagon/signal.c
new file mode 100644
index 0000000000..b90bec8779
--- /dev/null
+++ b/linux-user/hexagon/signal.c
@@ -0,0 +1,68 @@
+/*
+ *  Emulation of Linux signals
+ *
+ *  Copyright (c) 2003 Fabrice Bellard
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+#include "qemu/osdep.h"
+#include "qemu.h"
+#include "signal-common.h"
+#include "linux-user/trace.h"
+
+struct target_sigcontext {
+    struct target_pt_regs regs;  /* needs to be first */
+    uint32_t oldmask;
+};
+
+struct target_stack_t {
+    abi_ulong ss_sp;
+    int ss_flags;
+    unsigned int ss_size;
+};
+
+struct target_ucontext {
+    abi_ulong tuc_flags;
+    abi_ulong tuc_link;
+    struct target_stack_t tuc_stack;
+    struct target_sigcontext tuc_mcontext;
+    uint32_t tuc_extramask[TARGET_NSIG_WORDS - 1];
+};
+
+/* Signal frames. */
+struct target_signal_frame {
+    struct target_ucontext uc;
+    uint32_t extramask[TARGET_NSIG_WORDS - 1];
+    uint32_t tramp[2];
+};
+
+struct rt_signal_frame {
+    siginfo_t info;
+    ucontext_t uc;
+    uint32_t tramp[2];
+};
+
+void setup_rt_frame(int sig, struct target_sigaction *ka,
+                    target_siginfo_t *info,
+                    target_sigset_t *set, CPUHexagonState *env)
+{
+    qemu_log_mask(LOG_UNIMP, "setup_rt_frame: not implemented\n");
+}
+
+long do_rt_sigreturn(CPUHexagonState *env)
+{
+    trace_user_do_rt_sigreturn(env, 0);
+    qemu_log_mask(LOG_UNIMP, "do_rt_sigreturn: not implemented\n");
+    return -TARGET_ENOSYS;
+}
diff --git a/linux-user/hexagon/sockbits.h b/linux-user/hexagon/sockbits.h
new file mode 100644
index 0000000000..0e4c8f012d
--- /dev/null
+++ b/linux-user/hexagon/sockbits.h
@@ -0,0 +1 @@
+#include "../generic/sockbits.h"
diff --git a/linux-user/hexagon/syscall_nr.h b/linux-user/hexagon/syscall_nr.h
new file mode 100644
index 0000000000..d80d4396de
--- /dev/null
+++ b/linux-user/hexagon/syscall_nr.h
@@ -0,0 +1,391 @@
+#define TARGET_NR_restart_syscall	0 /* ok */
+#define TARGET_NR_exit		1 /* ok */
+#define TARGET_NR_fork		2 /* not for no MMU - weird */
+#define TARGET_NR_read		3 /* ok */
+#define TARGET_NR_write		4 /* ok */
+#define TARGET_NR_open		5 /* openat */
+#define TARGET_NR_close		6 /* ok */
+#define TARGET_NR_waitpid		7 /* waitid */
+#define TARGET_NR_creat		8 /* openat */
+#define TARGET_NR_link		9 /* linkat */
+#define TARGET_NR_unlink		10 /* unlinkat */
+#define TARGET_NR_execve		11 /* ok */
+#define TARGET_NR_chdir		12 /* ok */
+#define TARGET_NR_time		13 /* obsolete -> sys_gettimeofday */
+#define TARGET_NR_mknod		14 /* mknodat */
+#define TARGET_NR_chmod		15 /* fchmodat */
+#define TARGET_NR_lchown		16 /* ok */
+#define TARGET_NR_break		17 /* don't know */
+#define TARGET_NR_oldstat		18 /* remove */
+#define TARGET_NR_lseek		19 /* ok */
+#define TARGET_NR_getpid		20 /* ok */
+#define TARGET_NR_mount		21 /* ok */
+#define TARGET_NR_umount		22 /* ok */  /* use only umount2 */
+#define TARGET_NR_setuid		23 /* ok */
+#define TARGET_NR_getuid		24 /* ok */
+#define TARGET_NR_stime		25 /* obsolete -> sys_settimeofday */
+#define TARGET_NR_ptrace		26 /* ok */
+#define TARGET_NR_alarm		27 /* obsolete -> sys_setitimer */
+#define TARGET_NR_oldfstat		28 /* remove */
+#define TARGET_NR_pause		29 /* obsolete -> sys_rt_sigtimedwait */
+#define TARGET_NR_utime		30 /* obsolete -> sys_utimesat */
+#define TARGET_NR_stty		31 /* remove */
+#define TARGET_NR_gtty		32 /* remove */
+#define TARGET_NR_access		33 /* faccessat */
+#define TARGET_NR_nice		34 /* can be implemented by sys_setpriority */
+#define TARGET_NR_ftime		35 /* remove */
+#define TARGET_NR_sync		36 /* ok */
+#define TARGET_NR_kill		37 /* ok */
+#define TARGET_NR_rename		38 /* renameat */
+#define TARGET_NR_mkdir		39 /* mkdirat */
+#define TARGET_NR_rmdir		40 /* unlinkat */
+#define TARGET_NR_dup		41 /* ok */
+#define TARGET_NR_pipe		42 /* ok */
+#define TARGET_NR_times		43 /* ok */
+#define TARGET_NR_prof		44 /* remove */
+#define TARGET_NR_brk		45 /* ok -mmu, nommu specific */
+#define TARGET_NR_setgid		46 /* ok */
+#define TARGET_NR_getgid		47 /* ok */
+#define TARGET_NR_signal		48 /* obsolete -> sys_rt_sigaction */
+#define TARGET_NR_geteuid		49 /* ok */
+#define TARGET_NR_getegid		50 /* ok */
+#define TARGET_NR_acct		51 /* add it and then I can disable it */
+#define TARGET_NR_umount2		52 /* remove */
+#define TARGET_NR_lock		53 /* remove */
+#define TARGET_NR_ioctl		54 /* ok */
+#define TARGET_NR_fcntl		55 /* ok -> 64bit version*/
+#define TARGET_NR_mpx		56 /* remove */
+#define TARGET_NR_setpgid		57 /* ok */
+#define TARGET_NR_ulimit		58 /* remove */
+#define TARGET_NR_oldolduname	59 /* remove */
+#define TARGET_NR_umask		60 /* ok */
+#define TARGET_NR_chroot		61 /* ok */
+#define TARGET_NR_ustat		62 /* obsolete -> statfs64 */
+#define TARGET_NR_dup2		63 /* ok */
+#define TARGET_NR_getppid		64 /* ok */
+#define TARGET_NR_getpgrp		65 /* obsolete -> sys_getpgid */
+#define TARGET_NR_setsid		66 /* ok */
+#define TARGET_NR_sigaction		67 /* obsolete -> rt_sigaction */
+#define TARGET_NR_sgetmask		68 /* obsolete -> sys_rt_sigprocmask */
+#define TARGET_NR_ssetmask		69 /* obsolete ->sys_rt_sigprocmask */
+#define TARGET_NR_setreuid		70 /* ok */
+#define TARGET_NR_setregid		71 /* ok */
+#define TARGET_NR_sigsuspend		72 /* obsolete -> rt_sigsuspend */
+#define TARGET_NR_sigpending		73 /* obsolete -> sys_rt_sigpending */
+#define TARGET_NR_sethostname	74 /* ok */
+#define TARGET_NR_setrlimit		75 /* ok */
+#define TARGET_NR_getrlimit		76 /* ok Back compatible 2Gig limited rlimit */
+#define TARGET_NR_getrusage		77 /* ok */
+#define TARGET_NR_gettimeofday	78 /* ok */
+#define TARGET_NR_settimeofday	79 /* ok */
+#define TARGET_NR_getgroups		80 /* ok */
+#define TARGET_NR_setgroups		81 /* ok */
+#define TARGET_NR_select		82 /* obsolete -> sys_pselect7 */
+#define TARGET_NR_symlink		83 /* symlinkat */
+#define TARGET_NR_oldlstat		84 /* remove */
+#define TARGET_NR_readlink		85 /* obsolete -> sys_readlinkat */
+#define TARGET_NR_uselib		86 /* remove */
+#define TARGET_NR_swapon		87 /* ok */
+#define TARGET_NR_reboot		88 /* ok */
+#define TARGET_NR_readdir		89 /* remove ? */
+#define TARGET_NR_mmap		90 /* obsolete -> sys_mmap2 */
+#define TARGET_NR_munmap		91 /* ok - mmu and nommu */
+#define TARGET_NR_truncate		92 /* ok or truncate64 */
+#define TARGET_NR_ftruncate		93 /* ok or ftruncate64 */
+#define TARGET_NR_fchmod		94 /* ok */
+#define TARGET_NR_fchown		95 /* ok */
+#define TARGET_NR_getpriority	96 /* ok */
+#define TARGET_NR_setpriority	97 /* ok */
+#define TARGET_NR_profil		98 /* remove */
+#define TARGET_NR_statfs		99 /* ok or statfs64 */
+#define TARGET_NR_fstatfs		100  /* ok or fstatfs64 */
+#define TARGET_NR_ioperm		101 /* remove */
+#define TARGET_NR_socketcall		102 /* remove */
+#define TARGET_NR_syslog		103 /* ok */
+#define TARGET_NR_setitimer		104 /* ok */
+#define TARGET_NR_getitimer		105 /* ok */
+#define TARGET_NR_stat		106 /* remove */
+#define TARGET_NR_lstat		107 /* remove */
+#define TARGET_NR_fstat		108 /* remove */
+#define TARGET_NR_olduname		109 /* remove */
+#define TARGET_NR_iopl		110 /* remove */
+#define TARGET_NR_vhangup		111 /* ok */
+#define TARGET_NR_idle		112 /* remove */
+#define TARGET_NR_vm86old		113 /* remove */
+#define TARGET_NR_wait4		114 /* obsolete -> waitid */
+#define TARGET_NR_swapoff		115 /* ok */
+#define TARGET_NR_sysinfo		116 /* ok */
+#define TARGET_NR_ipc		117 /* remove - direct call */
+#define TARGET_NR_fsync		118 /* ok */
+#define TARGET_NR_clone		120 /* ok */
+#define TARGET_NR_setdomainname	121 /* ok */
+#define TARGET_NR_uname		122 /* remove */
+#define TARGET_NR_modify_ldt		123 /* remove */
+#define TARGET_NR_adjtimex		124 /* ok */
+#define TARGET_NR_mprotect		125 /* remove */
+#define TARGET_NR_sigprocmask	126 /* obsolete -> sys_rt_sigprocmask */
+#define TARGET_NR_create_module	127 /* remove */
+#define TARGET_NR_init_module	128 /* ok */
+#define TARGET_NR_delete_module	129 /* ok */
+#define TARGET_NR_get_kernel_syms	130 /* remove */
+#define TARGET_NR_quotactl		131 /* ok */
+#define TARGET_NR_getpgid		132 /* ok */
+#define TARGET_NR_fchdir		133 /* ok */
+#define TARGET_NR_bdflush		134 /* remove */
+#define TARGET_NR_sysfs		135 /* needed for busybox */
+#define TARGET_NR_personality	136 /* ok */
+#define TARGET_NR_afs_syscall	137 /* Syscall for Andrew File System */
+#define TARGET_NR_setfsuid		138 /* ok */
+#define TARGET_NR_setfsgid		139 /* ok */
+#define TARGET_NR__llseek		140 /* remove only lseek */
+#define TARGET_NR_getdents		141 /* ok or getdents64 */
+#define TARGET_NR__newselect		142 /* remove */
+#define TARGET_NR_flock		143 /* ok */
+#define TARGET_NR_msync		144 /* remove */
+#define TARGET_NR_readv		145 /* ok */
+#define TARGET_NR_writev		146 /* ok */
+#define TARGET_NR_getsid		147 /* ok */
+#define TARGET_NR_fdatasync		148 /* ok */
+#define TARGET_NR__sysctl		149 /* remove */
+#define TARGET_NR_mlock		150 /* ok - nommu or mmu */
+#define TARGET_NR_munlock		151 /* ok - nommu or mmu */
+#define TARGET_NR_mlockall		152 /* ok - nommu or mmu */
+#define TARGET_NR_munlockall		153 /* ok - nommu or mmu */
+#define TARGET_NR_sched_setparam		154 /* ok */
+#define TARGET_NR_sched_getparam		155 /* ok */
+#define TARGET_NR_sched_setscheduler		156 /* ok */
+#define TARGET_NR_sched_getscheduler		157 /* ok */
+#define TARGET_NR_sched_yield		158 /* ok */
+#define TARGET_NR_sched_get_priority_max	159 /* ok */
+#define TARGET_NR_sched_get_priority_min	160 /* ok */
+#define TARGET_NR_sched_rr_get_interval	161 /* ok */
+#define TARGET_NR_nanosleep		162 /* ok */
+#define TARGET_NR_mremap		163 /* ok - nommu or mmu */
+#define TARGET_NR_setresuid		164 /* ok */
+#define TARGET_NR_getresuid		165 /* ok */
+#define TARGET_NR_vm86		166 /* remove */
+#define TARGET_NR_query_module	167 /* ok */
+#define TARGET_NR_poll		168 /* obsolete -> sys_ppoll */
+#define TARGET_NR_nfsservctl		169 /* ok */
+#define TARGET_NR_setresgid		170 /* ok */
+#define TARGET_NR_getresgid		171 /* ok */
+#define TARGET_NR_prctl		172 /* ok */
+#define TARGET_NR_rt_sigreturn	173 /* ok */
+#define TARGET_NR_rt_sigaction	174 /* ok */
+#define TARGET_NR_rt_sigprocmask	175 /* ok */
+#define TARGET_NR_rt_sigpending	176 /* ok */
+#define TARGET_NR_rt_sigtimedwait	177 /* ok */
+#define TARGET_NR_rt_sigqueueinfo	178 /* ok */
+#define TARGET_NR_rt_sigsuspend	179 /* ok */
+#define TARGET_NR_pread64		180 /* ok */
+#define TARGET_NR_pwrite64		181 /* ok */
+#define TARGET_NR_chown		182 /* obsolete -> fchownat */
+#define TARGET_NR_getcwd		183 /* ok */
+#define TARGET_NR_capget		184 /* ok */
+#define TARGET_NR_capset		185 /* ok */
+#define TARGET_NR_sigaltstack	186 /* remove */
+#define TARGET_NR_sendfile		187 /* ok -> exist 64bit version*/
+#define TARGET_NR_getpmsg		188 /* remove - some people actually want streams */
+#define TARGET_NR_putpmsg		189 /* remove - some people actually want streams */
+#define TARGET_NR_vfork		190 /* for noMMU - group with clone -> maybe remove */
+#define TARGET_NR_ugetrlimit		191 /* remove - SuS compliant getrlimit */
+#define TARGET_NR_mmap2		192 /* ok */
+#define TARGET_NR_truncate64		193 /* ok */
+#define TARGET_NR_ftruncate64	194 /* ok */
+#define TARGET_NR_stat64		195 /* remove _ARCH_WANT_STAT64 */
+#define TARGET_NR_lstat64		196 /* remove _ARCH_WANT_STAT64 */
+#define TARGET_NR_fstat64		197 /* remove _ARCH_WANT_STAT64 */
+#define TARGET_NR_lchown32		198 /* ok - without 32 */
+#define TARGET_NR_getuid32		199 /* ok - without 32 */
+#define TARGET_NR_getgid32		200 /* ok - without 32 */
+#define TARGET_NR_geteuid32		201 /* ok - without 32 */
+#define TARGET_NR_getegid32		202 /* ok - without 32 */
+#define TARGET_NR_setreuid32		203 /* ok - without 32 */
+#define TARGET_NR_setregid32		204 /* ok - without 32 */
+#define TARGET_NR_getgroups32	205 /* ok - without 32 */
+#define TARGET_NR_setgroups32	206 /* ok - without 32 */
+#define TARGET_NR_fchown32		207 /* ok - without 32 */
+#define TARGET_NR_setresuid32	208 /* ok - without 32 */
+#define TARGET_NR_getresuid32	209 /* ok - without 32 */
+#define TARGET_NR_setresgid32	210 /* ok - without 32 */
+#define TARGET_NR_getresgid32	211 /* ok - without 32 */
+#define TARGET_NR_chown32		212 /* ok - without 32 -obsolete -> fchownat */
+#define TARGET_NR_setuid32		213 /* ok - without 32 */
+#define TARGET_NR_setgid32		214 /* ok - without 32 */
+#define TARGET_NR_setfsuid32		215 /* ok - without 32 */
+#define TARGET_NR_setfsgid32		216 /* ok - without 32 */
+#define TARGET_NR_pivot_root		217 /* ok */
+#define TARGET_NR_mincore		218 /* ok */
+#define TARGET_NR_madvise		219 /* ok */
+//#define TARGET_NR_madvise1		219 /* remove delete when C lib stub is removed */
+#define TARGET_NR_getdents64		220 /* ok */
+#define TARGET_NR_fcntl64		221 /* ok */
+/* 223 is unused */
+#define TARGET_NR_gettid		224 /* ok */
+#define TARGET_NR_readahead		225 /* ok */
+#define TARGET_NR_setxattr		226 /* ok */
+#define TARGET_NR_lsetxattr		227 /* ok */
+#define TARGET_NR_fsetxattr		228 /* ok */
+#define TARGET_NR_getxattr		229 /* ok */
+#define TARGET_NR_lgetxattr		230 /* ok */
+#define TARGET_NR_fgetxattr		231 /* ok */
+#define TARGET_NR_listxattr		232 /* ok */
+#define TARGET_NR_llistxattr		233 /* ok */
+#define TARGET_NR_flistxattr		234 /* ok */
+#define TARGET_NR_removexattr	235 /* ok */
+#define TARGET_NR_lremovexattr	236 /* ok */
+#define TARGET_NR_fremovexattr	237 /* ok */
+#define TARGET_NR_tkill		238 /* ok */
+#define TARGET_NR_sendfile64		239 /* ok */
+#define TARGET_NR_futex		240 /* ok */
+#define TARGET_NR_sched_setaffinity	241 /* ok */
+#define TARGET_NR_sched_getaffinity	242 /* ok */
+#define TARGET_NR_set_thread_area	243 /* remove */
+#define TARGET_NR_get_thread_area	244 /* remove */
+#define TARGET_NR_io_setup		245 /* ok */
+#define TARGET_NR_io_destroy		246 /* ok */
+#define TARGET_NR_io_getevents	247 /* ok */
+#define TARGET_NR_io_submit		248 /* ok */
+#define TARGET_NR_io_cancel		249 /* ok */
+#define TARGET_NR_fadvise64		250 /* remove -> sys_fadvise64_64 */
+/* 251 is available for reuse (was briefly sys_set_zone_reclaim) */
+#define TARGET_NR_exit_group		252 /* ok */
+#define TARGET_NR_lookup_dcookie	253 /* ok */
+#define TARGET_NR_epoll_create	254 /* ok */
+#define TARGET_NR_epoll_ctl		255 /* ok */
+#define TARGET_NR_epoll_wait		256 /* obsolete -> sys_epoll_pwait */
+#define TARGET_NR_remap_file_pages	257 /* only for mmu */
+#define TARGET_NR_set_tid_address	258 /* ok */
+#define TARGET_NR_timer_create	259 /* ok */
+#define TARGET_NR_timer_settime	(TARGET_NR_timer_create+1) /* 260 */ /* ok */
+#define TARGET_NR_timer_gettime	(TARGET_NR_timer_create+2) /* 261 */ /* ok */
+#define TARGET_NR_timer_getoverrun	(TARGET_NR_timer_create+3) /* 262 */ /* ok */
+#define TARGET_NR_timer_delete	(TARGET_NR_timer_create+4) /* 263 */ /* ok */
+#define TARGET_NR_clock_settime	(TARGET_NR_timer_create+5) /* 264 */ /* ok */
+#define TARGET_NR_clock_gettime	(TARGET_NR_timer_create+6) /* 265 */ /* ok */
+#define TARGET_NR_clock_getres	(TARGET_NR_timer_create+7) /* 266 */ /* ok */
+#define TARGET_NR_clock_nanosleep	(TARGET_NR_timer_create+8) /* 267 */ /* ok */
+#define TARGET_NR_statfs64		268 /* ok */
+#define TARGET_NR_fstatfs64		269 /* ok */
+#define TARGET_NR_tgkill		270 /* ok */
+#define TARGET_NR_utimes		271 /* obsolete -> sys_futimesat */
+#define TARGET_NR_fadvise64_64	272 /* ok */
+#define TARGET_NR_vserver		273 /* ok */
+#define TARGET_NR_mbind		274 /* only for mmu */
+#define TARGET_NR_get_mempolicy	275 /* only for mmu */
+#define TARGET_NR_set_mempolicy	276 /* only for mmu */
+#define TARGET_NR_mq_open		277 /* ok */
+#define TARGET_NR_mq_unlink		(TARGET_NR_mq_open+1) /* 278 */ /* ok */
+#define TARGET_NR_mq_timedsend	(TARGET_NR_mq_open+2) /* 279 */ /* ok */
+#define TARGET_NR_mq_timedreceive	(TARGET_NR_mq_open+3) /* 280 */ /* ok */
+#define TARGET_NR_mq_notify		(TARGET_NR_mq_open+4) /* 281 */ /* ok */
+#define TARGET_NR_mq_getsetattr	(TARGET_NR_mq_open+5) /* 282 */ /* ok */
+#define TARGET_NR_kexec_load		283 /* ok */
+#define TARGET_NR_waitid		284 /* ok */
+/* #define TARGET_NR_sys_setaltroot	285 */
+#define TARGET_NR_add_key		286 /* ok */
+#define TARGET_NR_request_key	287 /* ok */
+#define TARGET_NR_keyctl		288 /* ok */
+#define TARGET_NR_ioprio_set		289 /* ok */
+#define TARGET_NR_ioprio_get		290 /* ok */
+#define TARGET_NR_inotify_init	291 /* ok */
+#define TARGET_NR_inotify_add_watch	292 /* ok */
+#define TARGET_NR_inotify_rm_watch	293 /* ok */
+#define TARGET_NR_migrate_pages	294 /* mmu */
+#define TARGET_NR_openat		295 /* ok */
+#define TARGET_NR_mkdirat		296 /* ok */
+#define TARGET_NR_mknodat		297 /* ok */
+#define TARGET_NR_fchownat		298 /* ok */
+#define TARGET_NR_futimesat		299 /* obsolete -> sys_utimesat */
+#define TARGET_NR_fstatat64		300 /* stat64 */
+#define TARGET_NR_unlinkat		301 /* ok */
+#define TARGET_NR_renameat		302 /* ok */
+#define TARGET_NR_linkat		303 /* ok */
+#define TARGET_NR_symlinkat		304 /* ok */
+#define TARGET_NR_readlinkat		305 /* ok */
+#define TARGET_NR_fchmodat		306 /* ok */
+#define TARGET_NR_faccessat		307 /* ok */
+#define TARGET_NR_pselect6		308 /* obsolete -> sys_pselect7 */
+#define TARGET_NR_ppoll		309 /* ok */
+#define TARGET_NR_unshare		310 /* ok */
+#define TARGET_NR_set_robust_list	311 /* ok */
+#define TARGET_NR_get_robust_list	312 /* ok */
+#define TARGET_NR_splice		313 /* ok */
+#define TARGET_NR_sync_file_range	314 /* ok */
+#define TARGET_NR_tee		315 /* ok */
+#define TARGET_NR_vmsplice		316 /* ok */
+#define TARGET_NR_move_pages		317 /* mmu */
+#define TARGET_NR_getcpu		318 /* ok */
+#define TARGET_NR_epoll_pwait	319 /* ok */
+#define TARGET_NR_utimensat		320 /* ok */
+#define TARGET_NR_signalfd		321 /* ok */
+#define TARGET_NR_timerfd_create	322 /* ok */
+#define TARGET_NR_eventfd		323 /* ok */
+#define TARGET_NR_fallocate		324 /* ok */
+#define TARGET_NR_semtimedop		325 /* ok - semaphore group */
+#define TARGET_NR_timerfd_settime	326 /* ok */
+#define TARGET_NR_timerfd_gettime	327 /* ok */
+/* sysv ipc syscalls */
+#define TARGET_NR_semctl		328 /* ok */
+#define TARGET_NR_semget		329 /* ok */
+#define TARGET_NR_semop		330 /* ok */
+#define TARGET_NR_msgctl		331 /* ok */
+#define TARGET_NR_msgget		332 /* ok */
+#define TARGET_NR_msgrcv		333 /* ok */
+#define TARGET_NR_msgsnd		334 /* ok */
+#define TARGET_NR_shmat		335 /* ok */
+#define TARGET_NR_shmctl		336 /* ok */
+#define TARGET_NR_shmdt		337 /* ok */
+#define TARGET_NR_shmget		338 /* ok */
+
+
+#define TARGET_NR_signalfd4		339 /* new */
+#define TARGET_NR_eventfd2		340 /* new */
+#define TARGET_NR_epoll_create1	341 /* new */
+#define TARGET_NR_dup3		342 /* new */
+#define TARGET_NR_pipe2		343 /* new */
+#define TARGET_NR_inotify_init1	344 /* new */
+#define TARGET_NR_socket		345 /* new */
+#define TARGET_NR_socketpair		346 /* new */
+#define TARGET_NR_bind		347 /* new */
+#define TARGET_NR_listen		348 /* new */
+#define TARGET_NR_accept		349 /* new */
+#define TARGET_NR_connect		350 /* new */
+#define TARGET_NR_getsockname	351 /* new */
+#define TARGET_NR_getpeername	352 /* new */
+#define TARGET_NR_sendto		353 /* new */
+#define TARGET_NR_send		354 /* new */
+#define TARGET_NR_recvfrom		355 /* new */
+#define TARGET_NR_recv		356 /* new */
+#define TARGET_NR_setsockopt		357 /* new */
+#define TARGET_NR_getsockopt		358 /* new */
+#define TARGET_NR_shutdown		359 /* new */
+#define TARGET_NR_sendmsg		360 /* new */
+#define TARGET_NR_recvmsg		361 /* new */
+#define TARGET_NR_accept04		362 /* new */
+#define TARGET_NR_preadv                363 /* new */
+#define TARGET_NR_pwritev               364 /* new */
+#define TARGET_NR_rt_tgsigqueueinfo     365 /* new */
+#define TARGET_NR_perf_event_open       366 /* new */
+#define TARGET_NR_recvmmsg              367 /* new */
+#define TARGET_NR_fanotify_init         368
+#define TARGET_NR_fanotify_mark         369
+#define TARGET_NR_prlimit64             370
+#define TARGET_NR_name_to_handle_at     371
+#define TARGET_NR_open_by_handle_at     372
+#define TARGET_NR_clock_adjtime         373
+#define TARGET_NR_syncfs                374
+#define TARGET_NR_setns                 375
+#define TARGET_NR_sendmmsg              376
+#define TARGET_NR_process_vm_readv      377
+#define TARGET_NR_process_vm_writev     378
+#define TARGET_NR_kcmp                  379
+#define TARGET_NR_finit_module          380
+#define TARGET_NR_sched_setattr         381
+#define TARGET_NR_sched_getattr         382
+#define TARGET_NR_renameat2             383
+#define TARGET_NR_seccomp               384
+#define TARGET_NR_getrandom             385
+#define TARGET_NR_memfd_create          386
+#define TARGET_NR_bpf                   387
+#define TARGET_NR_execveat              388
diff --git a/linux-user/hexagon/target_cpu.h b/linux-user/hexagon/target_cpu.h
new file mode 100644
index 0000000000..900d0e3b6b
--- /dev/null
+++ b/linux-user/hexagon/target_cpu.h
@@ -0,0 +1,40 @@
+/*
+ * Hexagon specific CPU ABI and functions for linux-user
+ *
+ * Copyright (c) 2009 Edgar E. Iglesias
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+#ifndef HEXAGON_TARGET_CPU_H
+#define HEXAGON_TARGET_CPU_H
+
+static inline void cpu_clone_regs(CPUHexagonState *env, target_ulong newsp)
+{
+    if (newsp) {
+        env->cr[GPR_SP] = newsp;
+    }
+    env->gpr[0] = 0;
+}
+
+static inline void cpu_set_tls(CPUHexagonState *env, target_ulong newtls)
+{
+    /* TLS is not currently implemented */
+    ;
+}
+
+static inline abi_ulong get_sp_from_cpustate(CPUHexagonState *state)
+{
+    return state->cr[GPR_SP];
+}
+#endif
diff --git a/linux-user/hexagon/target_elf.h b/linux-user/hexagon/target_elf.h
new file mode 100644
index 0000000000..68213a316f
--- /dev/null
+++ b/linux-user/hexagon/target_elf.h
@@ -0,0 +1,14 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation, or (at your option) any
+ * later version. See the COPYING file in the top-level directory.
+ */
+
+#ifndef HEXAGON_TARGET_ELF_H
+#define HEXAGON_TARGET_ELF_H
+static inline const char *cpu_get_model(uint32_t eflags)
+{
+    return "any";
+}
+#endif
diff --git a/linux-user/hexagon/target_fcntl.h b/linux-user/hexagon/target_fcntl.h
new file mode 100644
index 0000000000..98d66acb55
--- /dev/null
+++ b/linux-user/hexagon/target_fcntl.h
@@ -0,0 +1,11 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation, or (at your option) any
+ * later version. See the COPYING file in the top-level directory.
+ */
+
+#ifndef HEXAGON_TARGET_FCNTL_H
+#define HEXAGON_TARGET_FCNTL_H
+#include "../generic/fcntl.h"
+#endif
diff --git a/linux-user/hexagon/target_signal.h b/linux-user/hexagon/target_signal.h
new file mode 100644
index 0000000000..49654bee32
--- /dev/null
+++ b/linux-user/hexagon/target_signal.h
@@ -0,0 +1,24 @@
+#ifndef HEXAGON_TARGET_SIGNAL_H
+#define HEXAGON_TARGET_SIGNAL_H
+
+/* this struct defines a stack used during syscall handling */
+
+typedef struct target_sigaltstack {
+	abi_ulong ss_sp;
+	abi_ulong ss_size;
+	abi_long ss_flags;
+} target_stack_t;
+
+
+/*
+ * sigaltstack controls
+ */
+#define TARGET_SS_ONSTACK     1
+#define TARGET_SS_DISABLE     2
+
+#define TARGET_MINSIGSTKSZ    2048
+#define TARGET_SIGSTKSZ       8192
+
+#include "../generic/signal.h"
+
+#endif /* HEXAGON_TARGET_SIGNAL_H */
diff --git a/linux-user/hexagon/target_structs.h b/linux-user/hexagon/target_structs.h
new file mode 100644
index 0000000000..a99e8bcbe7
--- /dev/null
+++ b/linux-user/hexagon/target_structs.h
@@ -0,0 +1,58 @@
+/*
+ * Hexagon specific structures for linux-user
+ *
+ * Copyright (c) 2013 Fabrice Bellard
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+#ifndef HEXAGON_TARGET_STRUCTS_H
+#define HEXAGON_TARGET_STRUCTS_H
+
+struct target_ipc_perm {
+    abi_int __key;                      /* Key.  */
+    abi_uint uid;                       /* Owner's user ID.  */
+    abi_uint gid;                       /* Owner's group ID.  */
+    abi_uint cuid;                      /* Creator's user ID.  */
+    abi_uint cgid;                      /* Creator's group ID.  */
+    abi_ushort mode;                    /* Read/write permission.  */
+    abi_ushort __pad1;
+    abi_ushort __seq;                   /* Sequence number.  */
+    abi_ushort __pad2;
+    abi_ulong __unused1;
+    abi_ulong __unused2;
+};
+
+struct target_shmid_ds {
+    struct target_ipc_perm shm_perm;    /* operation permission struct */
+    abi_long shm_segsz;                 /* size of segment in bytes */
+    abi_ulong shm_atime;                /* time of last shmat() */
+#if TARGET_ABI_BITS == 32
+    abi_ulong __unused1;
+#endif
+    abi_ulong shm_dtime;                /* time of last shmdt() */
+#if TARGET_ABI_BITS == 32
+    abi_ulong __unused2;
+#endif
+    abi_ulong shm_ctime;                /* time of last change by shmctl() */
+#if TARGET_ABI_BITS == 32
+    abi_ulong __unused3;
+#endif
+    abi_int shm_cpid;                   /* pid of creator */
+    abi_int shm_lpid;                   /* pid of last shmop */
+    abi_ulong shm_nattch;               /* number of current attaches */
+    abi_ulong __unused4;
+    abi_ulong __unused5;
+};
+
+#endif
diff --git a/linux-user/hexagon/target_syscall.h b/linux-user/hexagon/target_syscall.h
new file mode 100644
index 0000000000..15ca85f17d
--- /dev/null
+++ b/linux-user/hexagon/target_syscall.h
@@ -0,0 +1,23 @@
+#ifndef HEXAGON_TARGET_SYSCALL_H
+#define HEXAGON_TARGET_SYSCALL_H
+
+#define UNAME_MACHINE "hexagon"
+#define UNAME_MINIMUM_RELEASE "2.6.32"
+
+/* We use hexagon_reg_t to keep things similar to the kernel sources.  */
+typedef uint32_t hexagon_reg_t;
+
+struct target_pt_regs {
+        hexagon_reg_t gpr[32];
+        hexagon_reg_t cr[32];
+        hexagon_reg_t sr[64];
+};
+
+#define TARGET_CLONE_BACKWARDS
+#define TARGET_MINSIGSTKSZ      2048
+#define TARGET_MLOCKALL_MCL_CURRENT 1
+#define TARGET_MLOCKALL_MCL_FUTURE  2
+
+#define TARGET_WANT_NI_OLD_SELECT
+
+#endif
diff --git a/linux-user/hexagon/termbits.h b/linux-user/hexagon/termbits.h
new file mode 100644
index 0000000000..c825cd2f5e
--- /dev/null
+++ b/linux-user/hexagon/termbits.h
@@ -0,0 +1,214 @@
+/* from asm/termbits.h */
+
+#define TARGET_NCCS 19
+
+struct target_termios {
+    unsigned int c_iflag;               /* input mode flags */
+    unsigned int c_oflag;               /* output mode flags */
+    unsigned int c_cflag;               /* control mode flags */
+    unsigned int c_lflag;               /* local mode flags */
+    unsigned char c_line;                    /* line discipline */
+    unsigned char c_cc[TARGET_NCCS];                /* control characters */
+};
+
+/* c_iflag bits */
+#define TARGET_IGNBRK  0000001
+#define TARGET_BRKINT  0000002
+#define TARGET_IGNPAR  0000004
+#define TARGET_PARMRK  0000010
+#define TARGET_INPCK   0000020
+#define TARGET_ISTRIP  0000040
+#define TARGET_INLCR   0000100
+#define TARGET_IGNCR   0000200
+#define TARGET_ICRNL   0000400
+#define TARGET_IUCLC   0001000
+#define TARGET_IXON    0002000
+#define TARGET_IXANY   0004000
+#define TARGET_IXOFF   0010000
+#define TARGET_IMAXBEL 0020000
+
+/* c_oflag bits */
+#define TARGET_OPOST   0000001
+#define TARGET_OLCUC   0000002
+#define TARGET_ONLCR   0000004
+#define TARGET_OCRNL   0000010
+#define TARGET_ONOCR   0000020
+#define TARGET_ONLRET  0000040
+#define TARGET_OFILL   0000100
+#define TARGET_OFDEL   0000200
+#define TARGET_NLDLY   0000400
+#define   TARGET_NL0   0000000
+#define   TARGET_NL1   0000400
+#define TARGET_CRDLY   0003000
+#define   TARGET_CR0   0000000
+#define   TARGET_CR1   0001000
+#define   TARGET_CR2   0002000
+#define   TARGET_CR3   0003000
+#define TARGET_TABDLY  0014000
+#define   TARGET_TAB0  0000000
+#define   TARGET_TAB1  0004000
+#define   TARGET_TAB2  0010000
+#define   TARGET_TAB3  0014000
+#define   TARGET_XTABS 0014000
+#define TARGET_BSDLY   0020000
+#define   TARGET_BS0   0000000
+#define   TARGET_BS1   0020000
+#define TARGET_VTDLY   0040000
+#define   TARGET_VT0   0000000
+#define   TARGET_VT1   0040000
+#define TARGET_FFDLY   0100000
+#define   TARGET_FF0   0000000
+#define   TARGET_FF1   0100000
+
+/* c_cflag bit meaning */
+#define TARGET_CBAUD   0010017
+#define  TARGET_B0     0000000         /* hang up */
+#define  TARGET_B50    0000001
+#define  TARGET_B75    0000002
+#define  TARGET_B110   0000003
+#define  TARGET_B134   0000004
+#define  TARGET_B150   0000005
+#define  TARGET_B200   0000006
+#define  TARGET_B300   0000007
+#define  TARGET_B600   0000010
+#define  TARGET_B1200  0000011
+#define  TARGET_B1800  0000012
+#define  TARGET_B2400  0000013
+#define  TARGET_B4800  0000014
+#define  TARGET_B9600  0000015
+#define  TARGET_B19200 0000016
+#define  TARGET_B38400 0000017
+#define TARGET_EXTA B19200
+#define TARGET_EXTB B38400
+#define TARGET_CSIZE   0000060
+#define   TARGET_CS5   0000000
+#define   TARGET_CS6   0000020
+#define   TARGET_CS7   0000040
+#define   TARGET_CS8   0000060
+#define TARGET_CSTOPB  0000100
+#define TARGET_CREAD   0000200
+#define TARGET_PARENB  0000400
+#define TARGET_PARODD  0001000
+#define TARGET_HUPCL   0002000
+#define TARGET_CLOCAL  0004000
+#define TARGET_CBAUDEX 0010000
+#define  TARGET_B57600  0010001
+#define  TARGET_B115200 0010002
+#define  TARGET_B230400 0010003
+#define  TARGET_B460800 0010004
+#define TARGET_CIBAUD    002003600000  /* input baud rate (not used) */
+#define TARGET_CRTSCTS   020000000000          /* flow control */
+
+/* c_lflag bits */
+#define TARGET_ISIG    0000001
+#define TARGET_ICANON  0000002
+#define TARGET_XCASE   0000004
+#define TARGET_ECHO    0000010
+#define TARGET_ECHOE   0000020
+#define TARGET_ECHOK   0000040
+#define TARGET_ECHONL  0000100
+#define TARGET_NOFLSH  0000200
+#define TARGET_TOSTOP  0000400
+#define TARGET_ECHOCTL 0001000
+#define TARGET_ECHOPRT 0002000
+#define TARGET_ECHOKE  0004000
+#define TARGET_FLUSHO  0010000
+#define TARGET_PENDIN  0040000
+#define TARGET_IEXTEN  0100000
+
+/* c_cc character offsets */
+#define TARGET_VINTR	0
+#define TARGET_VQUIT	1
+#define TARGET_VERASE	2
+#define TARGET_VKILL	3
+#define TARGET_VEOF	4
+#define TARGET_VTIME	5
+#define TARGET_VMIN	6
+#define TARGET_VSWTC	7
+#define TARGET_VSTART	8
+#define TARGET_VSTOP	9
+#define TARGET_VSUSP	10
+#define TARGET_VEOL	11
+#define TARGET_VREPRINT	12
+#define TARGET_VDISCARD	13
+#define TARGET_VWERASE	14
+#define TARGET_VLNEXT	15
+#define TARGET_VEOL2	16
+
+/* ioctls */
+
+#define TARGET_TCGETS		0x5401
+#define TARGET_TCSETS		0x5402
+#define TARGET_TCSETSW		0x5403
+#define TARGET_TCSETSF		0x5404
+#define TARGET_TCGETA		0x5405
+#define TARGET_TCSETA		0x5406
+#define TARGET_TCSETAW		0x5407
+#define TARGET_TCSETAF		0x5408
+#define TARGET_TCSBRK		0x5409
+#define TARGET_TCXONC		0x540A
+#define TARGET_TCFLSH		0x540B
+
+#define TARGET_TIOCEXCL	0x540C
+#define TARGET_TIOCNXCL	0x540D
+#define TARGET_TIOCSCTTY	0x540E
+#define TARGET_TIOCGPGRP	0x540F
+#define TARGET_TIOCSPGRP	0x5410
+#define TARGET_TIOCOUTQ	0x5411
+#define TARGET_TIOCSTI		0x5412
+#define TARGET_TIOCGWINSZ	0x5413
+#define TARGET_TIOCSWINSZ	0x5414
+#define TARGET_TIOCMGET	0x5415
+#define TARGET_TIOCMBIS	0x5416
+#define TARGET_TIOCMBIC	0x5417
+#define TARGET_TIOCMSET	0x5418
+#define TARGET_TIOCGSOFTCAR	0x5419
+#define TARGET_TIOCSSOFTCAR	0x541A
+#define TARGET_FIONREAD	0x541B
+#define TARGET_TIOCINQ		TARGET_FIONREAD
+#define TARGET_TIOCLINUX	0x541C
+#define TARGET_TIOCCONS	0x541D
+#define TARGET_TIOCGSERIAL	0x541E
+#define TARGET_TIOCSSERIAL	0x541F
+#define TARGET_TIOCPKT		0x5420
+#define TARGET_FIONBIO		0x5421
+#define TARGET_TIOCNOTTY	0x5422
+#define TARGET_TIOCSETD	0x5423
+#define TARGET_TIOCGETD	0x5424
+#define TARGET_TCSBRKP		0x5425	/* Needed for POSIX tcsendbreak() */
+#define TARGET_TIOCTTYGSTRUCT	0x5426  /* For debugging only */
+#define TARGET_TIOCSBRK	0x5427  /* BSD compatibility */
+#define TARGET_TIOCCBRK	0x5428  /* BSD compatibility */
+#define TARGET_TIOCGSID	0x5429  /* Return the session ID of FD */
+#define TARGET_TIOCGPTN	TARGET_IOR('T',0x30, unsigned int) /* Get Pty Number (of pty-mux device) */
+#define TARGET_TIOCSPTLCK	TARGET_IOW('T',0x31, int)  /* Lock/unlock Pty */
+#define TARGET_TIOCGPTPEER      TARGET_IO('T', 0x41) /* Safely open the slave */
+
+#define TARGET_FIONCLEX	0x5450  /* these numbers need to be adjusted. */
+#define TARGET_FIOCLEX		0x5451
+#define TARGET_FIOASYNC	0x5452
+#define TARGET_TIOCSERCONFIG	0x5453
+#define TARGET_TIOCSERGWILD	0x5454
+#define TARGET_TIOCSERSWILD	0x5455
+#define TARGET_TIOCGLCKTRMIOS	0x5456
+#define TARGET_TIOCSLCKTRMIOS	0x5457
+#define TARGET_TIOCSERGSTRUCT	0x5458 /* For debugging only */
+#define TARGET_TIOCSERGETLSR   0x5459 /* Get line status register */
+#define TARGET_TIOCSERGETMULTI 0x545A /* Get multiport config  */
+#define TARGET_TIOCSERSETMULTI 0x545B /* Set multiport config */
+
+#define TARGET_TIOCMIWAIT	0x545C	/* wait for a change on serial input line(s) */
+#define TARGET_TIOCGICOUNT	0x545D	/* read serial port inline interrupt counts */
+#define TARGET_TIOCGHAYESESP   0x545E  /* Get Hayes ESP configuration */
+#define TARGET_TIOCSHAYESESP   0x545F  /* Set Hayes ESP configuration */
+
+/* Used for packet mode */
+#define TARGET_TIOCPKT_DATA		 0
+#define TARGET_TIOCPKT_FLUSHREAD	 1
+#define TARGET_TIOCPKT_FLUSHWRITE	 2
+#define TARGET_TIOCPKT_STOP		 4
+#define TARGET_TIOCPKT_START		 8
+#define TARGET_TIOCPKT_NOSTOP		16
+#define TARGET_TIOCPKT_DOSTOP		32
+
+#define TARGET_TIOCSER_TEMT    0x01	/* Transmitter physically empty */
diff --git a/linux-user/qemu.h b/linux-user/qemu.h
index b4959e41c6..27eb25ef17 100644
--- a/linux-user/qemu.h
+++ b/linux-user/qemu.h
@@ -115,7 +115,8 @@ typedef struct TaskState {
     int sim_syscalls;
     abi_ulong tp_value;
 #endif
-#if defined(TARGET_ARM) || defined(TARGET_M68K)
+#if defined(TARGET_ARM) || defined(TARGET_M68K) || \
+    defined(TARGET_HEXAGON)
     /* Extra fields for semihosted binaries.  */
     abi_ulong heap_base;
     abi_ulong heap_limit;
diff --git a/linux-user/signal.c b/linux-user/signal.c
index 602b631b92..22f8f778f9 100644
--- a/linux-user/signal.c
+++ b/linux-user/signal.c
@@ -236,7 +236,7 @@ int do_sigprocmask(int how, const sigset_t *set, sigset_t *oldset)
     return 0;
 }
 
-#if !defined(TARGET_NIOS2)
+#if !defined(TARGET_NIOS2) && !defined(TARGET_HEXAGON)
 /* Just set the guest's signal mask to the specified value; the
  * caller is assumed to have called block_signals() already.
  */
diff --git a/linux-user/strace.c b/linux-user/strace.c
index 33f4a506a2..a1d3440834 100644
--- a/linux-user/strace.c
+++ b/linux-user/strace.c
@@ -5,6 +5,7 @@
 #include <sys/shm.h>
 #include <sys/select.h>
 #include <sys/mount.h>
+#include <sys/sysmacros.h>
 #include <arpa/inet.h>
 #include <netinet/tcp.h>
 #include <linux/if_packet.h>
diff --git a/linux-user/syscall.c b/linux-user/syscall.c
index ae3c0dfef7..88c4fabfff 100644
--- a/linux-user/syscall.c
+++ b/linux-user/syscall.c
@@ -863,7 +863,12 @@ static abi_ulong brk_page;
 
 void target_set_brk(abi_ulong new_brk)
 {
+/* XXX: Hexagon does not align the heap to the page boundary */
+#if defined(TARGET_HEXAGON)
+    target_original_brk = target_brk = new_brk;
+#else
     target_original_brk = target_brk = HOST_PAGE_ALIGN(new_brk);
+#endif
     brk_page = HOST_PAGE_ALIGN(target_brk);
 }
 
diff --git a/linux-user/syscall_defs.h b/linux-user/syscall_defs.h
index 18d434d6dc..feee49b64d 100644
--- a/linux-user/syscall_defs.h
+++ b/linux-user/syscall_defs.h
@@ -59,7 +59,8 @@
 #if (defined(TARGET_I386) && defined(TARGET_ABI32)) \
     || (defined(TARGET_ARM) && defined(TARGET_ABI32)) \
     || defined(TARGET_SPARC) \
-    || defined(TARGET_M68K) || defined(TARGET_SH4) || defined(TARGET_CRIS)
+    || defined(TARGET_M68K) || defined(TARGET_SH4) || defined(TARGET_CRIS) \
+    || defined(TARGET_HEXAGON)
     /* 16 bit uid wrappers emulation */
 #define USE_UID16
 #define target_id uint16_t
@@ -72,7 +73,7 @@
     || defined(TARGET_S390X) \
     || defined(TARGET_OPENRISC) || defined(TARGET_TILEGX) \
     || defined(TARGET_NIOS2) || defined(TARGET_RISCV) \
-    || defined(TARGET_XTENSA)
+    || defined(TARGET_XTENSA) || defined(TARGET_HEXAGON)
 
 #define TARGET_IOC_SIZEBITS	14
 #define TARGET_IOC_DIRBITS	2
@@ -1149,7 +1150,8 @@ struct target_winsize {
 
 #if (defined(TARGET_I386) && defined(TARGET_ABI32)) \
     || (defined(TARGET_ARM) && defined(TARGET_ABI32)) \
-    || defined(TARGET_CRIS)
+    || defined(TARGET_CRIS) || defined(TARGET_HEXAGON)
+
 struct target_stat {
 	unsigned short st_dev;
 	unsigned short __pad1;
diff --git a/target/hexagon/Makefile.objs b/target/hexagon/Makefile.objs
new file mode 100644
index 0000000000..3b3c04345e
--- /dev/null
+++ b/target/hexagon/Makefile.objs
@@ -0,0 +1,49 @@
+obj-y += translate.o op_helper.o helper.o cpu.o hexagon-semi.o
+obj-y += gdbstub.o decoder.o
+
+# build and run feature list generator
+feat-src = $(SRC_PATH)/target/$(TARGET_BASE_ARCH)/generator/
+feat-dst = $(BUILD_DIR)/$(TARGET_DIR)
+ifneq ($(MAKECMDGOALS),clean)
+GENERATED_FILES += target/$(TARGET_BASE_ARCH)/decoder.c
+endif
+
+$(feat-dst)instruction-decoding.json: $(feat-dst)instruction-decoding.json-timestamp
+	@cmp $< $@ >/dev/null 2>&1 || cp $< $@
+
+$(feat-dst)instruction-decoding.json-timestamp: $(feat-dst)best-decoding
+	$(call quiet-command,$< $(feat-src)instructions.csv 4 3 2 > $@,"GEN","$(TARGET_DIR)instruction-decoding.json")
+
+$(feat-dst)sub-instruction-decoding.json: $(feat-dst)sub-instruction-decoding.json-timestamp
+	@cmp $< $@ >/dev/null 2>&1 || cp $< $@
+
+$(feat-dst)sub-instruction-decoding.json-timestamp: $(feat-dst)best-decoding
+	$(call quiet-command,$< $(feat-src)sub-instructions.csv 4 3 2 > $@,"GEN","$(TARGET_DIR)sub-instruction-decoding.json")
+
+$(feat-dst)best-decoding: $(feat-src)best-decoding.c
+	$(call quiet-command,$(HOST_CC) -o $@ $<,"CC","$(TARGET_DIR)best-decoding")
+
+# semantics
+$(feat-dst)semantics : $(feat-dst)lex.yy.c $(feat-dst)semantics.tab.c
+	$(call quiet-command,$(HOST_CC) -I$(feat-src)semantics -o $@ $^,"CC","$(TARGET_DIR)semantics")
+
+$(feat-dst)semantics.tab.h $(feat-dst)semantics.tab.c : $(feat-src)semantics/semantics.y $(feat-src)semantics/semantics_struct.h
+	$(call quiet-command,bison --defines=$(feat-dst)semantics.tab.h --output=$(feat-dst)semantics.tab.c $<,"BISON","$(TARGET_DIR)semantics.tab.c")
+
+$(feat-dst)lex.yy.c : $(feat-src)semantics/semantics.lex $(feat-dst)semantics.tab.h $(feat-src)semantics/semantics_struct.h
+	$(call quiet-command,flex --outfile=$(feat-dst)lex.yy.c $<,"FLEX","$(TARGET_DIR)lex.yy.c")
+
+target/$(TARGET_BASE_ARCH)/decoder.c: $(feat-src)decoder_gen.py $(feat-dst)semantics $(feat-dst)instruction-decoding.json $(feat-dst)sub-instruction-decoding.json
+	$(call quiet-command,$< $(feat-dst)semantics $(feat-src)meta-instructions.csv $(feat-src)instructions.csv $(feat-src)sub-instructions.csv $(feat-src)const-ext.csv $(feat-dst)instruction-decoding.json $(feat-dst)sub-instruction-decoding.json target/$(TARGET_BASE_ARCH)/decoder.c target/$(TARGET_BASE_ARCH)/decoder.h,"GEN","$(TARGET_DIR)decoder.c")
+
+target/$(TARGET_BASE_ARCH)/decoder.o : target/$(TARGET_BASE_ARCH)/decoder.c
+
+clean-target:
+	rm -f target/$(TARGET_BASE_ARCH)/decoder.o
+	rm -f target/$(TARGET_BASE_ARCH)/decoder.c target/$(TARGET_BASE_ARCH)/decoder.h
+	rm -f $(feat-dst)lex.yy.c
+	rm -f $(feat-dst)semantics.tab.h $(feat-dst)semantics.tab.c
+	rm -f $(feat-dst)semantics
+	rm -f $(feat-dst)best-decoding
+	rm -f $(feat-dst)instruction-decoding.json $(feat-dst)sub-instruction-decoding.json
+	rm -f $(feat-dst)instruction-decoding.json-timestamp $(feat-dst)sub-instruction-decoding.json-timestamp
diff --git a/target/hexagon/cpu-qom.h b/target/hexagon/cpu-qom.h
new file mode 100644
index 0000000000..b5fc1359d1
--- /dev/null
+++ b/target/hexagon/cpu-qom.h
@@ -0,0 +1,59 @@
+/*
+ * QEMU Hexagon CPU
+ *
+ * Copyright (c) 2017-2019 Comsecuris UG (haftungsbeschraenkt)
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef QEMU_HEXAGON_CPU_QOM_H
+#define QEMU_HEXAGON_CPU_QOM_H
+
+#include "qom/cpu.h"
+
+#define TYPE_HEXAGON_CPU "hexagon-cpu"
+
+#define HEXAGON_CPU_CLASS(klass) \
+    OBJECT_CLASS_CHECK(HexagonCPUClass, (klass), TYPE_HEXAGON_CPU)
+#define HEXAGON_CPU(obj) \
+    OBJECT_CHECK(HexagonCPU, (obj), TYPE_HEXAGON_CPU)
+#define HEXAGON_CPU_GET_CLASS(obj) \
+    OBJECT_GET_CLASS(HexagonCPUClass, (obj), TYPE_HEXAGON_CPU)
+
+/**
+ * HexagonCPUClass:
+ * @parent_realize: The parent class' realize handler.
+ * @parent_reset: The parent class' reset handler.
+ *
+ * A Hexagon CPU model.
+ */
+typedef struct HexagonCPUClass {
+    /*< private >*/
+    CPUClass parent_class;
+    /*< public >*/
+
+    DeviceRealize parent_realize;
+    void (*parent_reset)(CPUState *cpu);
+} HexagonCPUClass;
+
+typedef struct HexagonCPU HexagonCPU;
+
+#endif
diff --git a/target/hexagon/cpu.c b/target/hexagon/cpu.c
new file mode 100644
index 0000000000..3ad9cc359b
--- /dev/null
+++ b/target/hexagon/cpu.c
@@ -0,0 +1,157 @@
+/*
+ * QEMU Hexagon CPU
+ *
+ * Copyright (c) 2017-2019 Comsecuris UG (haftungsbeschraenkt)
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "qemu/osdep.h"
+#include "qapi/error.h"
+#include "cpu.h"
+#include "qemu-common.h"
+#include "hw/qdev-properties.h"
+#include "migration/vmstate.h"
+#include "exec/exec-all.h"
+
+static void hexagon_cpu_set_pc(CPUState *cs, vaddr value)
+{
+    HexagonCPU *cpu = HEXAGON_CPU(cs);
+
+    cpu->env.cr[CR_PC] = value;
+}
+
+static bool hexagon_cpu_has_work(CPUState *cs)
+{
+    return true;
+}
+
+/* CPUClass::reset() */
+static void hexagon_cpu_reset(CPUState *s)
+{
+    HexagonCPU *cpu = HEXAGON_CPU(s);
+    CPUHexagonState *env = &cpu->env;
+
+    env->cr[CR_PC] = cpu->cfg.base_vectors;
+
+    /* XXX: HTID is expected to be 1, so we fix it to 1 */
+    env->sr[CR_HTID] = 0;
+}
+
+static void hexagon_disas_set_info(CPUState *cpu, disassemble_info *info)
+{
+}
+
+static void hexagon_cpu_realizefn(DeviceState *dev, Error **errp)
+{
+    CPUState *cs = CPU(dev);
+    HexagonCPUClass *hexcc = HEXAGON_CPU_GET_CLASS(dev);
+    Error *local_err = NULL;
+
+    cpu_exec_realizefn(cs, &local_err);
+    if (local_err != NULL) {
+        error_propagate(errp, local_err);
+        return;
+    }
+
+    qemu_init_vcpu(cs);
+
+    hexcc->parent_realize(dev, errp);
+}
+
+static void hexagon_cpu_initfn(Object *obj)
+{
+    CPUState *cs = CPU(obj);
+    HexagonCPU *cpu = HEXAGON_CPU(obj);
+    CPUHexagonState *env = &cpu->env;
+
+    cs->env_ptr = env;
+}
+
+static const VMStateDescription vmstate_hexagon_cpu = {
+    .name = "cpu",
+    .unmigratable = 1,
+};
+
+static Property hexagon_properties[] = {
+    DEFINE_PROP_UINT32("base-vectors", HexagonCPU, cfg.base_vectors, 0),
+    DEFINE_PROP_END_OF_LIST(),
+};
+
+static ObjectClass *hexagon_cpu_class_by_name(const char *cpu_model)
+{
+    return object_class_by_name(TYPE_HEXAGON_CPU);
+}
+
+static void hexagon_cpu_class_init(ObjectClass *oc, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(oc);
+    CPUClass *cc = CPU_CLASS(oc);
+    HexagonCPUClass *hexcc = HEXAGON_CPU_CLASS(oc);
+
+    hexcc->parent_realize = dc->realize;
+    dc->realize = hexagon_cpu_realizefn;
+
+    hexcc->parent_reset = cc->reset;
+    cc->reset = hexagon_cpu_reset;
+
+    cc->class_by_name = hexagon_cpu_class_by_name;
+    cc->has_work = hexagon_cpu_has_work;
+    cc->do_interrupt = hexagon_cpu_do_interrupt;
+    cc->cpu_exec_interrupt = hexagon_cpu_exec_interrupt;
+    cc->dump_state = hexagon_cpu_dump_state;
+    cc->set_pc = hexagon_cpu_set_pc;
+    cc->gdb_read_register = hexagon_cpu_gdb_read_register;
+    cc->gdb_write_register = hexagon_cpu_gdb_write_register;
+    cc->handle_mmu_fault = hexagon_cpu_handle_mmu_fault;
+    dc->vmsd = &vmstate_hexagon_cpu;
+    dc->props = hexagon_properties;
+    cc->gdb_num_core_regs = 32 + 5;
+    cc->tcg_initialize = hexagon_tcg_init;
+
+    cc->disas_set_info = hexagon_disas_set_info;
+}
+
+static const TypeInfo hexagon_cpu_type_info = {
+    .name = TYPE_HEXAGON_CPU,
+    .parent = TYPE_CPU,
+    .instance_size = sizeof(HexagonCPU),
+    .instance_init = hexagon_cpu_initfn,
+    .class_size = sizeof(HexagonCPUClass),
+    .class_init = hexagon_cpu_class_init,
+};
+
+static void hexagon_cpu_register_types(void)
+{
+    type_register_static(&hexagon_cpu_type_info);
+}
+
+type_init(hexagon_cpu_register_types)
+
+int hexagon_cpu_handle_mmu_fault(CPUState *cs,
+                                 vaddr address,
+                                 int size,
+                                 int rw,
+                                 int mmu_idx) {
+    cs->exception_index = 0xaa;
+    cpu_dump_state(cs, stderr, fprintf, 0);
+    return 1;
+}
diff --git a/target/hexagon/cpu.h b/target/hexagon/cpu.h
new file mode 100644
index 0000000000..1fefb8fce4
--- /dev/null
+++ b/target/hexagon/cpu.h
@@ -0,0 +1,182 @@
+/*
+ * Hexagon virtual CPU header
+ *
+ * Copyright (c) 2017-2019 Comsecuris UG (haftungsbeschraenkt)
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef HEXAGON_CPU_H
+#define HEXAGON_CPU_H
+
+#include "qemu-common.h"
+#include "cpu-qom.h"
+
+#define TARGET_LONG_BITS 32
+
+#define CPUArchState struct CPUHexagonState
+
+#include "exec/cpu-defs.h"
+#include "fpu/softfloat.h"
+
+#define EXCP_CPU_DUMP   1
+#define EXCP_HW_EXCP    2
+#define EXCP_TRAP_INSN  3
+
+// General Purpose Registers Aliases
+#define GPR_SP 29
+#define GPR_FP 30
+#define GPR_LR 31
+
+// Control Registers Aliases
+#define CR_SA0 0
+#define CR_LC0 1
+#define CR_SA1 2
+#define CR_LC1 3
+#define CR_P 4
+#define CR_reserved 5
+#define CR_M0 6
+#define CR_M1 7
+#define CR_USR 8
+#define CR_HTID 8
+#define CR_PC 9
+#define CR_UGP 10
+#define CR_GP 11
+#define CR_CS0 12
+#define CR_CS1 13
+#define CR_UPCYCLELO 14
+#define CR_UPCYCLEHI 15
+#define CR_FRAMELIMIT 16
+#define CR_FRAMEKEY 17
+#define CR_PKTCOUNTLO 18
+#define CR_PKTCOUNTHI 19
+#define CR_UTIMERLO 30
+#define CR_UTIMERHI 31
+
+struct CPUHexagonState;
+typedef struct CPUHexagonState CPUHexagonState;
+
+struct CPUHexagonState {
+
+    uint32_t gpr[32];
+    uint32_t cr[32];
+    uint32_t sr[64];
+
+    /* Temporary registers to handle .new predicates and exceptions */
+    uint32_t gpr_new[32];
+    uint32_t cr_new[32];
+
+    uint32_t pc_written;
+    uint32_t pc_trace;
+
+    uint32_t sa[2];
+    uint32_t lc[2];
+    uint32_t lpcfg;
+
+
+    /* Fields up to this point are cleared by a CPU reset */
+    struct {} end_reset_fields;
+
+    CPU_COMMON
+};
+
+/**
+ * HexagonCPU:
+ * @env: #CPUHexagonState
+ *
+ * A Hexagon CPU.
+ */
+struct HexagonCPU {
+    /*< private >*/
+    CPUState parent_obj;
+
+    /*< public >*/
+    
+    /* Microblaze Configuration Settings */
+    struct {
+        uint32_t base_vectors;
+    } cfg;
+
+    CPUHexagonState env;
+};
+
+static inline HexagonCPU *hexagon_env_get_cpu(CPUHexagonState *env)
+{
+    return container_of(env, HexagonCPU, env);
+}
+
+#define ENV_GET_CPU(e) CPU(hexagon_env_get_cpu(e))
+
+#define ENV_OFFSET offsetof(HexagonCPU, env)
+
+void hexagon_cpu_do_interrupt(CPUState *cs);
+bool hexagon_cpu_exec_interrupt(CPUState *cs, int int_req);
+void hexagon_cpu_dump_state(CPUState *cpu,
+                            FILE *f,
+                            fprintf_function cpu_fprintf,
+                            int flags);
+hwaddr hexagon_cpu_get_phys_page_debug(CPUState *cpu, vaddr addr);
+int hexagon_cpu_gdb_read_register(CPUState *cpu, uint8_t *buf, int reg);
+int hexagon_cpu_gdb_write_register(CPUState *cpu, uint8_t *buf, int reg);
+int hexagon_cpu_handle_mmu_fault(CPUState *cs,
+                                  vaddr address,
+                                  int size,
+                                  int rw,
+                                  int mmu_idx);
+
+void hexagon_tcg_init(void);
+/* you can call this signal handler from your SIGBUS and SIGSEGV
+   signal handlers to inform the virtual CPU of exceptions. non zero
+   is returned if the signal was handled by the virtual CPU.  */
+int cpu_hexagon_signal_handler(int host_signum, void *pinfo,
+                          void *puc);
+
+#define TARGET_PAGE_BITS 12
+
+#define TARGET_PHYS_ADDR_SPACE_BITS 32
+#define TARGET_VIRT_ADDR_SPACE_BITS 32
+
+#define CPU_RESOLVING_TYPE TYPE_HEXAGON_CPU
+
+#define cpu_init(cpu_model) cpu_generic_init(TYPE_HEXAGON_CPU, cpu_model)
+
+#define cpu_signal_handler cpu_hexagon_signal_handler
+
+#include "exec/cpu-all.h"
+
+/* Exceptions */
+#define EXCP_BREAK    -1
+
+/* MMU modes definitions */
+#define MMU_MODE0_SUFFIX _user
+#define MMU_USER_IDX        0
+
+target_ulong do_hexagon_semihosting(CPUHexagonState *env);
+
+static inline void cpu_get_tb_cpu_state(CPUHexagonState *env, target_ulong *pc,
+                                        target_ulong *cs_base, uint32_t *flags)
+{
+    *pc = env->cr[CR_PC];
+    *cs_base = 0;
+    *flags = 0;
+}
+
+#endif
diff --git a/target/hexagon/gdbstub.c b/target/hexagon/gdbstub.c
new file mode 100644
index 0000000000..5b6d52c10c
--- /dev/null
+++ b/target/hexagon/gdbstub.c
@@ -0,0 +1,40 @@
+/*
+ * Hexagon gdb server stub
+ *
+ * Copyright (c) 2017-2019 Comsecuris UG (haftungsbeschraenkt)
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "qemu/osdep.h"
+#include "qemu-common.h"
+#include "cpu.h"
+#include "exec/gdbstub.h"
+
+int hexagon_cpu_gdb_read_register(CPUState *cs, uint8_t *mem_buf, int n)
+{
+    return 0;
+}
+
+int hexagon_cpu_gdb_write_register(CPUState *cs, uint8_t *mem_buf, int n)
+{
+    return 0;
+}
diff --git a/target/hexagon/generator/README.md b/target/hexagon/generator/README.md
new file mode 100644
index 0000000000..d106b5f31b
--- /dev/null
+++ b/target/hexagon/generator/README.md
@@ -0,0 +1,564 @@
+# QEMU Hexagon Frontend Generator
+
+## Compile-time/Run-time
+
+Due to the complex nature of this software piece, a foreword about the different
+computation times is needed.
+The final software includes 5 different computation times, those are:
+
+- decoder generation time
+- bison-time (semantics execution)
+- QEMU-compile time (QEMU compilation)
+- QEMU-time (tinycode compilation)
+- runtime (tinycode execution)
+
+These five layers of computation must not be mistaken one another,
+otherwise bugs and error will arise.
+
+## Components
+
+- `best-decoding`
+- `decoder_gen.py`
+- `semantics`
+
+### `best-decoding`
+
+### `decoder_gen.py`
+
+This python script has the purpose of converting all the information
+extracted from the ISA manual to source code implementing the Hexagon
+frontend.
+
+All the information from the ISA manual has been extracted with
+[Tabula](https://tabula.technology/), a semi-automatic PDF extraction tool.
+The information extracted is contained in the following files:
+
+- `instructions.csv`
+
+    This file contains all the 1508 instructions of the Hexagon ISA, and each
+    one is associated with an encoding scheme, the encoding scheme contains
+    information about the fixed and variabile bits of each instruction.
+    From this csv we extract the bit ranges of the instruction word to be
+    interpreted to parse all the operands of a single instruction.
+
+    The encoding scheme is expressed as follows:
+    - `1` is a constant one
+    - `0` is a constant zero
+    - `-` is a don't care
+    - `i` is the encoding of a constant denoted by `#s` or `#u`
+    - `I` is the encoding of a constant denoted by `#S` or `#U`
+    - `P` are the parse bits
+    - `s` is the encoding of Rs
+    - `d` is the encoding of Rd
+    - `x` is the encoding of Rx
+    - `y` is the encoding of Ry
+    - `t` is the encoding of Rt
+    - `e` is the encoding of Re
+    - `u` is the encoding of Pu
+    - `v` is the encoding of Pv
+- `meta-instructions.csv`
+
+    This file encompasses all the 1066 semantic behaviours contained
+    in the ISA manual. We call the elements of this csv _meta-instructions_.
+    The first argument of the csv is a regex for matching
+    a behaviour to a set of instructions, the second argument is a
+    description of the semantic of that group of instructions.
+    The description is expressed in a pseudo-C language; for interpreting
+    this language we will refer firstly to the description of a certain
+    meta-instruction present in the ISA manual, and secondly to the
+    C-language semantics.
+- `sub-instructions.csv`
+
+    This file is analogue to the instructions.csv, but refers to the
+    sub-instructions which compose the duplex instructions.
+- `const-ext.csv`
+
+    This csv file describes the instructions which accept a constant
+    extender. The first argument is the index of the constant value to be
+    extended, while the second argument of the csv will be converted in a
+    regex that will match one or more instructions.
+
+The goal of the `decoder_gen.py` script is to generate a QEMU function for
+each meta-instruction of the aforementioned `meta-instructions.csv`.
+This function will contain the QEMU code to generate the QEMU tinycode
+which will execute the semantics of each instruction.
+Each meta-instruction may contain one or more parametric values, so that
+it can match several instructions.
+Every value is converted to a QEMU function parameter, which will get
+a QEMU-runtime known value dependend on the particular instruction
+which has matched that meta-instruction.
+Also all the parameters of each instruction, obtained from the parsing
+of the instruction word will be converted into QEMU function parameters,
+so that the parsing step can be decoupled from the execution step.
+
+#### Generation Process
+
+The `decoder_gen.py` script executes several steps, each one represented
+by a function invocation in the main function.
+First, data is parsed from the csv files described above, then the regexes
+contained in the csv files are translated into the python regex syntax,
+so that they can be used programmatically in this same script.
+The next step is to build the mapping between meta-instructions and instructions
+, we do so by building the regex with the `to_regex` function and mapping
+that function to the regexes extracted from the csv.
+Meta-instruction may have one or more optional values have tipically
+the form of `[!]`, `[&|]` or `[01]` which will have a QEMU-runtime boolean
+value for each of the matching instructions.
+Here, while converting the regexes we create a matching group for each
+optional parameter, so that while matching each instruction, we can easily
+extract the value of each parameter.
+
+The `gen_decoder_header` and `gen_macros` functions then emit all the constant
+headers and macros which will be needed by the produced QEMU source files.
+
+#### Decoder Generation
+
+The `gen_decoder_switch` translates the decoding tree JSON generated by
+the `best-decoding` script into a tree of nested switch-case in the QEMU
+code which will handle the logarithmic part of the instructions identification.
+After we have reached one of the leaf nodes of the identification tree, if
+there is still ambiguity left for the instruction identity, a pattern-matching
+algorithm is applied.
+The algorithm is implemented in a constant-time-computation fashion,
+the instruction word is combined with a mask defining the constant bits,
+and with a value defining the instructions considered in the pattern-match.
+Care has been taken to assert when more than one instruction matches an
+instruction word.
+As a result we return the index of the instruction, which will be
+used later to call the corresponding semantic function.
+All of this happens in the generated `decode` QEMU function.
+
+The next function to be generated is the `execute` QEMU function which will
+take as a parameter the index of the parsed instruction and extracts the
+parameters and constants from the target instructions and then calls the
+matching meta-instruction function with the said parameters and with the
+correct matching parameters.
+In this function we also take care of applying constant-extension and
+sign-extension as needed. In addition to all the instruction semantics
+relative to the parameter parsing such as `:n` multiplication.
+
+#### QEMU Functions Emission
+
+The function `gen_functions` is in charge of emitting for each meta-instruction,
+a QEMU function that will emit the correct tinycode to perform its semantics.
+This function works by using the meta-instruction matching results to
+craft the function signature, then is call the `gen_function_body` function
+to emit the body of each newly created function.
+Moreover the gen_function_body calls for each of the meta-instruction an
+external parser called `semantics` which receives as input the pseudo-code
+of each meta-instruction and some parameters derived from the meta-instruction
+signature, such as the load/store size and the signedness of operations.
+The `semantics` program generates the QEMU code that will be filled inside
+the instruction body.
+
+#### Further Steps
+
+The functions `gen_sub_decoder` and `gen_sub_execute` perform those
+same steps for the sub-instructions employed in the Hexagon duplex instructions.
+
+The gen_endloop generates the special functions for the endloop instructions,
+since these instructions are not encoded in an instruction word but they
+are encoded in the parse bits, only the semantic functions are needed.
+
+The `indent` function applies the `GNU indent` utility to the whole generated
+code. To increased code cleanliness.
+
+### semantics
+
+The `semantics` parser is built with `GNU flex/bison` parser generation tools.
+Its source code, included in `decoder/semantics` is divided in three source
+files:
+
+- `semantics.lex`
+
+    This file contains the lexical tokens which define the meta-instructions
+    pseudo-code. The first ~75 tokens are simple tokens, when the pseudo-code
+    will be parsed and the string will be matched, the corresponding token
+    will be returned.
+    The next tokens are related to registers, variables and immediates.
+    Those tokens usually contain a variable part, e.g., the register `r0`
+    contains 0 as its index, this information is hereby parsed and
+    a struct is populated with all the information retrieved.
+    Here all the different types of registers are parsed into a single
+    `REG` token, with an associated information structure.
+    The `TOKEN_DEBUG` macro, if defined, allows to print the tokenized
+    input, useful to inspect tokenization problems and errors.
+    Remember that token are defined in order of decreasing priority.
+- `semantics_struct.h`
+
+    This file contains all the C structs which are used in the parser.
+- `semantics.y`
+
+    This file contains the parser grammar and helper functions.
+    The first notable part is at line 1175,
+    `%token LBR RBR LPAR RPAR LSQ RSQ LARR`
+    where all the tokens defined
+    in the `semantics.lex` file are declared.
+    At line 1188 `%token <index> SA` the binding between tokens and C struct
+    containing their information is defined.
+    At line 1203 `%left COMMA` the precedence between all the operators and
+    their associativity are defined, the operator precedence defined in this
+    code resembles closely the one of the C language.
+    The precedence of operators is an utmost important part of the parser
+    because it is used to solve Shift-Reduce conflicts that may arise
+    by editing the grammar.
+    If a conflict arise, make sure that the involved tokens are correctly
+    differentiated by precedence and/or associativity.
+
+## The grammar
+
+At line 1223 `code  : statements`, begins the definition of the language grammar.
+This grammar defines the structure of the attribute grammar tree
+which is used to parse the pseudo-code.
+The grammar follows a very simple structure, which is depicted in this
+document; a pseudocode is a list of statements, statements can be
+control statement (control flow etc) or assign statements.
+Here we introduce the two most important non-terminals of this grammar:
+the `lvalue`s and `rvalue`s.
+
+#### `lvalue`s
+
+`lvalue`s represent a value which can be assigned to, this includes
+`reg` the nonterminal which parses the registers with their vectorial
+access and .new attributes and `extra`, which consider the special values
+used in the pseudocode to handle specific tasks i.e. hardware loop iteration.
+Note that there exists other entities which can be assigned to like
+predicates and the program counter, but they are considered separately
+since they need special code to be handled.
+For example the four predicate registers are grouped into a single control
+register, so it needs special handling. In fact the predicate index is
+available at QEMU-time, according to that index a specific byte of the C4
+control register is first zeroed (using a mask) and then filled up with
+the target predicate value.
+The `assign_statement` rule also defines special assignments like `+=` and
+so on. In our code also `IMM`ediates can be assigned to, in the sense
+that the pseudo-code assign values to some of the constants of the instructions,
+these values are represented by parameters of our QEMU functions, and we
+are simply assigning at QEMU-time some different values to those parameters.
+
+#### `rvalue`s
+
+The other non-terminal `rvalue` represents a value computed from an expression.
+This value can be directly derived from a register or produced by the use
+of operators such as `+` or `<<`.
+Each `rvalue` non-terminal is associated with a struct that defines
+whether it is a register or a temporary value generated from an operation.
+The contents of the structs is used to call the correct tinycode generation
+functions and to print the rvalue correctly when it needs to be used.
+Actually also the `reg` nonterminal is of type rvalue, so that while
+using the copy rule `reg = rvalue` no further assignment is required.
+The majority of the operators' code emission is handled by the `gen_bin_op`
+function, which switches on the operation type and emits the code.
+Different function calls are emitted whether the operands are `IMM`ediates or
+`REG`isters, so that an appropriate constant folding can be performed.
+For example if we consider the following `rvalue` nonterminal: `1 + 1`,
+this will match under the `rvalue PLUS rvalue` rule, the two `rvalue`s will
+be copied from `IMM` tokens, thus when evaluating the immediateness of the
+expression, the constant folding will be applied.
+In fact the emitted code will be `int32_t tmp_0 = 1 + 1;\n`, which will
+perform its computation at QEMU-compile time, therefore shaving off execution
+time from the QEMU-time and runtime.
+
+Every `rvalue` in the end will result in the emission of a TCGv which
+is a pointer of a tinycode variable.
+This variable may be of two kinds:
+
+- a Hexagon register (global tinycode variable)
+- a temporary value (local tinycode variable).
+
+In some case where constant folding may be applied, the `rvalue` results
+in the emission of a C automatic variable at QEMU-time.
+This mechanism can be used by creating temporary variables using the
+function `gen_imm_value`.
+Note that this constant folding is possible only with value which are known
+at QEMU-time. `rvalue`s of this kind are characterized by the
+`rvalue.type == IMMEDIATE` condition.
+
+After an `rvalue` has been used inside a QEMU function, it must be freed
+using the `rvalue_free` function. This function, in the case the `rvalue`
+represents a temporary value, emits a free instructions which allows QEMU
+to decrease the temporary values counter.
+
+#### Type System
+
+The type system of the semantics parser is bi-dimensional.
+Variables can be either 32-bit or 64-bit, signed or unsigned.
+Bit width is encoded in `rvalue->bit_width`, signedness is encoded
+in `rvalue->is_unsigned`.
+The type of each variable is set by the lexer in case the variables are
+registers or constant.
+Otherwise if the variable is the result of an expression, the type
+is inferred from the operands.
+
+Here particular attention is posed to the selection of the bit width of
+the operation, if both operands are 32-bit, the result is 32-bit, in all
+other cases the result is 64-bit.
+If a 32-bit value is left-shifted by more than 32 bits, the result must
+be 64-bit wide.
+The result is stored at QEMU-time into a temporary value created at line
+537, `res = gen_tmp(bit_width);`. The `gen_tmp` function actually emits
+the code to generate the temporary
+and stores details about the temporary such as its index and bit-width
+into the corresponding struct.
+
+#### Code Emission
+
+Code emission is performed throug the OUT macro, which takes a variable
+number of arguments, which are all pointers, and for each of them calls
+the correct `*_print` function. All the `*_print` functions are listed
+at the beginning of the `semantics.y` file.
+Here for some non-terminals of the grammar, a corresponding QEMU-code
+is generated.
+
+#### 64-bit Registers
+
+In Hexagon, 64-bit registers are just the concatenation of contiguous 32bit
+GPRs. Therefore reading and writing to those registers is a complex task. To
+read the value of a 64bit registers to a temporary we use the `reg_concat`
+function. To assign a value to a 64-bit register, we must assign separately the
+higher and the lower word, this is performed from line 1101 of the `semantics.y`
+source file `if (dest->bit_width == 64)`.
+
+#### Special Assignments
+
+Special assignments like `INC` (`+=`) are handled by performing first a
+`reg_concat`, to extract value from eventual 64-bit registers, then the
+operation is emitted via the `gen_bin_op`, finally the value is assigned
+back to the destination register in the `gen_assign` function.
+
+#### Vectorial Accesses
+
+The Hexagon pseudo-code also encompasses vectorial access facilities,
+these are parsed in the `semantics.lex` file, then added to their respective
+`reg`s via the rules at line 1902 `| reg VEC`. 
+If a `reg`ister has a vectorial access
+registered in its struct, its assignment will become `deposit` operations
+and its conversions to `rvalue` will become `extract` operations.
+
+#### Logical Operators
+
+The optional not `[!]` operator is handled with a `movcond` tinycode instruction
+which negates the `rvalue` if the `not[01]` boolean parameter is true.
+
+The comparison values are handled by the `gen_bin_cmp` function which
+emits `setcond[i]` tinycode operation to materialize them.
+In some cases (LT, GT, LTE, GTE comparisons), is relevant whether the
+comparison itself is performed is a signed or unsigned fashion.
+If both of the operands have the same signedness, the signedness of the
+comparison is the same, otherwise the signedness is taken from the one
+specified in the meta-instruction signature (passed from `decoder-gen.py`).
+
+#### Memory Operations
+
+Load and stores are handled via the `STAREA` (`*EA`) token, when
+it is parsed by the `rvalue` rule, we emit a load operation; instead
+when it is used by the `STAREA ASSIGN rvalue` rule, we emit a store operation.
+The size of the loads and stores is passed by the `decoder_gen.py` script
+via an `argv` value, parsed at line 1960 `switch (opt) {`.
+In particular the memory operation size is inferred by the meta-instruction
+string in the following way:
+
+If the `mem` keyword is followed by the `u` suffix, the operation is
+to be considered unsigned. The same holds for comparison e.g. `cmp.gtu` is
+a unsigned *greater than* comparison operator.
+
+- `memb` is a byte load (8 bit)
+- `memh` is a half word load (16 bit)
+- `memw` is a word load (32 bit)
+- `memd` is a double word load (64 bit)
+
+#### Control Flow
+
+The if statements are handled by emitting labels and fixing them later on.
+In particular a everything starts from the `if_stmt` statement, which
+generates the _false_ label, when evaluating the if we must jump to that
+label only if the if condition does not hold (`brcondi` at line 1471).
+The label is fixed in the `if_statement` rule which handles also eventual
+`ELSE` statements.
+This implementation handles arbitrarily nested if-else combinations.
+Note that the _dangling else_ problem generates a conflict. This is the only
+admittable conflict in the whole grammar. This is specified at line 1173
+`%expect 1`.
+
+The `for` statements are very limited in the pseudo-code, in fact they are
+used for vectorial accesses and iterate only for a fixed number of times.
+Given this constraint we can simply emit another identical `for` loop at
+QEMU-time. Then QEMU will perform the loop unrolling for us by emitting
+the tinycode several times.
+
+Ternary assignments are translated using the `movcond` tinycode instruction.
+
+#### Building
+
+When working on the aforementioned source file, use this oneliner to ensure
+that QEMU source code is updated upon modification to the `semantics` files:
+
+```
+cd decoder
+SOURCE=~/Documents/Extra/Hexagon/decoder/semantics && while true; \
+do inotifywait -r -e close_write $SOURCE && cd semantics && make clean; \
+clear && make -j5; cd ..; ./decoder_gen.py ; \
+cp decoder.h decoder.c ../qemu/target/hexagon; done
+```
+
+## Commit, .new, destination values
+
+Hexagon parallel execution becomes serial in our emulator,
+in the design document it is explained how we solve the dependencies issue
+and the .new registers issue.
+The implementation of these techniques is split between the `decoder.h` file
+and the `translate.c` file.
+In the `decoder.h` file there are the `SET_USED_REG`, `SET_WRITTEN_PRE` and
+other macros. These macros keep track of which registers have been written
+in each instruction, this information is known at QEMU-time, and is used
+to detect which registers will be committed from the .new registers to the
+normal registers. Also a list of output registers is kept so that the `Nt`
+references can be redirected to the correct register index.
+In `translate.c`, at line 212 `static inline void handle_packet_end(DisasContext *dc)`
+we handle those information we collected,
+by committing the written .new registers and inject initialization of the
+conditional registers.
+This last operation is needed because if we have a conditional register
+write, we only know at runtime whether the register will be written or not,
+but we have to issue the commit anyways. So we inject in the prologue,
+a code which initializes the .new values with the current register values.
+
+## Double jumps
+
+Double jumps are handled by incrementing a counter every time the PC is
+written and issuing every write to the PC with a `movcond` instruction which
+checks if the PC has already been written. In this case, at runtime,
+only the first write to the PC will be issued.
+
+## Employed structs
+
+All the used structs are defined in the `semantics_struct.h` file.
+The most important is the `t_hex_value` struct which contains all the
+information needed by the `rvalue` and `lvalue` non-terminals.
+These structs are filled by the lexer while crafting `REG` and `IMM`
+tokens and also generated by the grammar while creating temporaries.
+The enum `rvalue_union_tag` allows to distinguish between `rvalue` types.
+Among its members are the `is_vectorial`, `is_optnew` and `is_dotnew` flags
+which control the emission of the target `rvalue`, for example if the
+`is_dotnew` flag is present, the `GPR_new[i]` TCGv will be emitted instead
+of `GPR[i]`.
+
+## Grammar Example
+
+In this example we examine the meta-instruction number 0 and follow
+its translation into QEMU code, here is the considered meta-instruction.
+
+```
+Rd=add(Rs,#s16)
+```
+
+With its pseudo-code
+
+```
+apply_extension(#s);
+Rd=Rs+#s;
+```
+
+First let's apply the tokenizer to the pseudocode:
+
+```
+EXT LPAR IMM RPAR SEMI REG ASSIGN REG PLUS IMM SEMI
+```
+
+The `apply_extension` statement is ignored since every sign-extension
+is performed while extranting constants at the time of parsing.
+Therefore for greater clarity we omit it from the parsing tree.
+The following statement corresponds to this parsing tree:
+
+```
+code
+|
+statements
+|
+statement
+|
+assign_statement SEMI
+|
+lvalue ASSIGN rvalue
+|             |
+reg           rvalue PLUS rvalue
+|             |           |
+REG           reg         IMM
+              |
+              REG
+```
+
+This is the code corresponding to that meta-instruction, the
+function signature, `regs` declaration and return statement are emitted
+by the `decoder_gen.py` script, the rest is filled in by the `semantics`
+parser.
+
+```
+regs_t function_0(DisasContext * dc, uint32_t d, uint32_t s, uint32_t i)
+{
+    regs_t regs = { 0  };
+    TCGv_i32 tmp_0 = tcg_temp_new_i32();
+    tcg_gen_addi_i32(tmp_0, GPR[s], i);
+    tcg_gen_mov_tl(GPR_new[d], tmp_0);
+    SET_USED_REG(regs, d);
+    tcg_temp_free_i32(tmp_0);
+    return regs;
+
+}
+```
+
+The first emitted statement is the declaration of a temporary value,
+which will be used to store the `rvalue` resulting from the sum.
+Then the operation itself is emitted, with the correct register index
+and constant, taken from the function signature.
+The `assign_statement` rule will result in a `mov` instruction
+being emitted from the temporary value into the destination register.
+At the end the temporary value is freed.
+
+## translate.c
+
+This piece of code handles the parsing and execution of the Hexagon code.
+Everything begins from the `gen_intermediate_code` function, which
+loads the instruction words from memory and feeds them to the `decode_packet`.
+This function performs a coarse parsing of the instruction word by parsing
+the _parse bits_. This let us distinguish between constant extender, endloops,
+end of packets, duplexes etc.
+If we have a standard instruction we feed it to the `decode` function,
+which is generated automatically by the `decoder_gen.py` script.
+The result is the instruction index, which is fed into the `execute` function.
+The `execute` function returns a struct containing data about the used registers
+, conditional registers and output registers, which is accumulated using the
+`regs_append` function, and used to implement the `.new` semantics.
+
+#### Duplexes
+
+In case of duplex instructions we extract the two sub_instructions and
+craft a special instruction word for each of them by prepending a numeric
+encoding of their class. The encoding is the following:
+
+- 0 -> L1
+- 1 -> L2
+- 2 -> S1
+- 3 -> S1
+- 4 -> A
+
+These numbers are encoded into the bits 13-14 of the newly crafted instruction
+words. These instruction words are called `first_sub` and `last_sub`.
+If a constant extender is present, it must extend only the sub-instruction
+in slot 1. This is enforced by disabling the eventual `extender_present`
+flag after the execution of the slot 1, since the slot1 sub-instruction
+is always executed before the slot0 sub-instruction.
+
+#### Dependency Reordering
+
+Some hexagon packets may present dependencies between instructions,
+this happens usually for predicates assignments and jumps.
+This is handled by emitting the `SET_READ_PRE` and `SET_WRITTEN_PRE`
+macros, which register new dependencies and dependencies resolution.
+The dependencies are resolved in the `solve_dependencies` function using
+a greedy algorithm. The algorithm adds to a new list all the instruction which
+have no pending dependencies, then re-computes the set of all the read
+and written predicates and cycles again.
+An artificial dependency is introduced between jumps, so that they are not
+reordered inside a packet, this is because in the hexagon architecture, only
+a single jump inside a packet can be executed, the first available one.
diff --git a/target/hexagon/generator/best-decoding.c b/target/hexagon/generator/best-decoding.c
new file mode 100644
index 0000000000..4e868703ce
--- /dev/null
+++ b/target/hexagon/generator/best-decoding.c
@@ -0,0 +1,456 @@
+/*
+ * Copyright (c) 2017-2019 Comsecuris UG (haftungsbeschraenkt)
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <strings.h>
+#include <string.h>
+#include <stdio.h>
+#include <assert.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <limits.h>
+#include <float.h>
+
+typedef struct {
+  uint32_t Value;
+  uint32_t Mask;
+} Instruction;
+
+void printTimes(char *String, unsigned Times) {
+  while (Times --> 0)
+    printf("%s", String);
+}
+
+void printBinaryBits(uint32_t Value, unsigned Bits) {
+  unsigned I = Bits;
+  while (I --> 0)
+    printf("%c", Value & (1 << I) ? '1' : '0');
+}
+
+void printBinary(uint32_t Value) {
+  unsigned I = 32;
+  while (I --> 0)
+    printf("%c", Value & (1 << I) ? '1' : '0');
+}
+
+void printWithColors(FILE *File, uint32_t Value, uint8_t Colors[32]) {
+  unsigned I = 32;
+  while (I --> 0)
+    fprintf(File, "\x1B[%dm%c", (int) Colors[I], Value & (1 << I) ? '1' : '0');
+  fprintf(File, "\x1B[0m");
+}
+
+void printInstruction(Instruction *Inst) {
+  unsigned I = 32;
+  while (I --> 0)
+    printf("%s%c%s", Inst->Mask & (1 << I) ? "\x1B[31m" : "\x1B[0m", Inst->Value & (1 << I) ? '1' : '0', "\x1B[0m");
+}
+
+void printWithChoice(uint32_t Value, uint8_t *Choice, unsigned Size) {
+  uint32_t ChoiceToInt = 0;
+  for (unsigned I = 0; I < Size; I++)
+    ChoiceToInt |= 1 << (Choice[I]);
+  Instruction Temp = { Value , ChoiceToInt };
+  printInstruction(&Temp);
+}
+
+int compareInstructions(const void *LHS, const void *RHS) {
+  assert(LHS != NULL);
+  assert(RHS != NULL);
+  return ((Instruction *) RHS)->Value - ((Instruction *) LHS)->Value;
+}
+
+uint32_t extractBits(uint32_t Value, uint8_t *Choice, unsigned Size) {
+  uint32_t Result = 0;
+  for (unsigned I = 0; I < Size; I++)
+    Result |= ((Value & (1 << Choice[I]) ? 1 : 0) << I);
+  return Result;
+}
+
+void quickTest(void) {
+  uint8_t Choice[4] = { 0, 1, 2, 3 };
+  assert(extractBits(0b10111011, Choice, 4) == 0b1011);
+  assert(extractBits(0b10111111, Choice, 4) == 0b1111);
+
+  uint8_t Choice2[4] = { 1, 3, 5 };
+  assert(extractBits(0b1101010, Choice2, 3) == 0b111);
+  assert(extractBits(0b010101, Choice2, 3) == 0);
+}
+
+unsigned findBest(Instruction *Instructions,
+                  Instruction *TargetInstructions,
+                  Instruction *SelectedInstructions,
+                  unsigned InstructionCount,
+                  Instruction *MaskedValue,
+                  uint8_t *BestChoice,
+                  float *Score,
+                  unsigned *Count,
+                  unsigned Bits) {
+  unsigned BestBits = 0;
+  float BestScore = FLT_MAX;
+
+  // 1. Select only the instructions of our interest
+  unsigned TargetInstructionsCount = 0;
+  for (unsigned I = 0; I < InstructionCount; I++) {
+    uint32_t Mask = MaskedValue->Mask & Instructions[I].Mask;
+    if ((Instructions[I].Value & Mask) == (MaskedValue->Value & Mask))
+      TargetInstructions[TargetInstructionsCount++] = Instructions[I];
+  }
+  *Count = TargetInstructionsCount;
+
+  // 2. Compute the choosable bits
+  uint8_t Choosable[32] = { 0 };
+  unsigned ChoosableCount = 0;
+  for (unsigned I = 0; I < 32; I++)
+    if ((MaskedValue->Mask & (1 << I)) == 0)
+      Choosable[ChoosableCount++] = I;
+
+  // Initialize combination
+  uint8_t Choice[32];
+  for (unsigned J = 0; J < Bits; J++)
+    Choice[J] = J;
+
+  int K = 1;
+  while (K >= 0) {
+
+    // Get the corresponding choosable indexes
+    uint8_t RealChoice[32];
+    for (unsigned J = 0; J < Bits; J++)
+      RealChoice[J] = Choosable[Choice[J]];
+
+    // Keep only the interesting bits
+    for (unsigned L = 0; L < TargetInstructionsCount; L++) {
+      SelectedInstructions[L].Value = extractBits(TargetInstructions[L].Value,
+                                                  RealChoice,
+                                                  Bits);
+      SelectedInstructions[L].Mask = extractBits(TargetInstructions[L].Mask,
+                                                 RealChoice,
+                                                 Bits);
+    }
+
+    unsigned TotalMatches = 0;
+    unsigned Options = (1 << Bits);
+    for (unsigned L = 0; L < (1U << Bits); L++) {
+      bool NoMatch = true;
+      for (unsigned M = 0; M < TargetInstructionsCount; M++) {
+        uint32_t MaskedL = L & SelectedInstructions[M].Mask;
+        uint32_t Value = SelectedInstructions[M].Value;
+        if (MaskedL == Value) {
+          TotalMatches++;
+          NoMatch = false;
+        }
+      }
+
+      if (NoMatch)
+        Options--;
+    }
+
+    float NewScore = (float) TotalMatches / Options;
+    if (Options > 0 && NewScore < BestScore) {
+      BestScore = NewScore;
+      BestBits = Bits;
+      memcpy(BestChoice, RealChoice, sizeof(Choice));
+    }
+
+    // Get next combination
+    for (K = (int) Bits - 1; K >= 0; K--) {
+      // Can we increment this?
+      if (Choice[K] < ChoosableCount - 1) {
+        Choice[K]++;
+        if (Choice[K] + Bits - 1 - K <= ChoosableCount - 1) {
+          for (K++; K < (int) Bits; K++)
+            Choice[K] = Choice[K - 1] + 1;
+          break;
+        }
+      }
+    }
+
+  }
+
+  *Score = BestScore;
+  return BestBits;
+}
+
+void go(Instruction *Instructions,
+        Instruction *TargetInstructions,
+        Instruction *SelectedInstructions,
+        unsigned InstructionCount,
+        Instruction *Tmp,
+        uint8_t Choices[32][32],
+        unsigned Depth,
+        uint8_t *BitsPerMemoryAccess,
+        unsigned MaxDepth) {
+  unsigned BestBits = 0;
+  float Score;
+  unsigned Count;
+  BestBits = findBest(Instructions,
+                      TargetInstructions,
+                      SelectedInstructions,
+                      InstructionCount,
+                      Tmp,
+                      &Choices[Depth][0],
+                      &Score,
+                      &Count,
+                      BitsPerMemoryAccess[Depth]);
+
+  printTimes("  ", 2 + Depth * 2);
+  printf("\"bits\": [%d", Choices[Depth][0]);
+  for (unsigned I = 1; I < BitsPerMemoryAccess[Depth]; I++)
+    printf(", %d", Choices[Depth][I]);
+  printf("]");
+  printf(",\n");
+  printTimes("  ", 2 + Depth * 2);
+
+  if (Depth < MaxDepth - 1) {
+    printf("\"options\": {\n");
+    Instruction Tmp2 = *Tmp;
+    for (unsigned M = 0; M < BestBits; M++)
+      Tmp2.Mask |= 1 << Choices[Depth][M];
+
+    for (unsigned L = 0; L < (1U << BestBits); L++) {
+      printTimes("  ", 2 + Depth * 2 + 1);
+      printf("\"");
+      printBinaryBits(L, BestBits);
+      printf("\": {\n");
+
+      Tmp2.Value = Tmp->Value;
+      for (unsigned M = 0; M < BestBits; M++)
+        if (L & (1 << M))
+          Tmp2.Value |= 1 << Choices[Depth][M];
+      go(Instructions,
+         TargetInstructions,
+         SelectedInstructions,
+         InstructionCount,
+         &Tmp2,
+         Choices,
+         Depth + 1,
+         BitsPerMemoryAccess,
+         MaxDepth);
+
+      printTimes("  ", 2 + Depth * 2 + 1);
+      printf("}");
+      if (L != (1U << BestBits) - 1)
+        printf(",");
+      printf("\n");
+    }
+
+  } else {
+    printf("\"instructions\": {\n");
+    Instruction Tmp2 = *Tmp;
+    for (unsigned M = 0; M < BestBits; M++)
+      Tmp2.Mask |= 1 << Choices[Depth][M];
+
+    for (unsigned L = 0; L < (1U << BestBits); L++) {
+      printTimes("  ", 2 + Depth * 2 + 1);
+      printf("\"");
+      printBinaryBits(L, BestBits);
+      printf("\": [");
+
+      Tmp2.Value = Tmp->Value;
+      for (unsigned M = 0; M < BestBits; M++)
+        if (L & (1 << M))
+          Tmp2.Value |= 1 << Choices[Depth][M];
+
+      bool IsFirst = true;
+      for (unsigned M = 0; M < InstructionCount; M++) {
+        uint32_t Mask = Instructions[M].Mask & Tmp2.Mask;
+        if ((Tmp2.Value & Mask) == (Instructions[M].Value & Mask)) {
+          if (!IsFirst) {
+            printf(", ");
+          }
+          IsFirst = false;
+          printf("%d", M);
+        }
+      }
+
+      printf("]");
+      if (L != (1U << BestBits) - 1)
+        printf(",");
+      printf("\n");
+    }
+
+    // Print to stderr coloful stuff
+    if (Score != FLT_MAX) {
+      uint8_t Colors[32] = { 0 };
+      for (unsigned K = 0; K < MaxDepth; K++) {
+        for (unsigned L = 0; L < BitsPerMemoryAccess[K]; L++) {
+          assert(Colors[Choices[K][L]] == 0);
+          if (32 + K < 37)
+            Colors[Choices[K][L]] = 32 + K;
+        }
+      }
+
+      printWithColors(stderr, Tmp->Value, Colors);
+      fprintf(stderr, " %2.2f/%d\n", Score, Count);
+    }
+
+  }
+  printTimes("  ", 2 + Depth * 2);
+  printf("}");
+  printf("\n");
+}
+
+int main(int argc, char *argv[]) {
+
+  if (argc < 3) {
+    fprintf(stderr, "Usage: %s INSTRUCTIONS_CSV"
+            " BITS_PER_ACCESS1 BITS_PER_ACCESS2...\n", argv[0]);
+    return EXIT_FAILURE;
+  }
+
+  #define MAX_MEMORY_ACCESSES 32
+  unsigned MemoryAccesses = argc - 2;
+  assert(MemoryAccesses < MAX_MEMORY_ACCESSES);
+  uint8_t BitsPerMemoryAccess[MAX_MEMORY_ACCESSES];
+  unsigned TotalBits = 0;
+  for (unsigned I = 0; I < MemoryAccesses; I++) {
+    unsigned Bits = atoi(argv[2 + I]);
+    if (Bits <= 0 || Bits > 32) {
+      fprintf(stderr,
+              "Invalid number of bits for memory access %d: %u\n",
+              I + 1,
+              Bits);
+      return EXIT_FAILURE;
+    }
+    TotalBits += Bits;
+    BitsPerMemoryAccess[I] = Bits;
+  }
+  assert(TotalBits < 32);
+
+  quickTest();
+
+  FILE *File = fopen(argv[1], "r");
+  if (File == NULL) {
+    fprintf(stderr, "Couldn't open the input file: %s\n", argv[1]);
+    return EXIT_FAILURE;
+  }
+
+  size_t BufferSize = 100;
+  size_t InstructionCount = 0;
+  Instruction *Buffer = (Instruction *) calloc(1000, sizeof(Instruction));
+
+  unsigned BitsMet = 0;
+
+  bool LastWasSpace = true;
+  bool Corrupted = false;
+  char LastInput = 0;
+  uint32_t Value = 0;
+  uint32_t Mask = 0;
+  while (true) {
+    char Input;
+    size_t BytesRead = fread(&Input, 1, 1, File);
+    if (BytesRead == 0)
+      break;
+
+    assert(BytesRead == 1);
+
+    if (Input == '\n') {
+      if (!Corrupted && BitsMet == 32) {
+        /* printBinary(Value); */
+        /* printf("\n"); */
+        /* printBinary(Mask); */
+        /* printf("\n\n"); */
+
+        Buffer[InstructionCount].Value = Value;
+        Buffer[InstructionCount].Mask = Mask;
+        InstructionCount++;
+
+        if (InstructionCount >= BufferSize) {
+          BufferSize *= 2;
+          Buffer = realloc(Buffer, BufferSize * sizeof(Instruction));
+        }
+
+      }
+
+      Value = 0;
+      Mask = 0;
+      BitsMet = 0;
+      LastWasSpace = true;
+
+      Corrupted = false;
+      continue;
+    }
+
+    if (Corrupted)
+      continue;
+
+    if (BitsMet < 32) {
+      bool IsSpace = Input == ' ' || Input == ',';
+      if (!LastWasSpace && IsSpace) {
+        if (LastInput == '0' || LastInput == '1')
+          Mask |= 1 << (31 - BitsMet);
+
+        if (LastInput == '1')
+          Value |= 1 << (31 - BitsMet);
+
+        BitsMet++;
+      } else if (!LastWasSpace && !IsSpace) {
+        Corrupted = true;
+      }
+    }
+
+    LastWasSpace = Input == ' ' || Input == ',';
+    LastInput = Input;
+ }
+
+  fclose(File);
+
+  // Dump all instructions
+  printf("{\n");
+  printf("  \"instructions\": [\n");
+  for (unsigned I = 0; I < InstructionCount; I++) {
+    printf("    [\"");
+    printBinary(Buffer[I].Value);
+    printf("\", \"");
+    printBinary(Buffer[I].Mask);
+    printf("\"]");
+    if (I != InstructionCount - 1)
+      printf(",");
+    printf("\n");
+  }
+  printf("  ],\n");
+  printf("  \"decode\": {\n");
+
+  // Call the recursive function to find the best at each level
+  Instruction *TargetInstructions = calloc(InstructionCount, sizeof(Instruction));
+  Instruction *SelectedInstructions = calloc(InstructionCount, sizeof(Instruction));
+  uint8_t Choices[32][32];
+  bzero(&Choices, sizeof(Choices));
+  Instruction Fixed = { 0, 0 };
+  go(Buffer,
+     TargetInstructions,
+     SelectedInstructions,
+     InstructionCount,
+     &Fixed,
+     Choices,
+     0,
+     BitsPerMemoryAccess,
+     MemoryAccesses);
+  printf("  }\n");
+  printf("}\n");
+
+  free(Buffer);
+
+  return EXIT_SUCCESS;
+}
diff --git a/target/hexagon/generator/const-ext.csv b/target/hexagon/generator/const-ext.csv
new file mode 100644
index 0000000000..0f82310e68
--- /dev/null
+++ b/target/hexagon/generator/const-ext.csv
@@ -0,0 +1,67 @@
+1,"Rd = #U6; jump ##s32"
+0,"if (Pt.new) jump:hint ##s32"
+0,"if ([!]Pt) jump:hint ##s32"
+0,"Rd[d] = mem{b|ub|h|uh|w|d}(gp + ##U32)"
+0,"if ([!]Pt[.new]) Rd = mem{b|ub|h|uh|w|d} (Rs + ##U32)"
+0,"Rd[d] = mem{b|ub|h|uh|w|d} (Rs + ##U32)"
+0,"Rd[d] = mem{b|ub|h|uh|w|d} (Re=##U32)"
+1,"Rd[d] = mem{b|ub|h|uh|w|d} (Rt<<#u2 + ##U32)"
+0,"if ([!]Pt[.new]) Rd = mem{b|ub|h|uh|w|d} (##U32)"
+0,"mem{b|h|w|d}(##U32) = Rs[.new]"
+0,"mem{b|h|w|d}(gp+##U32) = Rt"
+0,"if ([!]Pt[.new]) mem{b|h|w|d}(Rs + ##U32) = Rt[.new]"
+0,"mem{b|h|w|d}(Rs + ##U32) = Rt[.new]"
+0,"mem{b|h|w|d}(Rd=##U32) = Rt[.new]"
+1,"mem{b|h|w|d}(Ru<<#u2 + ##U32) = Rt[.new]"
+0,"if ([!]Pt[.new]) mem{b|h|w|d}(##U32) = Rt[.new]"
+1,"if ([!]Pt[.new]) memw(Rs + #u6) = ##U32"
+1,"memw(Rs + #u6) = ##U32"
+1,memw(Rs + Rt<<#u2) = ##U32
+0,"if (cmp.xx(Rs.new,##U32)) jump:hint target"
+1,"p0=cmp.xx(Rs,##U32); if (p0.new) jump:hint target"
+1,"p0=cmp.xx(Rs,##U32); if (!p0.new) jump:hint target"
+0,"p0=cmp.xx(Rs,Rt); if (p0.new) jump:hint ##s32"
+0,"p0=cmp.xx(Rs,Rt); if (!p0.new) jump:hint ##s32"
+0,Rd = ##u32
+0,"Rdd = combine(Rs,#s8)"
+0,"Rdd = combine(#s8,Rs)"
+0,"Rdd = combine(#s8,#S8)"
+1,"Rdd = combine(#s8,#U6)"
+0,"Rd = mux (Pu,Rs,##u32)"
+0,"Rd = mux (Pu,##u32,Rs)"
+0,"Rd = mux(Pu,##u32,#s8)"
+0,"if ([!]Pu[.new]) Rd = add(Rs,##u32)"
+0,if ([!]Pu[.new]) Rd = ##u32
+0,"Pd = [!]cmp.eq (Rs,##u32)"
+0,"Pd = [!]cmp.gt (Rs,##u32)"
+0,"Pd = [!]cmp.gtu (Rs,##u32)"
+0,"Rd = [!]cmp.eq(Rs,##u32)"
+0,"Rd = and(Rs,##u32)"
+0,"Rd = or(Rs,##u32)"
+0,"Rd = sub(##u32,Rs)"
+0,"Rd = add(Rs,##s32)"
+0,"Rd = mpyi(Rs,##u32)"
+0,"Rd += mpyi(Rs,##u32)"
+0,"Rd -= mpyi(Rs,##u32)"
+0,"Rx += add(Rs,##u32)"
+0,"Rx -= add(Rs,##u32)"
+0,Rd = ##u32
+0,"Rd = add(Rs,##s32)"
+0,jump (PC + ##s32)
+0,call (PC + ##s32)
+0,if ([!]Pu) call (PC + ##s32)
+0,"Pd = spNloop0(PC+##s32,Rs/#U10)"
+0,"loop0/1 (PC+##s32,#Rs/#U10)"
+0,"Rd = add(pc,##s32)"
+0,"Rd = add(##u32,mpyi(Rs,#u6))"
+0,"Rd = add(##u32,mpyi(Rs,Rt))"
+0,"Rd = add(Rs,add(Rt,##u32))"
+0,"Rd = add(Rs,sub(##u32,Rt))"
+0,"Rd = sub(##u32,add(Rs,Rt))"
+0,"Rd = or(Rs,and(Rt,##u32))"
+0,"Rx = add/sub/and/or (##u32,asl/asr/lsr(Rx,#U5))"
+0,"Rx = add/sub/and/or (##u32,asl/asr/lsr(Rs,Rx))"
+0,"Rx = add/sub/and/or (##u32,asl/asr/lsr(Rx,Rs))"
+0,"Pd = cmpb/h.{eq,gt,gtu} (Rs,##u32)"
+0,"Rx = add(Rx,#s7)"
+0,"Rd = #u6"
diff --git a/target/hexagon/generator/decoder_gen.py b/target/hexagon/generator/decoder_gen.py
new file mode 100755
index 0000000000..fce4334148
--- /dev/null
+++ b/target/hexagon/generator/decoder_gen.py
@@ -0,0 +1,1122 @@
+#!/usr/bin/env python3
+#
+# Code generator for the header file required by the Hexagon decoder
+#
+# Copyright (c) 2017-2019 Comsecuris UG (haftungsbeschraenkt)
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are met:
+#     * Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#     * Redistributions in binary form must reproduce the above copyright
+#       notice, this list of conditions and the following disclaimer in the
+#       documentation and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+# ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+
+from collections import namedtuple
+from collections import defaultdict
+from pprint import pprint
+
+import argparse
+import csv
+import json
+import re
+import subprocess
+
+instruction_strings = []
+sub_instruction_strings = []
+meta_instructions = []
+instructions_masks = []
+specialization_params = {}
+endloops = {}
+patterns = []
+meta_mapping = defaultdict(list)
+implemented_meta = 0
+implemented_insn = 0
+system_insn = 0
+float_insn = 0
+implemented_vect = 0
+vectorial_meta = 0
+Constant = namedtuple('Constant', ['identifier', 'bits', 'signed',
+                                   'multiple', 'pc_offset', 'ranges'])
+Register = namedtuple('Register', ['identifier', 'bits', 'ranges',
+                                   'dot_new', 'predicate'])
+Range = namedtuple('Range', ['start', 'end'])
+
+DECODER_HEADER = """#ifndef HEXAGON_DECODER_H
+#define HEXAGON_DECODER_H
+
+#include "exec/log.h"
+#include "qemu-common.h"
+#include "tcg.h"
+
+#define LOG_DIS(...) qemu_log_mask(CPU_LOG_TB_IN_ASM, ## __VA_ARGS__)
+#define SET_USED_REG(reg_struct, reg) {\\
+        if (is_conditional) \\
+            reg_struct.conditional |= (uint64_t)1 << (reg); \\
+        else \\
+            reg_struct.written |= (uint64_t)1 << (reg); \\
+        if (reg < 32) \\
+            push_destination_reg(&(reg_struct.destination), reg); \\
+}
+#define SET_WRITTEN_PRE(dc, pre_index) dc->deps[dc->i].written |= (uint8_t)1 << (pre_index)
+#define GET_WRITTEN_PRE(dc, pre_index) dc->deps[dc->i].written & (uint64_t)1 << (pre_index)
+#define GET_WRITTEN_PREV_PRE(dc, pre_index)                      \\
+        (dc->i == 0 ?                                            \\
+        (dc->deps[1].written & (uint64_t)1 << (pre_index)) |     \\
+        (dc->deps[2].written & (uint64_t)1 << (pre_index)) |     \\
+        (dc->deps[3].written & (uint64_t)1 << (pre_index))       \\
+        : dc->i == 1 ?                                           \\
+        (dc->deps[0].written & (uint64_t)1 << (pre_index)) |     \\
+        (dc->deps[2].written & (uint64_t)1 << (pre_index)) |     \\
+        (dc->deps[3].written & (uint64_t)1 << (pre_index))       \\
+        : dc->i == 2 ?                                           \\
+        (dc->deps[0].written & (uint64_t)1 << (pre_index)) |     \\
+        (dc->deps[1].written & (uint64_t)1 << (pre_index)) |     \\
+        (dc->deps[3].written & (uint64_t)1 << (pre_index))       \\
+        : dc->i == 3 ?                                           \\
+        (dc->deps[0].written & (uint64_t)1 << (pre_index)) |     \\
+        (dc->deps[1].written & (uint64_t)1 << (pre_index)) |     \\
+        (dc->deps[2].written & (uint64_t)1 << (pre_index)) : -1 )
+#define GET_WRITTEN_ANY_PRE(dc) \\
+        (dc->deps[0].written & 0b1111) | \\
+        (dc->deps[1].written & 0b1111) | \\
+        (dc->deps[2].written & 0b1111) | \\
+        (dc->deps[3].written & 0b1111)
+#define SET_READ_PRE(dc, pre_index) dc->deps[dc->i].read |= (uint8_t)1 << (pre_index)
+#define GET_USED_REG(reg_struct, reg) (reg_struct).written & (uint64_t)1 << (reg)
+#define GET_COND_REG(reg_struct, reg) (reg_struct).conditional & (uint64_t)1 << (reg)
+#define SET_BEGIN_COND() is_conditional = true;
+#define SET_END_COND() is_conditional = false;
+#define SET_JUMP_FLAG(dc) { \\
+    switch (dc->jump_count) { \\
+        case 0: SET_WRITTEN_PRE(dc, 4); break; \\
+        case 1: SET_READ_PRE(dc, 4); break; \\
+        default: assert(false && "More than two jumps in a packet!"); \\
+    } \\
+    dc->jump_count++; \\
+}
+#define ADD_IF_ZERO(x, y) {\\
+        assert((x == 0 || y == 0) && "Overlapping instruction encodings!");\\
+        x += y;\\
+}
+#define EXTRACT_P(index, dotnew) (dotnew) ? \\
+        ((CR[P] & (0xff << 8 * index)) >> 8 * index) : \\
+        ((CR_new[P] & (0xff << 8 * index)) >> 8 * index) : \\
+
+#define EXTR(src, start, end) \\
+(((src) >> (31 - end)) & ((1 << (end - start + 1)) - 1))
+#define EXTR_2(src, start, end, start2, end2) \\
+(EXTR(src, start, end) << (end2 - start2 + 1)) | EXTR(src, start2, end2)
+#define EXTR_3(src, start, end, start2, end2, start3, end3) \\
+(EXTR(src, start, end) << (end2 - start2 + end3 - start3 + 2)) |\\
+(EXTR(src, start2, end2) << (end3 - start3 + 1)) | (EXTR(src, start3, end3));
+#define EXTR_4(src, start, end, start2, end2, start3, end3, start4, end4) \\
+EXTR(src, start, end) << (end2 - start2 + end3 - start3 + end4 - start4 + 3)\\
+| (EXTR(src, start2, end2) << (end3 - start3 + end4 - start4 + 2))\\
+| (EXTR(src, start3, end3) << (end4 - start4 + 1))\\
+| EXTR(src, start4, end4)
+#define EXTR_BITS(src, x) \\
+((src >> x) & 1)
+#define EXTR_BITS_2(src, x, y) \\
+(EXTR_BITS(src, x) | (EXTR_BITS(src, y) << 1))
+#define EXTR_BITS_3(src, x, y, z) \\
+(EXTR_BITS_2(src, x, y) | (EXTR_BITS(src, z) << 2))
+#define EXTR_BITS_4(src, x, y, z, a) \\
+(EXTR_BITS_2(src, x, y) | (EXTR_BITS_2(src, z, a) << 2))
+#define EXTR_BITS_5(src, x, y, z, a, b) \\
+(EXTR_BITS_4(src, x, y, z, a) | (EXTR_BITS(src, b) << 4))
+#define EXTR_BITS_6(src, x, y, z, a, b, c) \\
+(EXTR_BITS_3(src, x, y, z) | (EXTR_BITS_3(src, a, b, c) << 3))\n
+
+typedef struct destination_reg_node {
+    int index;
+    struct destination_reg_node *next;
+} d_reg_node;
+typedef d_reg_node * d_reg_list;
+
+typedef struct regs {
+    uint64_t written;
+    uint64_t conditional;
+    d_reg_list destination;
+} regs_t;
+
+typedef struct dep {
+    TCGOp *begin;
+    TCGOp *end;
+    uint8_t written;
+    uint8_t read;
+} deps_t;
+
+/* This is the state at translation time.  */
+typedef struct DisasContext {
+    HexagonCPU *cpu;
+    target_ulong pc;
+    target_ulong old_pc;
+    target_ulong instruction_pc;
+    target_ulong npc;
+
+    int i;
+    uint32_t ir;
+    uint32_t const_ext;
+    bool block_end;
+    bool new_packet;
+    bool extender_present;
+    bool pc_written;
+    bool duplex;
+    bool endloop[2];
+    bool is_pre_written;
+    TCGOp *packet_first_op;
+    int jump_count;
+    regs_t regs;
+    deps_t deps[4];
+    deps_t * original[4];
+    deps_t * ordered[4];
+
+    struct TranslationBlock *tb;
+} DisasContext;
+
+extern TCGv GPR[32];
+extern TCGv CR[32];
+extern TCGv SR[64];
+extern TCGv GPR_new[32];
+extern TCGv CR_new[32];
+extern TCGv PC_written;
+extern TCGv SA[2];
+extern TCGv LC[2];
+extern TCGv LPCFG;
+
+int get_destination_reg(regs_t regs, int t);
+void push_destination_reg(d_reg_list* list, int index);
+void register_dependency(int index, DisasContext *dc);
+uint32_t decode(uint32_t ir);
+uint32_t sub_decode(uint32_t ir);
+regs_t execute(unsigned inst_id, DisasContext *dc);
+regs_t sub_execute(unsigned inst_id, DisasContext *dc);
+void endloop0(void);
+void endloop01(void);
+void endloop1(void);
+
+"""
+DECODER_INCLUDES = """#include "qemu/osdep.h"
+#include "cpu.h"
+#include "decoder.h"
+#include "tcg-op.h"
+
+static const int pred_whitening[4] = { 0xffffff00,
+                                       0xffff00ff,
+                                       0xff00ffff,
+                                       0x00ffffff };
+
+bool is_conditional = false;
+
+int get_destination_reg(regs_t regs, int t) {
+    d_reg_list reg_list = regs.destination;
+    if (reg_list == NULL)
+        assert(false && "Invalid .new instruction reference!");
+    for(int i = 1; i < t; i++) {
+        assert(reg_list != NULL && "Invalid .new instruction reference!");
+        reg_list = reg_list->next;
+    }
+    return reg_list->index;
+}
+
+void push_destination_reg(d_reg_list* list, int index) {
+    if (index == 29 || index == 30 || index == 31 ||
+        (list != NULL && *list != NULL && (*list)->index == index)) {
+        return;
+    }
+    d_reg_node *new_reg = (d_reg_node *)malloc(sizeof(d_reg_node));
+    new_reg->next = *list;
+    new_reg->index = index;
+    *list = new_reg;
+}
+
+"""
+
+def gen_macros():
+    code = ""
+    code += DECODER_INCLUDES
+    with open(decoder_c, "w") as d:
+        d.write(code)
+
+
+def find_integer(string):
+    for i, letter in enumerate(string):
+        if not letter.isdigit():
+            return i
+    return len(string)
+
+
+def extract_shift(string):
+    if string[1:5] == ":<<N":
+        return Constant(identifier="N", bits=32, signed=False,
+                        multiple=1, pc_offset=False, ranges=[])
+    else:
+        return None
+
+
+# Parse a constant from a tokenized string
+def extract_const(string):
+    # Extract features from constant placeholders
+    identifier = "j" if string[1].islower() else "I"
+    if string[1] in {"u", "U"}:
+        # Unsigned N-bit immediate value
+        signed = False
+        pc_offset = False
+    elif string[1] in {"s", "S"}:
+        # Signed N-bit immediate value
+        signed = True
+        pc_offset = False
+    elif string[1] in {"m", "M"}:
+        # Signed N-bit immediate value
+        signed = True
+        pc_offset = False
+    elif string[1] in {"r", "R"}:
+        # Signed N-bit immediate value
+        signed = True
+        pc_offset = True
+    elif string[1] == "#":
+        # 32 bit value
+        return Constant(bits=32)
+    elif string[1] == "-" or string[1].isdigit():
+        return None
+    else:
+        assert(False and "Constant placeholder parsing error!")
+
+    bits_delimiter = find_integer(string[2:]) + 2
+    bits = int(string[2:bits_delimiter])
+    if len(string) > bits_delimiter and string[bits_delimiter] == ":":
+        multiple_delimiter = find_integer(
+                string[bits_delimiter + 1:]) + bits_delimiter + 1
+        multiple = 2 ** int(string[bits_delimiter + 1:multiple_delimiter])
+    else:
+        multiple = 1
+    return Constant(identifier=identifier, bits=bits, signed=signed,
+                    multiple=multiple, pc_offset=pc_offset, ranges=[])
+
+
+# Parse a register from a tokenized string
+def extract_reg(string):
+    # TODO: Handle 64bit composite registers
+    if string[0] in {"R", "C", "P",
+                     "M", "G", "S"}:
+        if string[1] in {"e", "s", "d", "t", "u", "v", "x", "y"}:
+            if len(string) >= 3 and string[2] == string[1]:
+                return Register(identifier=string[1],
+                                bits=64,
+                                ranges=[],
+                                dot_new=False,
+                                predicate=string[0] == "P")
+            return Register(identifier=string[1],
+                            bits=32,
+                            ranges=[],
+                            dot_new=False,
+                            predicate=string[0] == "P")
+    elif string[0] in {"N"}:
+        if string[1] in {"t"}:
+            return Register(identifier=string[1],
+                            bits=32,
+                            ranges=[],
+                            dot_new=True,
+                            predicate=False)
+        elif string[1] in {"s"}:
+            return Register(identifier=string[1],
+                            bits=32,
+                            ranges=[],
+                            dot_new=True,
+                            predicate=False)
+
+
+# Search operand from identifier
+def find_op(identifier, operands):
+    return [op for op in operands if op.identifier == identifier][0]
+
+
+# Parse operands and compute format strings
+def parse_op(inst_str):
+    # Find operands order
+    operands = []
+    format_identifiers = []
+    for i, letter in enumerate(inst_str):
+        op = None
+        # Signed and unsigned constants
+        if letter == "#":
+            op = extract_const(inst_str[i:])
+        elif letter == "[":
+            op = extract_shift(inst_str[i:])
+        # Registers and predicates
+        else:
+            op = extract_reg(inst_str[i:])
+        format_identifiers.append(op)
+        if op not in operands:
+            operands.append(op)
+    identifiers = []
+    for op in format_identifiers:
+        if op is not None:
+            if op.bits == 64:
+                identifiers.append("(" + op.identifier + " + 1)")
+                identifiers.append(op.identifier)
+            else:
+                identifiers.append(op.identifier)
+    return ([op for op in operands if op is not None],
+            identifiers)
+
+
+# Operands extraction code generation
+def gen_extract_op(inst_str, encoding, operands):
+    code = ""
+    identifiers = set([c.identifier
+                       if type(c) in {Constant, Register}
+                       else c
+                       for c in operands])
+    # Extract bit ranges from encoding scheme
+    char, start = '', 0
+    for i, letter in enumerate(encoding):
+        if letter != char:
+            if char in identifiers:
+                find_op(char, operands).ranges.append(
+                        Range(start=start, end=(i - 1)))
+            start = i
+            char = letter
+        # Verify that no meaningful bits are left behind
+        if letter not in {'0', '1', '-', 'P'}.union(set(identifiers)):
+            print("Bit " + letter +
+                  " was not parsed in instruction " + inst_str)
+
+    if char in identifiers:
+        find_op(char, operands).ranges.append(
+                Range(start=start, end=(len(encoding) - 1)))
+
+    # Verify encoding scheme coherence
+    for op in operands:
+        if type(op) == Constant and op.identifier != "N":
+            sum = 0
+            for r in op.ranges:
+                sum += r.end - r.start + 1
+            assert(sum == op.bits and "Non-coherent encoding scheme!")
+
+    # Patch Nt encoding ranges
+    for op in operands:
+        if type(op) == Register and op.dot_new:
+            old_range = op.ranges[-1]
+            op.ranges[-1] = Range(start=old_range.start, end=old_range.end - 1)
+
+    # Constand extender is not present, apply multiplier
+    ext_imm = extendable_index(inst_str)
+    constant_index = 0
+    # Emit code for each operand
+    for i, op in enumerate(operands):
+        multiple = ""
+        if len(op.ranges) == 1:
+            code += "raw_value = EXTR(dc->ir, {}, {});\n".format(
+                    op.ranges[0].start,
+                    op.ranges[0].end)
+        elif len(op.ranges) == 2:
+            code += "raw_value = EXTR_2(dc->ir, {}, {}, {}, {});\n".format(
+                            op.ranges[0].start,
+                            op.ranges[0].end,
+                            op.ranges[1].start,
+                            op.ranges[1].end)
+        elif len(op.ranges) == 3:
+            code += "raw_value = EXTR_3(dc->ir, {}, {}, {}, {}, {}, {});"\
+                    "\n".format(
+                            op.ranges[0].start,
+                            op.ranges[0].end,
+                            op.ranges[1].start,
+                            op.ranges[1].end,
+                            op.ranges[2].start,
+                            op.ranges[2].end)
+        elif len(op.ranges) == 4:
+            code += "raw_value = EXTR_4(dc->ir, {}, {}, {}, {}, {}, {}, {},"\
+                    " {});\n".format(
+                            op.ranges[0].start,
+                            op.ranges[0].end,
+                            op.ranges[1].start,
+                            op.ranges[1].end,
+                            op.ranges[2].start,
+                            op.ranges[2].end,
+                            op.ranges[3].start,
+                            op.ranges[3].end)
+        if type(op) == Constant:
+            if op.multiple != 0:
+                multiple = " * "+str(op.multiple)
+            if op.signed:
+                extended = "((0xffffffff >> {bits}) << {bits}) | "\
+                        "raw_value".format(bits=op.bits)
+                code += "uint32_t {op_name} = ((raw_value >> ({bits} - 1))"\
+                        " ? ({extended}) : raw_value);".format(
+                                op_name=op.identifier,
+                                bits=op.bits,
+                                extended=extended)
+                # If is extendable emit conditional multiplier
+                if constant_index == ext_imm:
+                    code += "{op_name} = (dc->extender_present ? "\
+                            "{op_name} : ({op_name}{multiple}));\n".format(
+                                    op_name=op.identifier,
+                                    multiple=multiple)
+                # Otherwise just multiply
+                else:
+                    code += "{op_name} = {op_name}{multiple};\n".format(
+                                    op_name=op.identifier,
+                                    multiple=multiple)
+
+            else:
+                code += "uint32_t {op_name} = "\
+                        "raw_value;".format(
+                                op_name=op.identifier,
+                                index=i,
+                                bits=op.bits)
+                # If is extendable emit conditional multiplier
+                if constant_index == ext_imm:
+                    code += "{op_name} = (dc->extender_present ? "\
+                            "{op_name} : ({op_name}{multiple}));\n".format(
+                                    op_name=op.identifier,
+                                    multiple=multiple)
+                # Otherwise just multiply
+                else:
+                    code += "{op_name} = {op_name}{multiple};\n".format(
+                                    op_name=op.identifier,
+                                    multiple=multiple)
+            constant_index += 1
+        else:
+            code += "uint32_t "+op.identifier+" = raw_value;"
+    return code
+
+
+def extendable_index(inst_str):
+    inst_str = inst_str.replace(" ", "")
+    extendables = []
+    with open(const_ext_csv) as f:
+        lines = csv.reader(f)
+        for line in lines:
+            extendables.append(line)
+    indexes, expressions = zip(*extendables)
+    regexes = map(to_extender_regex, expressions)
+    patterns = map(re.compile, regexes)
+    for i, pattern in enumerate(patterns):
+        match = pattern.match(inst_str)
+        if match is not None:
+            return int(indexes[i])
+    return None
+
+
+# Function execution code generation
+def gen_execute():
+    global system_insn
+    code = "regs_t execute(unsigned inst_id, DisasContext *dc) {"\
+           "uint32_t raw_value = 0;"\
+           "regs_t regs = { 0 };"\
+           "switch (inst_id) {"
+    encodings = parse_encodings(instructions_csv)
+    # Count SYSTEM instructions
+    for e in encodings:
+        if e[0:4] == ['0', '1', '1', '0']:
+            system_insn += 1
+    for inst_id, inst_str in enumerate(instruction_strings):
+        operands, format_identifiers = parse_op(inst_str)
+        identifiers = [op.identifier for op in operands]
+        code += "case {}:\n{{".format(inst_id)
+        code += gen_extract_op(inst_str, encodings[inst_id], operands)
+        for op in operands:
+            if type(op) == Register and op.dot_new:
+                code += "{id} = get_destination_reg(dc->regs, {id});\n".format(
+                        id=op.identifier)
+            if type(op) == Register and not op.dot_new and not op.predicate:
+                sum = 0
+                for r in op.ranges:
+                    sum += r.end - r.start + 1
+                    if sum < 5:
+                        code += "if (" + op.identifier + " >= 8)\n"
+                        code += op.identifier + " += 8;\n"
+        # If present, apply constant extender value
+        ext_imm = extendable_index(inst_str)
+        if ext_imm is not None:
+            constants = [op for op in operands if type(op) == Constant]
+            identifier = constants[ext_imm].identifier
+            code += "if (dc->extender_present) {\n"
+            code += identifier + " &= 0x3f;\n"
+            code += identifier + " |= dc->const_ext;\n"
+            code += "}\n"
+        # if inst_id == 233:
+        #    pprint(inst_str)
+        #    pprint(ext_imm)
+        # Print LOG_DIS disassembly using format.h
+        code += ("LOG_DIS({}" +
+                 ", {}" * len(format_identifiers) +
+                 ");\n").format(to_format_string(inst_str), *format_identifiers)
+        # Call the correct semantics function
+        code += gen_function_call(inst_str, identifiers)
+        code += "break;\n}\n"
+
+    code += 'default: assert(false && '\
+            '"Decoding not implemented for this instruction");'
+
+    code += "}\nreturn regs;\n}\n\n"
+
+    with open(decoder_c, "a") as d:
+        d.write(code)
+
+
+# Translate regex groups to function parameters
+def get_params(pattern):
+    flags = {}
+    params = []
+    # Each group becomes a parameter
+    for k, v in pattern.groupindex.items():
+        flags[v - 1] = k
+    for i in range(len(flags)):
+        params.append(flags[i])
+    return params
+
+
+# Invoke semantics compiler to fill function body
+def gen_function_body(pattern_index):
+    global implemented_meta
+    global implemented_insn
+    global implemented_vect
+    qemu_code = ""
+    qemu_code += "regs_t regs = { 0 };\n"
+    instruction_code = meta_instructions[pattern_index]["code"]
+    # Patch missing semicolons
+    instruction_code = instruction_code.replace(" if", "; if")
+    # Parse memory operation size
+    mem_args = []
+    mem_size = re.findall(r'mem(.*)\(', meta_instructions[pattern_index]["str"])
+    assert(len(mem_size) < 2 and "More than one memory operation!")
+    if len(mem_size) == 1:
+        mem_size = mem_size[0]
+        if "u" in mem_size:
+            mem_args.append("-u")
+        if "b" in mem_size:
+            mem_args.append("-b")
+        elif "h" in mem_size:
+            mem_args.append("-h")
+        elif "w" in mem_size:
+            mem_args.append("-w")
+        elif "d" in mem_size:
+            mem_args.append("-d")
+    # Parse comparison signedness
+    cmp_sign = re.findall(r'cmp.(?:gt|ge|lt|le)(.)\(',
+                          meta_instructions[pattern_index]["str"])
+    if len(cmp_sign) == 1 and "u" in cmp_sign:
+        mem_args.append("-u")
+    # Parse jump flag
+    jumps = re.findall(r'jump', meta_instructions[pattern_index]["str"])
+    if len(jumps) > 0:
+        mem_args.append("-j")
+    # Parse stop instruction
+    if meta_instructions[pattern_index]["str"] == "stop(Rs)":
+        mem_args.append("-s")
+    args = [semantics_path] + mem_args
+    proc = subprocess.Popen(" ".join(args),
+                            shell=True,
+                            stdout=subprocess.PIPE,
+                            stderr=subprocess.PIPE,
+                            stdin=subprocess.PIPE)
+    proc.stdin.write(instruction_code.encode("utf-8"))
+    proc.stdin.close()
+    proc.wait()
+    # Check bison exit code
+    if proc.returncode == 0:
+        qemu_code += proc.stdout.read().decode("utf-8")
+        implemented_meta += 1
+        implemented_insn += len(meta_mapping[pattern_index])
+        if "=v" in meta_instructions[pattern_index]["str"]:
+            implemented_vect += 1
+    else:
+        qemu_code += 'assert(false && "Instruction not implemented!");\n'
+        # pprint(meta_instructions[pattern_index]["code"])
+    qemu_code += "return regs;"
+    return qemu_code
+
+
+# Generate functions signatures
+def gen_functions():
+    code = ""
+    regexes = map(to_regex, meta_instructions)
+    patterns = map(re.compile, regexes)
+    # Map meta-instructions into effective instructions
+    for pattern_index, pattern in enumerate(patterns):
+        meta_instruction = meta_instructions[pattern_index]["str"]
+        meta_instruction = re.sub(r"\[(:<<N)\]", r"\[:<<N\]", meta_instruction)
+        meta_instruction = re.sub(r"\[(:<<1)\]", r"\[:<<N\]", meta_instruction)
+        operands, _ = parse_op(meta_instruction)
+        identifiers = [op.identifier for op in operands]
+        params = get_params(pattern)
+        # Add function string comment
+        code += "/* " + meta_instructions[pattern_index]["str"] + " */\n"
+        code += "/* " + meta_instructions[pattern_index]["code"] + " */\n"
+        # Generate function signature
+        if len(identifiers) + len(params) == 0:
+            code += "regs_t function_{}(DisasContext *dc) {{".format(pattern_index)
+        else:
+            function_str = ("regs_t function_{}(DisasContext *dc, " +
+                            ", ".join(["uint32_t {}"] * len(identifiers) +
+                                      ["bool {}"] * len(params)) + "){{\n")
+            code += function_str.format(pattern_index,
+                                        *identifiers,
+                                        *params)
+        code += gen_function_body(pattern_index)
+        code += "}\n"
+    with open(decoder_c, "a") as d:
+        d.write(code)
+    print("{}/{} meta instructions are vectorial!".format(vectorial_meta, len(meta_instructions)))
+    print("{}/{} meta instructions have been implemented!".format(implemented_meta, len(meta_instructions)))
+    print("{}/{} vectorial meta instructions have been implemented!".format(implemented_vect, vectorial_meta))
+    print("{}/{} instructions have been implemented!".format(implemented_insn, len(instruction_strings) - system_insn - float_insn))
+
+# Match instructions corresponding to a meta-instruction
+def gen_pattern_matching(candidates, instruction_masks):
+    if len(candidates) == 0:
+        code = 'assert(false && '\
+                '"Invalid instruction encoding!");'
+        return code
+    elif len(candidates) == 1:
+        return "return {};".format(candidates[0])
+    else:
+        code = ""
+        for candidate in candidates:
+            code += "ADD_IF_ZERO(inst_index, "\
+                    "(((ir & {}) ^ {}) == 0) * {});\n".format(
+                        hex(int(instruction_masks[candidate][1], 2)),
+                        hex(int(instruction_masks[candidate][0], 2)),
+                        candidate)
+        code += "return inst_index;\n"
+        return code
+
+
+# Generate switch case for decoding
+def explore_switch(decode, instruction_masks):
+    # Recursively generate switch cases
+    n_bits = len(decode["bits"])
+    code = ("switch (" +
+            "EXTR_BITS_{}(".format(n_bits) +
+            ("ir"+", {}"*n_bits+")) {{").format(*decode["bits"]))
+    if "options" in decode.keys():
+        for option in decode["options"]:
+            code += "case {}: ".format(hex(int(option, 2)))
+            code += explore_switch(decode["options"][option],
+                                   instruction_masks)
+            code += "break;"
+        code += 'default: assert(false && '\
+                '"Invalid instruction encoding!");'
+    elif "instructions" in decode.keys():
+        for instruction in decode["instructions"]:
+            code += "case {}:".format(hex(int(instruction, 2)))
+            code += gen_pattern_matching(decode["instructions"][instruction],
+                                         instruction_masks)
+            code += "break;"
+        code += 'default: assert(false && '\
+                '"Invalid instruction encoding!");'
+    else:
+        assert(False and "Unable to generate parsing code for:")
+        pprint(decode)
+    code += "}"
+    return code
+
+
+def gen_decoder_switch():
+    with open(instruction_decoding_json) as f:
+        decoding_json = json.loads(f.read())
+    decode = decoding_json["decode"]
+    instruction_masks = decoding_json["instructions"]
+
+    code = "uint32_t decode(uint32_t ir) {\n"
+    code += "uint64_t inst_index = 0;"
+    code += explore_switch(decode, instruction_masks)
+    code += "}"
+    with open(decoder_c, "a") as d:
+        d.write(code)
+
+
+# Translate instruction string into a format string
+def to_format_string(inst_str):
+    code = ""
+    code += "    "
+    code += '"'
+    format_string = re.sub("Nt", "Rt", inst_str)
+    format_string = re.sub("([RCPMGNS])[esdtuvxy]{2}",
+                           '\g<1>%" PRIu32 ":%" PRIu32 "', format_string)
+    format_string = re.sub("([RCPMGNS])[esdtuvxy]",
+                           '\g<1>%" PRIu32 "', format_string)
+    format_string = re.sub("\[:<<N\]", '[:<<%" PRIi32 "]', format_string)
+    format_string = re.sub("#[uU][0-9]+:[0-9]+", '#%" PRIu32 "', format_string)
+    format_string = re.sub("#[uU][0-9]+", '#%" PRIu32 "', format_string)
+    format_string = re.sub("#[sS][0-9]+:[0-9]+", '#%" PRIi32 "', format_string)
+    format_string = re.sub("#[sS][0-9]+", '#%" PRIi32 "', format_string)
+    format_string = re.sub("#m[0-9]+", '#%" PRIi32 "', format_string)
+    format_string = re.sub("#r[0-9]+", '#%" PRIi32 "', format_string)
+    format_string = re.sub("##", '#%" PRIi32 "', format_string)
+    code += format_string
+    code += '"\n'
+    return code
+
+
+# Translate a meta-instruction string into a regex
+def to_regex(meta_instruction):
+    regex = meta_instruction["str"]
+    regex = regex.replace("(", "\(")
+    regex = regex.replace(")", "\)")
+    regex = regex.replace("*", "\*")
+    regex = regex.replace("?", "\?")
+    regex = regex.replace("^", "\^")
+    regex = regex.replace("\n", "")
+    regex = regex.replace(" ", "")
+    regex = re.sub(r"\[(:<<1)\]", r"(?P<opt_shift>\1)?", regex)
+    regex = re.sub(r"\[(:<<N)\]", r"\[:<<N\]", regex)
+    regex = re.sub(r"\[(:<<1)\]", r"\[:<<N\]", regex)
+    regex = re.sub(r"\[([&|]+)\]", r"(?P<and_or>[\1])", regex)
+    regex = re.sub(r"\[([+-]+)\]", r"(?P<plus_minus>[\1])", regex)
+    regex = re.sub(r"\[([HL]+)\]", r"(?P<high_low0>[\1])", regex, count=1)
+    regex = re.sub(r"(?<!>)\[([HL]+)\]", r"(?P<high_low1>[\1])", regex, count=1)
+    regex = re.sub(r"\[([01]+)\]", r"(?P<zero_one0>[01])", regex, count=1)
+    regex = re.sub(r"(?<!>)\[([01]+)\]", r"(?P<zero_one1>[01])", regex, count=1)
+    regex = re.sub(r"\[!\]", r"(?P<not0>[!]*)?", regex, count=1)
+    regex = re.sub(r"(?<!>)\[!\]", r"(?P<not1>[!]*)", regex, count=1)
+    regex = re.sub(r"\[(:sat)\]", r"(?P<sat>\1)?", regex)
+    regex = re.sub(r"\[(:rnd)\]", r"(?P<rnd>\1)?", regex)
+    regex = re.sub(r"\[(.new)\]", r"(?P<new>\1)?", regex)
+    regex = re.sub(r":<hint>", r"(?P<hint>\:n?t)?", regex)
+    regex = regex.replace("+", "\+")
+    regex = regex.replace("|", "\|")
+    regex = regex.replace(".", "\.")
+    regex = "^" + regex + "$"
+    return regex
+
+
+# Translate a constant extender string into a regex
+def to_extender_regex(meta_instruction):
+    regex = meta_instruction
+    regex = regex.replace("(", "\(")
+    regex = regex.replace(")", "\)")
+    regex = regex.replace("?", "\?")
+    regex = regex.replace("Rd[d]", "Rdd?")
+    regex = regex.replace("[.new]", r"(.new)?")
+    regex = regex.replace("{", "(?:")
+    regex = regex.replace("}", ")")
+    regex = regex.replace("*", "\*")
+    regex = regex.replace("^", "\^")
+    regex = regex.replace("\n", "")
+    regex = regex.replace(" ", "")
+    regex = regex.replace("+", "\+")
+    regex = regex.replace(".", "\.")
+    regex = re.sub(r"\[!\]", r"!?", regex, count=1)
+    regex = regex.replace(",", "\,")
+    regex = regex.replace("hint", "n?t")
+    regex = regex.replace("xx", "(?:gt|ge|lt|le|eq)u?")
+    regex = regex.replace("target", "#[rRuUsS][0-9]+(?:\:?[0-9]+)?")
+    regex = regex.replace("#u6", "#[uUsS][0-9]+(?:\:?[0-9]+)?")
+    regex = regex.replace("##u32", "#[uUsS][0-9]+(?:\:?[0-9]+)?")
+    regex = regex.replace("##U32", "#[uUsS][0-9]+(?:\:?[0-9]+)?")
+    regex = regex.replace("##s32", "#[rRsS][0-9]+(?:\:?[0-9]+)?")
+    regex = regex.replace("##S32", "#[rRsS][0-9]+(?:\:?[0-9]+)?")
+    regex = regex.replace("Pt", "P[a-z]")
+    regex = regex.replace("add/sub/and/or", "(?:add|sub|and|or)")
+    regex = regex.replace("asl/asr/lsr", "(?:asl|asr|lsr)")
+    # pprint(regex)
+    return regex
+
+
+def parse_instructions(filename):
+    global float_insn
+    instruction_strings = []
+    # Extract effective instructions from instructions.csv
+    with open(filename) as f:
+        inst_reader = csv.reader(f, delimiter=",", quotechar='"')
+        for inst_id, inst_str in enumerate(inst_reader):
+            instruction_strings.append(inst_str[-1])
+            # Count floating point instructions
+            if "=sf" in inst_str[-1]:
+                float_insn += 1
+    return instruction_strings
+
+
+def parse_encodings(filename):
+    instruction_strings = []
+    # Extract effective instructions from instructions.csv
+    with open(filename) as f:
+        inst_reader = csv.reader(f, delimiter=",", quotechar='"')
+        for inst_id, inst_str in enumerate(inst_reader):
+            instruction_strings.append(inst_str[:32])
+    return instruction_strings
+
+
+def parse_meta_instructions():
+    global endloops
+    global vectorial_meta
+    meta_instructions = []
+    with open(meta_instructions_csv) as inst:
+        insts = csv.reader(inst)
+        instruction = {}
+        for inst in insts:
+            if inst[0] in {"endloop0", "endloop1", "endloop01"}:
+                endloops[inst[0]] = inst[1]
+                continue
+            # Exclude syntactic sugar
+            if "Assembler" in inst[1]:
+                continue
+            if len(inst[0]) != 0:
+                meta_instructions.append(instruction)
+                instruction = {}
+                instruction["str"] = inst[0]
+                if "=v" in instruction["str"]:
+                    vectorial_meta += 1
+                if len(inst[1]) == 0:
+                    instruction["code"] = "NOP;"
+                else:
+                    instruction["code"] = inst[1]
+            else:
+                instruction["code"] += "\n"+inst[1]
+        meta_instructions.append(instruction)
+        del meta_instructions[0]
+    return meta_instructions
+
+
+def gen_function_call(inst_str, identifiers):
+    inst_str = inst_str.replace(" ", "")
+    arguments = identifiers
+    pattern_id = None
+    matched = False
+    for i, pattern in enumerate(patterns):
+        match = pattern.match(inst_str)
+        if match is not None:
+            matched = True
+            for group in match.groups():
+                arguments.append("true" if group in {"&", "+", "1", "!", "H",
+                                                     ":sat", ":rnd", ".new",
+                                                     "t"} else "false")
+            pattern_id = i
+            break
+    if matched:
+        meta_mapping[pattern_id].append(inst_str)
+        return ("regs = function_{}(dc" +
+                ", {}" * len(identifiers) +
+                ");\n").format(pattern_id, *arguments)
+    else:
+        return ('assert(false && "This instruction is not implemented!");')
+
+
+def gen_sub_decoder():
+    global duplex_masks
+    with open(sub_instruction_decoding_json) as f:
+        decoding_json = json.loads(f.read())
+    decode = decoding_json["decode"]
+    duplex_masks = decoding_json["instructions"]
+
+    code = "uint32_t sub_decode(uint32_t ir) {\n"
+    code += "uint64_t inst_index = 0;"
+    code += explore_switch(decode, duplex_masks)
+    code += "}"
+    with open(decoder_c, "a") as d:
+        d.write(code)
+
+
+# Function execution code generation
+def gen_sub_execute():
+    code = "regs_t sub_execute(unsigned inst_id, DisasContext *dc) {"\
+           "uint32_t raw_value = 0;"\
+           "regs_t regs = { 0 };"\
+           "switch (inst_id) {"
+    encodings = parse_encodings(sub_instructions_csv)
+    for inst_id, inst_str in enumerate(sub_instruction_strings):
+        operands, format_identifiers = parse_op(inst_str)
+        identifiers = [op.identifier for op in operands]
+        code += "case {}:\n{{".format(inst_id)
+        # Implement weird operator encoding
+        code += gen_extract_op(inst_str, encodings[inst_id], operands)
+        for op in operands:
+            if type(op) == Register:
+                if op.bits == 64:
+                    code += op.identifier + " *= 2;\n"
+                code += "if (" + op.identifier + " >= 8)\n"
+                code += op.identifier + " += 8;\n"
+        # If present, apply constant extender value
+        ext_imm = extendable_index(inst_str)
+        if ext_imm is not None:
+            constants = [op for op in operands if type(op) == Constant]
+            identifier = constants[ext_imm].identifier
+            code += "if (dc->extender_present) {\n"
+            code += identifier + " &= 0x3f;\n"
+            code += identifier + " |= dc->const_ext;\n"
+            code += "dc->extender_present = false;\n"
+            code += "dc->const_ext = 0;\n"
+            code += "}\n"
+        # Print LOG_DIS disassembly using format.h
+        code += ("LOG_DIS({}" +
+                 ", {}" * len(format_identifiers) +
+                 ");\n").format(to_format_string(inst_str), *format_identifiers)
+        # Call the correct semantics function
+        code += gen_function_call(inst_str, identifiers)
+        code += "break;\n}\n"
+
+    code += 'default: assert(false && '\
+            '"Decoding not implemented for this instruction");'
+
+    code += "}\nreturn regs;\n}\n\n"
+
+    with open(decoder_c, "a") as d:
+        d.write(code)
+
+
+def gen_endloop():
+    code = ""
+    for name, pseudocode in endloops.items():
+        code += "void "+name+"(void)\n"
+        code += "{\n"
+        proc = subprocess.Popen([semantics_path,
+                                 '-t'],
+                                stdout=subprocess.PIPE,
+                                stdin=subprocess.PIPE)
+        proc.stdin.write(pseudocode.encode("utf-8"))
+        proc.stdin.close()
+        proc.wait()
+        assert(proc.returncode == 0 and "Unhandled endloop instruction!")
+        code += proc.stdout.read().decode("utf-8")
+        code += "}\n"
+    with open(decoder_c, "a") as d:
+        d.write(code)
+
+
+def analyse_inst_mapping():
+    no_match_count = 0
+    regexes = map(to_regex, meta_instructions)
+    patterns = list(map(re.compile, regexes))
+    for i, inst_str in enumerate(instruction_strings):
+        # Patch instruction strings to make them more easily parsable
+        inst_str = inst_str.replace(" ", "")
+        no_match = True
+        for pattern in patterns:
+            match = pattern.match(inst_str)
+            if match is not None:
+                no_match = False
+        if no_match:
+            no_match_count += 1
+            assert(inst_str.split("=")[1][0] == "v" and "Non-vectorial "
+                   "instruction has no corresponding meta-instruction!")
+    print("{}/{} instructions did not match any meta "
+          "instruction!".format(no_match_count, len(instruction_strings)))
+
+
+def gen_decoder_header():
+    multi_reference_count = 0
+    decoder_header = DECODER_HEADER
+    regexes = map(to_regex, meta_instructions)
+    patterns = map(re.compile, regexes)
+    # Map meta-instructions into effective instructions
+    for pattern_index, pattern in enumerate(patterns):
+        meta_instruction = meta_instructions[pattern_index]["str"]
+        meta_instruction = re.sub(r"\[(:<<N)\]", r"\[:<<N\]", meta_instruction)
+        meta_instruction = re.sub(r"\[(:<<1)\]", r"\[:<<N\]", meta_instruction)
+        operands, _ = parse_op(meta_instruction)
+        identifiers = [op.identifier for op in operands]
+        flags = {}
+        params = []
+        # Each group becomes a parameter
+        for k, v in pattern.groupindex.items():
+            flags[v - 1] = k
+        for i in range(len(flags)):
+            params.append(flags[i])
+        # Generate function signature
+        if len(identifiers) + len(params) == 0:
+            decoder_header += "regs_t function_{}(DisasContext *dc);\n".format(pattern_index)
+        else:
+            function_str = ("regs_t function_{}(DisasContext *dc, " +
+                            ", ".join(["uint32_t {}"] * len(identifiers) +
+                                      ["bool {}"] * len(params)) + ");\n")
+            decoder_header += function_str.format(pattern_index,
+                                                  *identifiers,
+                                                  *params)
+    print("{}/{} instructions were referenced multiple "
+          "times!".format(multi_reference_count, len(instruction_strings)))
+    decoder_header += "\n#endif"
+    with open(decoder_h, "w") as f:
+        f.write(decoder_header)
+
+
+def indent():
+    # Optionally, indent
+    try:
+        subprocess.run("indent -linux " + decoder_c, shell=True, check=True)
+    except:
+        pass
+
+def main():
+    parser = argparse.ArgumentParser()
+    # Support programs
+    parser.add_argument("semantics", metavar="SEMANTICS")
+
+    # Data extracted from ISA reference manual
+    parser.add_argument("meta_instructions_csv", metavar="META_INSTRUCTION_CSV")
+    parser.add_argument("instructions_csv", metavar="INSTRUCTION_CSV")
+    parser.add_argument("sub_instructions_csv", metavar="SUB_INSTRUCTION_CSV")
+    parser.add_argument("const_ext_csv", metavar="CONST_EXT_CSV")
+
+    # Generated by best-decoding
+    parser.add_argument("instruction_decoding_json", metavar="INSTRUCTION_DECODING_JSON")
+    parser.add_argument("sub_instruction_decoding_json", metavar="SUB_INSTRUCTION_DECODING_JSON")
+
+    # Output files
+    parser.add_argument("decoder_c", metavar="DECODER_C")
+    parser.add_argument("decoder_h", metavar="DECODER_H")
+
+    args = parser.parse_args()
+
+    global semantics_path
+    global meta_instructions_csv
+    global instructions_csv
+    global sub_instructions_csv
+    global const_ext_csv
+    global instruction_decoding_json
+    global sub_instruction_decoding_json
+    global decoder_c
+    global decoder_h
+    semantics_path = args.semantics
+    meta_instructions_csv = args.meta_instructions_csv
+    instructions_csv = args.instructions_csv
+    sub_instructions_csv = args.sub_instructions_csv
+    const_ext_csv = args.const_ext_csv
+    instruction_decoding_json = args.instruction_decoding_json
+    sub_instruction_decoding_json = args.sub_instruction_decoding_json
+    decoder_c = args.decoder_c
+    decoder_h = args.decoder_h
+
+    global meta_instructions
+    global instruction_strings
+    global sub_instruction_strings
+    global patterns
+    # Parse instructions and meta-instructions
+    meta_instructions = parse_meta_instructions()
+    instruction_strings = parse_instructions(instructions_csv)
+    sub_instruction_strings = parse_instructions(sub_instructions_csv)
+    regexes = map(to_regex, meta_instructions)
+    patterns = list(map(re.compile, regexes))
+    analyse_inst_mapping()
+    # decoder.h
+    gen_decoder_header()
+    # decoder.c
+    gen_macros()
+    gen_decoder_switch()
+    gen_execute()
+    gen_functions()
+    # Duplex instructions
+    gen_sub_decoder()
+    gen_sub_execute()
+    gen_endloop()
+    # auto-indent
+    indent()
+
+if __name__ == "__main__":
+    main()
diff --git a/target/hexagon/generator/instructions.csv b/target/hexagon/generator/instructions.csv
new file mode 100644
index 0000000000..7e5fc4ceb9
--- /dev/null
+++ b/target/hexagon/generator/instructions.csv
@@ -0,0 +1,1508 @@
+1,0,1,1,j,j,j,j,j,j,j,s,s,s,s,s,P,P,j,j,j,j,j,j,j,j,j,d,d,d,d,d,"Rd=add(Rs,#s16)"
+1,1,1,1,0,0,1,1,0,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,d,d,d,d,d,"Rd=add(Rs,Rt)"
+1,1,1,1,0,1,1,0,0,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,d,d,d,d,d,"Rd=add(Rs,Rt):sat"
+0,1,1,1,0,1,1,0,0,0,j,s,s,s,s,s,P,P,j,j,j,j,j,j,j,j,j,d,d,d,d,d,"Rd=and(Rs,#s10)"
+0,1,1,1,0,1,1,0,1,0,j,s,s,s,s,s,P,P,j,j,j,j,j,j,j,j,j,d,d,d,d,d,"Rd=or(Rs,#s10)"
+1,1,1,1,0,0,0,1,0,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,d,d,d,d,d,"Rd=and(Rs,Rt)"
+1,1,1,1,0,0,0,1,0,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,d,d,d,d,d,"Rd=or(Rs,Rt)"
+1,1,1,1,0,0,0,1,0,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,d,d,d,d,d,"Rd=xor(Rs,Rt)"
+1,1,1,1,0,0,0,1,1,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,d,d,d,d,d,"Rd=and(Rt,~Rs)"
+1,1,1,1,0,0,0,1,1,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,d,d,d,d,d,"Rd=or(Rt,~Rs)"
+0,1,1,1,1,1,1,1,-,-,-,-,-,-,-,-,P,P,-,-,-,-,-,-,-,-,-,-,-,-,-,-,"nop"
+0,1,1,1,0,1,1,0,0,1,j,s,s,s,s,s,P,P,j,j,j,j,j,j,j,j,j,d,d,d,d,d,"Rd=sub(#s10,Rs)"
+1,1,1,1,0,0,1,1,0,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,d,d,d,d,d,"Rd=sub(Rt,Rs)"
+1,1,1,1,0,1,1,0,1,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,d,d,d,d,d,"Rd=sub(Rt,Rs):sat"
+0,1,1,1,0,0,0,0,1,0,1,s,s,s,s,s,P,P,0,-,-,-,-,-,-,-,-,d,d,d,d,d,"Rd=sxtb(Rs)"
+0,1,1,1,0,0,0,0,1,1,1,s,s,s,s,s,P,P,0,-,-,-,-,-,-,-,-,d,d,d,d,d,"Rd=sxth(Rs)"
+0,1,1,1,0,0,0,1,j,j,1,x,x,x,x,x,P,P,j,j,j,j,j,j,j,j,j,j,j,j,j,j,"Rx.L=#u16"
+0,1,1,1,0,0,1,0,j,j,1,x,x,x,x,x,P,P,j,j,j,j,j,j,j,j,j,j,j,j,j,j,"Rx.H=#u16"
+0,1,1,1,1,0,0,0,j,j,-,j,j,j,j,j,P,P,j,j,j,j,j,j,j,j,j,d,d,d,d,d,"Rd=#s16"
+0,1,1,1,0,0,0,0,0,1,1,s,s,s,s,s,P,P,0,-,-,-,-,-,-,-,-,d,d,d,d,d,"Rd=Rs"
+1,1,1,1,0,1,1,0,0,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,d,d,d,d,d,"Rd=vaddh(Rs,Rt)"
+1,1,1,1,0,1,1,0,0,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,d,d,d,d,d,"Rd=vaddh(Rs,Rt):sat"
+1,1,1,1,0,1,1,0,0,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,d,d,d,d,d,"Rd=vadduh(Rs,Rt):sat"
+1,1,1,1,0,1,1,1,-,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,d,d,d,d,d,"Rd=vavgh(Rs,Rt)"
+1,1,1,1,0,1,1,1,-,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,d,d,d,d,d,"Rd=vavgh(Rs,Rt):rnd"
+1,1,1,1,0,1,1,1,-,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,d,d,d,d,d,"Rd=vnavgh(Rt,Rs)"
+1,1,1,1,0,1,1,0,1,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,d,d,d,d,d,"Rd=vsubh(Rt,Rs)"
+1,1,1,1,0,1,1,0,1,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,d,d,d,d,d,"Rd=vsubh(Rt,Rs):sat"
+1,1,1,1,0,1,1,0,1,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,d,d,d,d,d,"Rd=vsubuh(Rt,Rs):sat"
+0,1,1,1,0,0,0,0,1,1,0,s,s,s,s,s,P,P,0,-,-,-,-,-,-,-,-,d,d,d,d,d,"Rd=zxth(Rs)"
+0,1,1,1,0,0,1,1,-,0,0,s,s,s,s,s,P,P,1,j,j,j,j,j,j,j,j,d,d,d,d,d,"Rdd=combine(Rs,#s8)"
+0,1,1,1,0,0,1,1,-,0,1,s,s,s,s,s,P,P,1,j,j,j,j,j,j,j,j,d,d,d,d,d,"Rdd=combine(#s8,Rs)"
+0,1,1,1,1,1,0,0,0,I,I,I,I,I,I,I,P,P,I,j,j,j,j,j,j,j,j,d,d,d,d,d,"Rdd=combine(#s8,#S8)"
+0,1,1,1,1,1,0,0,1,-,-,I,I,I,I,I,P,P,I,j,j,j,j,j,j,j,j,d,d,d,d,d,"Rdd=combine(#s8,#U6)"
+1,1,1,1,0,0,1,1,1,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,d,d,d,d,d,"Rd=combine(Rt.H,Rs.H)"
+1,1,1,1,0,0,1,1,1,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,d,d,d,d,d,"Rd=combine(Rt.H,Rs.L)"
+1,1,1,1,0,0,1,1,1,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,d,d,d,d,d,"Rd=combine(Rt.L,Rs.H)"
+1,1,1,1,0,0,1,1,1,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,d,d,d,d,d,"Rd=combine(Rt.L,Rs.L)"
+1,1,1,1,0,1,0,1,0,-,-,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,d,d,d,d,d,"Rdd=combine(Rs,Rt)"
+0,1,1,1,0,0,1,1,0,u,u,s,s,s,s,s,P,P,0,j,j,j,j,j,j,j,j,d,d,d,d,d,"Rd=mux(Pu,Rs,#s8)"
+0,1,1,1,0,0,1,1,1,u,u,s,s,s,s,s,P,P,0,j,j,j,j,j,j,j,j,d,d,d,d,d,"Rd=mux(Pu,#s8,Rs)"
+0,1,1,1,1,0,1,u,u,I,I,I,I,I,I,I,P,P,I,j,j,j,j,j,j,j,j,d,d,d,d,d,"Rd=mux(Pu,#s8,#S8)"
+1,1,1,1,0,1,0,0,-,-,-,s,s,s,s,s,P,P,-,t,t,t,t,t,-,u,u,d,d,d,d,d,"Rd=mux(Pu,Rs,Rt)"
+0,1,1,1,0,0,0,0,0,0,0,s,s,s,s,s,P,P,0,-,-,-,-,-,-,-,-,d,d,d,d,d,"Rd=aslh(Rs)"
+0,1,1,1,0,0,0,0,0,0,1,s,s,s,s,s,P,P,0,-,-,-,-,-,-,-,-,d,d,d,d,d,"Rd=asrh(Rs)"
+1,1,1,1,0,1,0,1,1,-,-,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,d,d,d,d,d,"Rdd=packhl(Rs,Rt)"
+0,1,1,1,0,1,0,0,0,u,u,s,s,s,s,s,P,P,0,j,j,j,j,j,j,j,j,d,d,d,d,d,"if (Pu) Rd=add(Rs,#s8)"
+0,1,1,1,0,1,0,0,0,u,u,s,s,s,s,s,P,P,1,j,j,j,j,j,j,j,j,d,d,d,d,d,"if (Pu.new) Rd=add(Rs,#s8)"
+0,1,1,1,0,1,0,0,1,u,u,s,s,s,s,s,P,P,0,j,j,j,j,j,j,j,j,d,d,d,d,d,"if (!Pu) Rd=add(Rs,#s8)"
+0,1,1,1,0,1,0,0,1,u,u,s,s,s,s,s,P,P,1,j,j,j,j,j,j,j,j,d,d,d,d,d,"if (!Pu.new)Rd=add(Rs,#s8)"
+1,1,1,1,1,0,1,1,0,-,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,u,u,d,d,d,d,d,"if (Pu) Rd=add(Rs,Rt)"
+1,1,1,1,1,0,1,1,0,-,0,s,s,s,s,s,P,P,0,t,t,t,t,t,1,u,u,d,d,d,d,d,"if (!Pu) Rd=add(Rs,Rt)"
+1,1,1,1,1,0,1,1,0,-,0,s,s,s,s,s,P,P,1,t,t,t,t,t,0,u,u,d,d,d,d,d,"if (Pu.new) Rd=add(Rs,Rt)"
+1,1,1,1,1,0,1,1,0,-,0,s,s,s,s,s,P,P,1,t,t,t,t,t,1,u,u,d,d,d,d,d,"if (!Pu.new) Rd=add(Rs,Rt)"
+0,1,1,1,0,0,0,0,0,0,0,s,s,s,s,s,P,P,1,-,0,0,u,u,-,-,-,d,d,d,d,d,"if (Pu) Rd=aslh(Rs)"
+0,1,1,1,0,0,0,0,0,0,0,s,s,s,s,s,P,P,1,-,0,1,u,u,-,-,-,d,d,d,d,d,"if (Pu.new) Rd=aslh(Rs)"
+0,1,1,1,0,0,0,0,0,0,0,s,s,s,s,s,P,P,1,-,1,0,u,u,-,-,-,d,d,d,d,d,"if (!Pu) Rd=aslh(Rs)"
+0,1,1,1,0,0,0,0,0,0,0,s,s,s,s,s,P,P,1,-,1,1,u,u,-,-,-,d,d,d,d,d,"if (!Pu.new) Rd=aslh(Rs)"
+0,1,1,1,0,0,0,0,0,0,1,s,s,s,s,s,P,P,1,-,0,0,u,u,-,-,-,d,d,d,d,d,"if (Pu) Rd=asrh(Rs)"
+0,1,1,1,0,0,0,0,0,0,1,s,s,s,s,s,P,P,1,-,0,1,u,u,-,-,-,d,d,d,d,d,"if (Pu.new) Rd=asrh(Rs)"
+0,1,1,1,0,0,0,0,0,0,1,s,s,s,s,s,P,P,1,-,1,0,u,u,-,-,-,d,d,d,d,d,"if (!Pu) Rd=asrh(Rs)"
+0,1,1,1,0,0,0,0,0,0,1,s,s,s,s,s,P,P,1,-,1,1,u,u,-,-,-,d,d,d,d,d,"if (!Pu.new) Rd=asrh(Rs)"
+1,1,1,1,1,1,0,1,-,-,-,s,s,s,s,s,P,P,0,t,t,t,t,t,0,u,u,d,d,d,d,d,"if (Pu) Rdd=combine(Rs,Rt)"
+1,1,1,1,1,1,0,1,-,-,-,s,s,s,s,s,P,P,0,t,t,t,t,t,1,u,u,d,d,d,d,d,"if (!Pu)Rdd=combine(Rs,Rt)"
+1,1,1,1,1,1,0,1,-,-,-,s,s,s,s,s,P,P,1,t,t,t,t,t,0,u,u,d,d,d,d,d,"if (Pu.new)Rdd=combine(Rs,Rt)"
+1,1,1,1,1,1,0,1,-,-,-,s,s,s,s,s,P,P,1,t,t,t,t,t,1,u,u,d,d,d,d,d,"if (!Pu.new)Rdd=combine(Rs,Rt)"
+1,1,1,1,1,0,0,1,-,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,u,u,d,d,d,d,d,"if (Pu) Rd=and(Rs,Rt)"
+1,1,1,1,1,0,0,1,-,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,1,u,u,d,d,d,d,d,"if (!Pu) Rd=and(Rs,Rt)"
+1,1,1,1,1,0,0,1,-,0,0,s,s,s,s,s,P,P,1,t,t,t,t,t,0,u,u,d,d,d,d,d,"if (Pu.new) Rd=and(Rs,Rt)"
+1,1,1,1,1,0,0,1,-,0,0,s,s,s,s,s,P,P,1,t,t,t,t,t,1,u,u,d,d,d,d,d,"if (!Pu.new) Rd=and(Rs,Rt)"
+1,1,1,1,1,0,0,1,-,0,1,s,s,s,s,s,P,P,0,t,t,t,t,t,0,u,u,d,d,d,d,d,"if (Pu) Rd=or(Rs,Rt)"
+1,1,1,1,1,0,0,1,-,0,1,s,s,s,s,s,P,P,0,t,t,t,t,t,1,u,u,d,d,d,d,d,"if (!Pu) Rd=or(Rs,Rt)"
+1,1,1,1,1,0,0,1,-,0,1,s,s,s,s,s,P,P,1,t,t,t,t,t,0,u,u,d,d,d,d,d,"if (Pu.new) Rd=or(Rs,Rt)"
+1,1,1,1,1,0,0,1,-,0,1,s,s,s,s,s,P,P,1,t,t,t,t,t,1,u,u,d,d,d,d,d,"if (!Pu.new) Rd=or(Rs,Rt)"
+1,1,1,1,1,0,0,1,-,1,1,s,s,s,s,s,P,P,0,t,t,t,t,t,0,u,u,d,d,d,d,d,"if (Pu) Rd=xor(Rs,Rt)"
+1,1,1,1,1,0,0,1,-,1,1,s,s,s,s,s,P,P,0,t,t,t,t,t,1,u,u,d,d,d,d,d,"if (!Pu) Rd=xor(Rs,Rt)"
+1,1,1,1,1,0,0,1,-,1,1,s,s,s,s,s,P,P,1,t,t,t,t,t,0,u,u,d,d,d,d,d,"if (Pu.new) Rd=xor(Rs,Rt)"
+1,1,1,1,1,0,0,1,-,1,1,s,s,s,s,s,P,P,1,t,t,t,t,t,1,u,u,d,d,d,d,d,"if (!Pu.new) Rd=xor(Rs,Rt)"
+1,1,1,1,1,0,1,1,0,-,1,s,s,s,s,s,P,P,0,t,t,t,t,t,0,u,u,d,d,d,d,d,"if (Pu) Rd=sub(Rt,Rs)"
+1,1,1,1,1,0,1,1,0,-,1,s,s,s,s,s,P,P,0,t,t,t,t,t,1,u,u,d,d,d,d,d,"if (!Pu) Rd=sub(Rt,Rs)"
+1,1,1,1,1,0,1,1,0,-,1,s,s,s,s,s,P,P,1,t,t,t,t,t,0,u,u,d,d,d,d,d,"if (Pu.new) Rd=sub(Rt,Rs)"
+1,1,1,1,1,0,1,1,0,-,1,s,s,s,s,s,P,P,1,t,t,t,t,t,1,u,u,d,d,d,d,d,"if (!Pu.new) Rd=sub(Rt,Rs)"
+0,1,1,1,0,0,0,0,1,0,1,s,s,s,s,s,P,P,1,-,0,0,u,u,-,-,-,d,d,d,d,d,"if (Pu) Rd=sxtb(Rs)"
+0,1,1,1,0,0,0,0,1,0,1,s,s,s,s,s,P,P,1,-,0,1,u,u,-,-,-,d,d,d,d,d,"if (Pu.new) Rd=sxtb(Rs)"
+0,1,1,1,0,0,0,0,1,0,1,s,s,s,s,s,P,P,1,-,1,0,u,u,-,-,-,d,d,d,d,d,"if (!Pu) Rd=sxtb(Rs)"
+0,1,1,1,0,0,0,0,1,0,1,s,s,s,s,s,P,P,1,-,1,1,u,u,-,-,-,d,d,d,d,d,"if (!Pu.new) Rd=sxtb(Rs)"
+0,1,1,1,0,0,0,0,1,1,1,s,s,s,s,s,P,P,1,-,0,0,u,u,-,-,-,d,d,d,d,d,"if (Pu) Rd=sxth(Rs)"
+0,1,1,1,0,0,0,0,1,1,1,s,s,s,s,s,P,P,1,-,0,1,u,u,-,-,-,d,d,d,d,d,"if (Pu.new) Rd=sxth(Rs)"
+0,1,1,1,0,0,0,0,1,1,1,s,s,s,s,s,P,P,1,-,1,0,u,u,-,-,-,d,d,d,d,d,"if (!Pu) Rd=sxth(Rs)"
+0,1,1,1,0,0,0,0,1,1,1,s,s,s,s,s,P,P,1,-,1,1,u,u,-,-,-,d,d,d,d,d,"if (!Pu.new) Rd=sxth(Rs)"
+0,1,1,1,1,1,1,0,0,u,u,0,j,j,j,j,P,P,0,j,j,j,j,j,j,j,j,d,d,d,d,d,"if (Pu) Rd=#s12"
+0,1,1,1,1,1,1,0,0,u,u,0,j,j,j,j,P,P,1,j,j,j,j,j,j,j,j,d,d,d,d,d,"if (Pu.new) Rd=#s12"
+0,1,1,1,1,1,1,0,1,u,u,0,j,j,j,j,P,P,0,j,j,j,j,j,j,j,j,d,d,d,d,d,"if (!Pu) Rd=#s12"
+0,1,1,1,1,1,1,0,1,u,u,0,j,j,j,j,P,P,1,j,j,j,j,j,j,j,j,d,d,d,d,d,"if (!Pu.new) Rd=#s12"
+0,1,1,1,0,0,0,0,1,0,0,s,s,s,s,s,P,P,1,-,0,0,u,u,-,-,-,d,d,d,d,d,"if (Pu) Rd=zxtb(Rs)"
+0,1,1,1,0,0,0,0,1,0,0,s,s,s,s,s,P,P,1,-,0,1,u,u,-,-,-,d,d,d,d,d,"if (Pu.new) Rd=zxtb(Rs)"
+0,1,1,1,0,0,0,0,1,0,0,s,s,s,s,s,P,P,1,-,1,0,u,u,-,-,-,d,d,d,d,d,"if (!Pu) Rd=zxtb(Rs)"
+0,1,1,1,0,0,0,0,1,0,0,s,s,s,s,s,P,P,1,-,1,1,u,u,-,-,-,d,d,d,d,d,"if (!Pu.new) Rd=zxtb(Rs)"
+0,1,1,1,0,0,0,0,1,1,0,s,s,s,s,s,P,P,1,-,0,0,u,u,-,-,-,d,d,d,d,d,"if (Pu) Rd=zxth(Rs)"
+0,1,1,1,0,0,0,0,1,1,0,s,s,s,s,s,P,P,1,-,0,1,u,u,-,-,-,d,d,d,d,d,"if (Pu.new) Rd=zxth(Rs)"
+0,1,1,1,0,0,0,0,1,1,0,s,s,s,s,s,P,P,1,-,1,0,u,u,-,-,-,d,d,d,d,d,"if (!Pu) Rd=zxth(Rs)"
+0,1,1,1,0,0,0,0,1,1,0,s,s,s,s,s,P,P,1,-,1,1,u,u,-,-,-,d,d,d,d,d,"if (!Pu.new) Rd=zxth(Rs)"
+0,1,1,1,0,1,0,1,0,0,j,s,s,s,s,s,P,P,j,j,j,j,j,j,j,j,j,0,0,0,d,d,"Pd=cmp.eq(Rs,#s10)"
+0,1,1,1,0,1,0,1,0,0,j,s,s,s,s,s,P,P,j,j,j,j,j,j,j,j,j,1,0,0,d,d,"Pd=!cmp.eq(Rs,#s10)"
+0,1,1,1,0,1,0,1,0,1,j,s,s,s,s,s,P,P,j,j,j,j,j,j,j,j,j,0,0,0,d,d,"Pd=cmp.gt(Rs,#s10)"
+0,1,1,1,0,1,0,1,0,1,j,s,s,s,s,s,P,P,j,j,j,j,j,j,j,j,j,1,0,0,d,d,"Pd=!cmp.gt(Rs,#s10)"
+0,1,1,1,0,1,0,1,1,0,0,s,s,s,s,s,P,P,j,j,j,j,j,j,j,j,j,0,0,0,d,d,"Pd=cmp.gtu(Rs,#u9)"
+0,1,1,1,0,1,0,1,1,0,0,s,s,s,s,s,P,P,j,j,j,j,j,j,j,j,j,1,0,0,d,d,"Pd=!cmp.gtu(Rs,#u9)"
+1,1,1,1,0,0,1,0,-,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,0,0,0,d,d,"Pd=cmp.eq(Rs,Rt)"
+1,1,1,1,0,0,1,0,-,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,1,0,0,d,d,"Pd=!cmp.eq(Rs,Rt)"
+1,1,1,1,0,0,1,0,-,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,0,0,0,d,d,"Pd=cmp.gt(Rs,Rt)"
+1,1,1,1,0,0,1,0,-,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,1,0,0,d,d,"Pd=!cmp.gt(Rs,Rt)"
+1,1,1,1,0,0,1,0,-,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,0,0,0,d,d,"Pd=cmp.gtu(Rs,Rt)"
+1,1,1,1,0,0,1,0,-,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,1,0,0,d,d,"Pd=!cmp.gtu(Rs,Rt)"
+0,1,1,1,0,0,1,1,-,1,0,s,s,s,s,s,P,P,1,j,j,j,j,j,j,j,j,d,d,d,d,d,"Rd=cmp.eq(Rs,#s8)"
+0,1,1,1,0,0,1,1,-,1,1,s,s,s,s,s,P,P,1,j,j,j,j,j,j,j,j,d,d,d,d,d,"Rd=!cmp.eq(Rs,#s8)"
+1,1,1,1,0,0,1,1,0,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,d,d,d,d,d,"Rd=cmp.eq(Rs,Rt)"
+1,1,1,1,0,0,1,1,0,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,d,d,d,d,d,"Rd=!cmp.eq(Rs,Rt)"
+0,1,1,0,1,0,1,1,0,0,0,0,-,-,s,s,P,P,1,-,-,-,t,t,1,-,-,1,-,-,d,d,"Pd=fastcorner9(Ps,Pt)"
+0,1,1,0,1,0,1,1,0,0,0,1,-,-,s,s,P,P,1,-,-,-,t,t,1,-,-,1,-,-,d,d,"Pd=!fastcorner9(Ps,Pt)"
+0,1,1,0,1,0,1,1,1,0,0,0,-,-,s,s,P,P,0,-,-,-,-,-,-,-,-,-,-,-,d,d,"Pd=any8(Ps)"
+0,1,1,0,1,0,1,1,1,0,1,0,-,-,s,s,P,P,0,-,-,-,-,-,-,-,-,-,-,-,d,d,"Pd=all8(Ps)"
+0,1,1,0,0,0,0,0,0,0,0,s,s,s,s,s,P,P,-,j,j,j,j,j,-,-,-,j,j,-,-,-,"loop0(#r7:2,Rs)"
+0,1,1,0,0,0,0,0,0,0,1,s,s,s,s,s,P,P,-,j,j,j,j,j,-,-,-,j,j,-,-,-,"loop1(#r7:2,Rs)"
+0,1,1,0,1,0,0,1,0,0,0,I,I,I,I,I,P,P,-,j,j,j,j,j,I,I,I,j,j,-,I,I,"loop0(#r7:2,#U10)"
+0,1,1,0,1,0,0,1,0,0,1,I,I,I,I,I,P,P,-,j,j,j,j,j,I,I,I,j,j,-,I,I,"loop1(#r7:2,#U10)"
+0,1,1,0,1,0,1,0,0,1,0,0,1,0,0,1,P,P,-,j,j,j,j,j,j,-,-,d,d,d,d,d,"Rd=add(pc,#u6)"
+0,1,1,0,0,0,0,0,1,0,1,s,s,s,s,s,P,P,-,j,j,j,j,j,-,-,-,j,j,-,-,-,"p3=sp1loop0(#r7:2,Rs)"
+0,1,1,0,0,0,0,0,1,1,0,s,s,s,s,s,P,P,-,j,j,j,j,j,-,-,-,j,j,-,-,-,"p3=sp2loop0(#r7:2,Rs)"
+0,1,1,0,0,0,0,0,1,1,1,s,s,s,s,s,P,P,-,j,j,j,j,j,-,-,-,j,j,-,-,-,"p3=sp3loop0(#r7:2,Rs)"
+0,1,1,0,1,0,0,1,1,0,1,I,I,I,I,I,P,P,-,j,j,j,j,j,I,I,I,j,j,-,I,I,"p3=sp1loop0(#r7:2,#U10)"
+0,1,1,0,1,0,0,1,1,1,0,I,I,I,I,I,P,P,-,j,j,j,j,j,I,I,I,j,j,-,I,I,"p3=sp2loop0(#r7:2,#U10)"
+0,1,1,0,1,0,0,1,1,1,1,I,I,I,I,I,P,P,-,j,j,j,j,j,I,I,I,j,j,-,I,I,"p3=sp3loop0(#r7:2,#U10)"
+0,1,1,0,1,0,1,1,0,0,0,0,-,-,s,s,P,P,0,-,-,-,t,t,-,-,-,-,-,-,d,d,"Pd=and(Pt,Ps)"
+0,1,1,0,1,0,1,1,0,0,0,1,-,-,s,s,P,P,0,-,-,-,t,t,u,u,-,-,-,-,d,d,"Pd=and(Ps,and(Pt,Pu))"
+0,1,1,0,1,0,1,1,0,0,1,0,-,-,s,s,P,P,0,-,-,-,t,t,-,-,-,-,-,-,d,d,"Pd=or(Pt,Ps)"
+0,1,1,0,1,0,1,1,0,0,1,1,-,-,s,s,P,P,0,-,-,-,t,t,u,u,-,-,-,-,d,d,"Pd=and(Ps,or(Pt,Pu))"
+0,1,1,0,1,0,1,1,0,1,0,0,-,-,s,s,P,P,0,-,-,-,t,t,-,-,-,-,-,-,d,d,"Pd=xor(Ps,Pt)"
+0,1,1,0,1,0,1,1,0,1,0,1,-,-,s,s,P,P,0,-,-,-,t,t,u,u,-,-,-,-,d,d,"Pd=or(Ps,and(Pt,Pu))"
+0,1,1,0,1,0,1,1,0,1,1,0,-,-,s,s,P,P,0,-,-,-,t,t,-,-,-,-,-,-,d,d,"Pd=and(Pt,!Ps)"
+0,1,1,0,1,0,1,1,0,1,1,1,-,-,s,s,P,P,0,-,-,-,t,t,u,u,-,-,-,-,d,d,"Pd=or(Ps,or(Pt,Pu))"
+0,1,1,0,1,0,1,1,1,0,0,1,-,-,s,s,P,P,0,-,-,-,t,t,u,u,-,-,-,-,d,d,"Pd=and(Ps,and(Pt,!Pu))"
+0,1,1,0,1,0,1,1,1,0,1,1,-,-,s,s,P,P,0,-,-,-,t,t,u,u,-,-,-,-,d,d,"Pd=and(Ps,or(Pt,!Pu))"
+0,1,1,0,1,0,1,1,1,1,0,0,-,-,s,s,P,P,0,-,-,-,-,-,-,-,-,-,-,-,d,d,"Pd=not(Ps)"
+0,1,1,0,1,0,1,1,1,1,0,1,-,-,s,s,P,P,0,-,-,-,t,t,u,u,-,-,-,-,d,d,"Pd=or(Ps,and(Pt,!Pu))"
+0,1,1,0,1,0,1,1,1,1,1,0,-,-,s,s,P,P,0,-,-,-,t,t,-,-,-,-,-,-,d,d,"Pd=or(Pt,!Ps)"
+0,1,1,0,1,0,1,1,1,1,1,1,-,-,s,s,P,P,0,-,-,-,t,t,u,u,-,-,-,-,d,d,"Pd=or(Ps,or(Pt,!Pu))"
+0,1,1,0,0,0,1,0,0,0,1,s,s,s,s,s,P,P,-,-,-,-,-,-,-,-,-,d,d,d,d,d,"Cd=Rs"
+0,1,1,0,0,0,1,1,0,0,1,s,s,s,s,s,P,P,-,-,-,-,-,-,-,-,-,d,d,d,d,d,"Cdd=Rss"
+0,1,1,0,1,0,0,0,0,0,0,s,s,s,s,s,P,P,-,-,-,-,-,-,-,-,-,d,d,d,d,d,"Rdd=Css"
+0,1,1,0,1,0,1,0,0,0,0,s,s,s,s,s,P,P,-,-,-,-,-,-,-,-,-,d,d,d,d,d,"Rd=Cs"
+0,1,0,1,0,0,0,0,1,0,1,s,s,s,s,s,P,P,-,-,-,-,-,-,-,-,-,-,-,-,-,-,"callr Rs"
+0,1,0,1,0,0,0,1,0,0,0,s,s,s,s,s,P,P,-,-,-,-,u,u,-,-,-,-,-,-,-,-,"if (Pu) callr Rs"
+0,1,0,1,0,0,0,1,0,0,1,s,s,s,s,s,P,P,-,-,-,-,u,u,-,-,-,-,-,-,-,-,"if (!Pu) callr Rs"
+0,1,0,1,0,0,1,0,1,0,1,s,s,s,s,s,P,P,-,-,-,-,-,-,-,-,-,-,-,-,-,-,"hintjr(Rs)"
+0,1,0,1,0,0,1,0,1,0,0,s,s,s,s,s,P,P,-,-,-,-,-,-,-,-,-,-,-,-,-,-,"jumpr Rs"
+0,1,0,1,0,0,1,1,0,1,0,s,s,s,s,s,P,P,-,0,0,-,u,u,-,-,-,-,-,-,-,-,"if (Pu) jumpr:nt Rs"
+0,1,0,1,0,0,1,1,0,1,0,s,s,s,s,s,P,P,-,0,1,-,u,u,-,-,-,-,-,-,-,-,"if (Pu.new) jumpr:nt Rs"
+0,1,0,1,0,0,1,1,0,1,0,s,s,s,s,s,P,P,-,1,0,-,u,u,-,-,-,-,-,-,-,-,"if (Pu) jumpr:t Rs"
+0,1,0,1,0,0,1,1,0,1,0,s,s,s,s,s,P,P,-,1,1,-,u,u,-,-,-,-,-,-,-,-,"if (Pu.new) jumpr:t Rs"
+0,1,0,1,0,0,1,1,0,1,1,s,s,s,s,s,P,P,-,0,0,-,u,u,-,-,-,-,-,-,-,-,"if (!Pu) jumpr:nt Rs"
+0,1,0,1,0,0,1,1,0,1,1,s,s,s,s,s,P,P,-,0,1,-,u,u,-,-,-,-,-,-,-,-,"if (!Pu.new) jumpr:nt Rs"
+0,1,0,1,0,0,1,1,0,1,1,s,s,s,s,s,P,P,-,1,0,-,u,u,-,-,-,-,-,-,-,-,"if (!Pu) jumpr:t Rs"
+0,1,0,1,0,0,1,1,0,1,1,s,s,s,s,s,P,P,-,1,1,-,u,u,-,-,-,-,-,-,-,-,"if (!Pu.new) jumpr:t Rs"
+0,1,0,1,1,0,1,j,j,j,j,j,j,j,j,j,P,P,j,j,j,j,j,j,j,j,j,j,j,j,j,0,"call #r22:2"
+0,1,0,1,1,1,0,1,j,j,0,j,j,j,j,j,P,P,j,-,0,-,u,u,j,j,j,j,j,j,j,-,"if (Pu) call #r15:2"
+0,1,0,1,1,1,0,1,j,j,1,j,j,j,j,j,P,P,j,-,0,-,u,u,j,j,j,j,j,j,j,-,"if (!Pu) call #r15:2"
+0,0,0,1,0,0,0,1,1,0,j,j,s,s,s,s,P,P,0,-,-,-,0,0,j,j,j,j,j,j,j,-,"p0=cmp.eq(Rs,#-1); if(p0.new) jump:nt #r9:2"
+0,0,0,1,0,0,0,1,1,0,j,j,s,s,s,s,P,P,0,-,-,-,0,1,j,j,j,j,j,j,j,-,"p0=cmp.gt(Rs,#-1); if(p0.new) jump:nt #r9:2"
+0,0,0,1,0,0,0,1,1,0,j,j,s,s,s,s,P,P,0,-,-,-,1,1,j,j,j,j,j,j,j,-,"p0=tstbit(Rs,#0); if (p0.new)jump:nt #r9:2"
+0,0,0,1,0,0,0,1,1,0,j,j,s,s,s,s,P,P,1,-,-,-,0,0,j,j,j,j,j,j,j,-,"p0=cmp.eq(Rs,#-1); if(p0.new) jump:t #r9:2"
+0,0,0,1,0,0,0,1,1,0,j,j,s,s,s,s,P,P,1,-,-,-,0,1,j,j,j,j,j,j,j,-,"p0=cmp.gt(Rs,#-1); if(p0.new) jump:t #r9:2"
+0,0,0,1,0,0,0,1,1,0,j,j,s,s,s,s,P,P,1,-,-,-,1,1,j,j,j,j,j,j,j,-,"p0=tstbit(Rs,#0); if (p0.new)jump:t #r9:2"
+0,0,0,1,0,0,0,1,1,1,j,j,s,s,s,s,P,P,0,-,-,-,0,0,j,j,j,j,j,j,j,-,"p0=cmp.eq(Rs,#-1); if(!p0.new) jump:nt #r9:2"
+0,0,0,1,0,0,0,1,1,1,j,j,s,s,s,s,P,P,0,-,-,-,0,1,j,j,j,j,j,j,j,-,"p0=cmp.gt(Rs,#-1); if(!p0.new) jump:nt #r9:2"
+0,0,0,1,0,0,0,1,1,1,j,j,s,s,s,s,P,P,0,-,-,-,1,1,j,j,j,j,j,j,j,-,"p0=tstbit(Rs,#0); if(!p0.new) jump:nt #r9:2"
+0,0,0,1,0,0,0,1,1,1,j,j,s,s,s,s,P,P,1,-,-,-,0,0,j,j,j,j,j,j,j,-,"p0=cmp.eq(Rs,#-1); if(!p0.new) jump:t #r9:2"
+0,0,0,1,0,0,0,1,1,1,j,j,s,s,s,s,P,P,1,-,-,-,0,1,j,j,j,j,j,j,j,-,"p0=cmp.gt(Rs,#-1); if(!p0.new) jump:t #r9:2"
+0,0,0,1,0,0,0,1,1,1,j,j,s,s,s,s,P,P,1,-,-,-,1,1,j,j,j,j,j,j,j,-,"p0=tstbit(Rs,#0); if(!p0.new) jump:t #r9:2"
+0,0,0,1,0,0,0,0,0,0,j,j,s,s,s,s,P,P,0,I,I,I,I,I,j,j,j,j,j,j,j,-,"p0=cmp.eq(Rs,#U5); if(p0.new) jump:nt #r9:2"
+0,0,0,1,0,0,0,0,0,0,j,j,s,s,s,s,P,P,1,I,I,I,I,I,j,j,j,j,j,j,j,-,"p0=cmp.eq(Rs,#U5); if(p0.new) jump:t #r9:2"
+0,0,0,1,0,0,0,0,0,1,j,j,s,s,s,s,P,P,0,I,I,I,I,I,j,j,j,j,j,j,j,-,"p0=cmp.eq(Rs,#U5); if(!p0.new) jump:nt #r9:2"
+0,0,0,1,0,0,0,0,0,1,j,j,s,s,s,s,P,P,1,I,I,I,I,I,j,j,j,j,j,j,j,-,"p0=cmp.eq(Rs,#U5); if(!p0.new) jump:t #r9:2"
+0,0,0,1,0,0,0,0,1,0,j,j,s,s,s,s,P,P,0,I,I,I,I,I,j,j,j,j,j,j,j,-,"p0=cmp.gt(Rs,#U5); if(p0.new) jump:nt #r9:2"
+0,0,0,1,0,0,0,0,1,0,j,j,s,s,s,s,P,P,1,I,I,I,I,I,j,j,j,j,j,j,j,-,"p0=cmp.gt(Rs,#U5); if(p0.new) jump:t #r9:2"
+0,0,0,1,0,0,0,0,1,1,j,j,s,s,s,s,P,P,0,I,I,I,I,I,j,j,j,j,j,j,j,-,"p0=cmp.gt(Rs,#U5); if(!p0.new) jump:nt #r9:2"
+0,0,0,1,0,0,0,0,1,1,j,j,s,s,s,s,P,P,1,I,I,I,I,I,j,j,j,j,j,j,j,-,"p0=cmp.gt(Rs,#U5); if(!p0.new) jump:t #r9:2"
+0,0,0,1,0,0,0,1,0,0,j,j,s,s,s,s,P,P,0,I,I,I,I,I,j,j,j,j,j,j,j,-,"p0=cmp.gtu(Rs,#U5); if(p0.new) jump:nt #r9:2"
+0,0,0,1,0,0,0,1,0,0,j,j,s,s,s,s,P,P,1,I,I,I,I,I,j,j,j,j,j,j,j,-,"p0=cmp.gtu(Rs,#U5); if(p0.new) jump:t #r9:2"
+0,0,0,1,0,0,0,1,0,1,j,j,s,s,s,s,P,P,0,I,I,I,I,I,j,j,j,j,j,j,j,-,"p0=cmp.gtu(Rs,#U5); if(!p0.new) jump:nt #r9:2"
+0,0,0,1,0,0,0,1,0,1,j,j,s,s,s,s,P,P,1,I,I,I,I,I,j,j,j,j,j,j,j,-,"p0=cmp.gtu(Rs,#U5); if(!p0.new) jump:t #r9:2"
+0,0,0,1,0,0,1,1,1,0,j,j,s,s,s,s,P,P,0,-,-,-,0,0,j,j,j,j,j,j,j,-,"p1=cmp.eq(Rs,#-1); if(p1.new) jump:nt #r9:2"
+0,0,0,1,0,0,1,1,1,0,j,j,s,s,s,s,P,P,0,-,-,-,0,1,j,j,j,j,j,j,j,-,"p1=cmp.gt(Rs,#-1); if(p1.new) jump:nt #r9:2"
+0,0,0,1,0,0,1,1,1,0,j,j,s,s,s,s,P,P,0,-,-,-,1,1,j,j,j,j,j,j,j,-,"p1=tstbit(Rs,#0); if (p1.new)jump:nt #r9:2"
+0,0,0,1,0,0,1,1,1,0,j,j,s,s,s,s,P,P,1,-,-,-,0,0,j,j,j,j,j,j,j,-,"p1=cmp.eq(Rs,#-1); if(p1.new) jump:t #r9:2"
+0,0,0,1,0,0,1,1,1,0,j,j,s,s,s,s,P,P,1,-,-,-,0,1,j,j,j,j,j,j,j,-,"p1=cmp.gt(Rs,#-1); if(p1.new) jump:t #r9:2"
+0,0,0,1,0,0,1,1,1,0,j,j,s,s,s,s,P,P,1,-,-,-,1,1,j,j,j,j,j,j,j,-,"p1=tstbit(Rs,#0); if (p1.new)jump:t #r9:2"
+0,0,0,1,0,0,1,1,1,1,j,j,s,s,s,s,P,P,0,-,-,-,0,0,j,j,j,j,j,j,j,-,"p1=cmp.eq(Rs,#-1); if(!p1.new) jump:nt #r9:2"
+0,0,0,1,0,0,1,1,1,1,j,j,s,s,s,s,P,P,0,-,-,-,0,1,j,j,j,j,j,j,j,-,"p1=cmp.gt(Rs,#-1); if(!p1.new) jump:nt #r9:2"
+0,0,0,1,0,0,1,1,1,1,j,j,s,s,s,s,P,P,0,-,-,-,1,1,j,j,j,j,j,j,j,-,"p1=tstbit(Rs,#0); if(!p1.new) jump:nt #r9:2"
+0,0,0,1,0,0,1,1,1,1,j,j,s,s,s,s,P,P,1,-,-,-,0,0,j,j,j,j,j,j,j,-,"p1=cmp.eq(Rs,#-1); if(!p1.new) jump:t #r9:2"
+0,0,0,1,0,0,1,1,1,1,j,j,s,s,s,s,P,P,1,-,-,-,0,1,j,j,j,j,j,j,j,-,"p1=cmp.gt(Rs,#-1); if(!p1.new) jump:t #r9:2"
+0,0,0,1,0,0,1,1,1,1,j,j,s,s,s,s,P,P,1,-,-,-,1,1,j,j,j,j,j,j,j,-,"p1=tstbit(Rs,#0); if(!p1.new) jump:t #r9:2"
+0,0,0,1,0,0,1,0,0,0,j,j,s,s,s,s,P,P,0,I,I,I,I,I,j,j,j,j,j,j,j,-,"p1=cmp.eq(Rs,#U5); if(p1.new) jump:nt #r9:2"
+0,0,0,1,0,0,1,0,0,0,j,j,s,s,s,s,P,P,1,I,I,I,I,I,j,j,j,j,j,j,j,-,"p1=cmp.eq(Rs,#U5); if(p1.new) jump:t #r9:2"
+0,0,0,1,0,0,1,0,0,1,j,j,s,s,s,s,P,P,0,I,I,I,I,I,j,j,j,j,j,j,j,-,"p1=cmp.eq(Rs,#U5); if(!p1.new) jump:nt #r9:2"
+0,0,0,1,0,0,1,0,0,1,j,j,s,s,s,s,P,P,1,I,I,I,I,I,j,j,j,j,j,j,j,-,"p1=cmp.eq(Rs,#U5); if(!p1.new) jump:t #r9:2"
+0,0,0,1,0,0,1,0,1,0,j,j,s,s,s,s,P,P,0,I,I,I,I,I,j,j,j,j,j,j,j,-,"p1=cmp.gt(Rs,#U5); if(p1.new) jump:nt #r9:2"
+0,0,0,1,0,0,1,0,1,0,j,j,s,s,s,s,P,P,1,I,I,I,I,I,j,j,j,j,j,j,j,-,"p1=cmp.gt(Rs,#U5); if(p1.new) jump:t #r9:2"
+0,0,0,1,0,0,1,0,1,1,j,j,s,s,s,s,P,P,0,I,I,I,I,I,j,j,j,j,j,j,j,-,"p1=cmp.gt(Rs,#U5); if(!p1.new) jump:nt #r9:2"
+0,0,0,1,0,0,1,0,1,1,j,j,s,s,s,s,P,P,1,I,I,I,I,I,j,j,j,j,j,j,j,-,"p1=cmp.gt(Rs,#U5); if(!p1.new) jump:t #r9:2"
+0,0,0,1,0,0,1,1,0,0,j,j,s,s,s,s,P,P,0,I,I,I,I,I,j,j,j,j,j,j,j,-,"p1=cmp.gtu(Rs,#U5); if(p1.new) jump:nt #r9:2"
+0,0,0,1,0,0,1,1,0,0,j,j,s,s,s,s,P,P,1,I,I,I,I,I,j,j,j,j,j,j,j,-,"p1=cmp.gtu(Rs,#U5); if(p1.new) jump:t #r9:2"
+0,0,0,1,0,0,1,1,0,1,j,j,s,s,s,s,P,P,0,I,I,I,I,I,j,j,j,j,j,j,j,-,"p1=cmp.gtu(Rs,#U5); if(!p1.new) jump:nt #r9:2"
+0,0,0,1,0,0,1,1,0,1,j,j,s,s,s,s,P,P,1,I,I,I,I,I,j,j,j,j,j,j,j,-,"p1=cmp.gtu(Rs,#U5); if(!p1.new) jump:t #r9:2"
+0,0,0,1,0,1,0,0,0,0,j,j,s,s,s,s,P,P,0,0,t,t,t,t,j,j,j,j,j,j,j,-,"p0=cmp.eq(Rs,Rt); if(p0.new) jump:nt #r9:2"
+0,0,0,1,0,1,0,0,0,0,j,j,s,s,s,s,P,P,0,1,t,t,t,t,j,j,j,j,j,j,j,-,"p1=cmp.eq(Rs,Rt); if(p1.new) jump:nt #r9:2"
+0,0,0,1,0,1,0,0,0,0,j,j,s,s,s,s,P,P,1,0,t,t,t,t,j,j,j,j,j,j,j,-,"p0=cmp.eq(Rs,Rt); if(p0.new) jump:t #r9:2"
+0,0,0,1,0,1,0,0,0,0,j,j,s,s,s,s,P,P,1,1,t,t,t,t,j,j,j,j,j,j,j,-,"p1=cmp.eq(Rs,Rt); if(p1.new) jump:t #r9:2"
+0,0,0,1,0,1,0,0,0,1,j,j,s,s,s,s,P,P,0,0,t,t,t,t,j,j,j,j,j,j,j,-,"p0=cmp.eq(Rs,Rt); if(!p0.new) jump:nt #r9:2"
+0,0,0,1,0,1,0,0,0,1,j,j,s,s,s,s,P,P,0,1,t,t,t,t,j,j,j,j,j,j,j,-,"p1=cmp.eq(Rs,Rt); if(!p1.new) jump:nt #r9:2"
+0,0,0,1,0,1,0,0,0,1,j,j,s,s,s,s,P,P,1,0,t,t,t,t,j,j,j,j,j,j,j,-,"p0=cmp.eq(Rs,Rt); if(!p0.new) jump:t #r9:2"
+0,0,0,1,0,1,0,0,0,1,j,j,s,s,s,s,P,P,1,1,t,t,t,t,j,j,j,j,j,j,j,-,"p1=cmp.eq(Rs,Rt); if(!p1.new) jump:t #r9:2"
+0,0,0,1,0,1,0,0,1,0,j,j,s,s,s,s,P,P,0,0,t,t,t,t,j,j,j,j,j,j,j,-,"p0=cmp.gt(Rs,Rt); if(p0.new) jump:nt #r9:2"
+0,0,0,1,0,1,0,0,1,0,j,j,s,s,s,s,P,P,0,1,t,t,t,t,j,j,j,j,j,j,j,-,"p1=cmp.gt(Rs,Rt); if(p1.new) jump:nt #r9:2"
+0,0,0,1,0,1,0,0,1,0,j,j,s,s,s,s,P,P,1,0,t,t,t,t,j,j,j,j,j,j,j,-,"p0=cmp.gt(Rs,Rt); if(p0.new) jump:t #r9:2"
+0,0,0,1,0,1,0,0,1,0,j,j,s,s,s,s,P,P,1,1,t,t,t,t,j,j,j,j,j,j,j,-,"p1=cmp.gt(Rs,Rt); if(p1.new) jump:t #r9:2"
+0,0,0,1,0,1,0,0,1,1,j,j,s,s,s,s,P,P,0,0,t,t,t,t,j,j,j,j,j,j,j,-,"p0=cmp.gt(Rs,Rt); if(!p0.new) jump:nt #r9:2"
+0,0,0,1,0,1,0,0,1,1,j,j,s,s,s,s,P,P,0,1,t,t,t,t,j,j,j,j,j,j,j,-,"p1=cmp.gt(Rs,Rt); if(!p1.new) jump:nt #r9:2"
+0,0,0,1,0,1,0,0,1,1,j,j,s,s,s,s,P,P,1,0,t,t,t,t,j,j,j,j,j,j,j,-,"p0=cmp.gt(Rs,Rt); if(!p0.new) jump:t #r9:2"
+0,0,0,1,0,1,0,0,1,1,j,j,s,s,s,s,P,P,1,1,t,t,t,t,j,j,j,j,j,j,j,-,"p1=cmp.gt(Rs,Rt); if(!p1.new) jump:t #r9:2"
+0,0,0,1,0,1,0,1,0,0,j,j,s,s,s,s,P,P,0,0,t,t,t,t,j,j,j,j,j,j,j,-,"p0=cmp.gtu(Rs,Rt); if(p0.new) jump:nt #r9:2"
+0,0,0,1,0,1,0,1,0,0,j,j,s,s,s,s,P,P,0,1,t,t,t,t,j,j,j,j,j,j,j,-,"p1=cmp.gtu(Rs,Rt); if(p1.new) jump:nt #r9:2"
+0,0,0,1,0,1,0,1,0,0,j,j,s,s,s,s,P,P,1,0,t,t,t,t,j,j,j,j,j,j,j,-,"p0=cmp.gtu(Rs,Rt); if(p0.new) jump:t #r9:2"
+0,0,0,1,0,1,0,1,0,0,j,j,s,s,s,s,P,P,1,1,t,t,t,t,j,j,j,j,j,j,j,-,"p1=cmp.gtu(Rs,Rt); if(p1.new) jump:t #r9:2"
+0,0,0,1,0,1,0,1,0,1,j,j,s,s,s,s,P,P,0,0,t,t,t,t,j,j,j,j,j,j,j,-,"p0=cmp.gtu(Rs,Rt); if(!p0.new) jump:nt #r9:2"
+0,0,0,1,0,1,0,1,0,1,j,j,s,s,s,s,P,P,0,1,t,t,t,t,j,j,j,j,j,j,j,-,"p1=cmp.gtu(Rs,Rt); if(!p1.new) jump:nt #r9:2"
+0,0,0,1,0,1,0,1,0,1,j,j,s,s,s,s,P,P,1,0,t,t,t,t,j,j,j,j,j,j,j,-,"p0=cmp.gtu(Rs,Rt); if(!p0.new) jump:t #r9:2"
+0,0,0,1,0,1,0,1,0,1,j,j,s,s,s,s,P,P,1,1,t,t,t,t,j,j,j,j,j,j,j,-,"p1=cmp.gtu(Rs,Rt); if(!p1.new) jump:t #r9:2"
+0,1,0,1,1,0,0,j,j,j,j,j,j,j,j,j,P,P,j,j,j,j,j,j,j,j,j,j,j,j,j,-,"jump #r22:2"
+0,1,0,1,1,1,0,0,j,j,0,j,j,j,j,j,P,P,j,0,0,-,u,u,j,j,j,j,j,j,j,-,"if (Pu) jump:nt #r15:2"
+0,1,0,1,1,1,0,0,j,j,0,j,j,j,j,j,P,P,j,1,0,-,u,u,j,j,j,j,j,j,j,-,"if (Pu) jump:t #r15:2"
+0,1,0,1,1,1,0,0,j,j,1,j,j,j,j,j,P,P,j,0,0,-,u,u,j,j,j,j,j,j,j,-,"if (!Pu) jump:nt #r15:2"
+0,1,0,1,1,1,0,0,j,j,1,j,j,j,j,j,P,P,j,1,0,-,u,u,j,j,j,j,j,j,j,-,"if (!Pu) jump:t #r15:2"
+0,1,0,1,1,1,0,0,j,j,0,j,j,j,j,j,P,P,j,0,1,-,u,u,j,j,j,j,j,j,j,-,"if (Pu.new) jump:nt #r15:2"
+0,1,0,1,1,1,0,0,j,j,0,j,j,j,j,j,P,P,j,1,1,-,u,u,j,j,j,j,j,j,j,-,"if (Pu.new) jump:t #r15:2"
+0,1,0,1,1,1,0,0,j,j,1,j,j,j,j,j,P,P,j,0,1,-,u,u,j,j,j,j,j,j,j,-,"if (!Pu.new) jump:nt #r15:2"
+0,1,0,1,1,1,0,0,j,j,1,j,j,j,j,j,P,P,j,1,1,-,u,u,j,j,j,j,j,j,j,-,"if (!Pu.new) jump:t #r15:2"
+0,1,1,0,0,0,0,1,0,0,j,s,s,s,s,s,P,P,j,0,j,j,j,j,j,j,j,j,j,j,j,-,"if (Rs!=#0) jump:nt #r13:2"
+0,1,1,0,0,0,0,1,0,0,j,s,s,s,s,s,P,P,j,1,j,j,j,j,j,j,j,j,j,j,j,-,"if (Rs!=#0) jump:t #r13:2"
+0,1,1,0,0,0,0,1,0,1,j,s,s,s,s,s,P,P,j,0,j,j,j,j,j,j,j,j,j,j,j,-,"if (Rs>=#0) jump:nt #r13:2"
+0,1,1,0,0,0,0,1,0,1,j,s,s,s,s,s,P,P,j,1,j,j,j,j,j,j,j,j,j,j,j,-,"if (Rs>=#0) jump:t #r13:2"
+0,1,1,0,0,0,0,1,1,0,j,s,s,s,s,s,P,P,j,0,j,j,j,j,j,j,j,j,j,j,j,-,"if (Rs==#0) jump:nt #r13:2"
+0,1,1,0,0,0,0,1,1,0,j,s,s,s,s,s,P,P,j,1,j,j,j,j,j,j,j,j,j,j,j,-,"if (Rs==#0) jump:t #r13:2"
+0,1,1,0,0,0,0,1,1,1,j,s,s,s,s,s,P,P,j,0,j,j,j,j,j,j,j,j,j,j,j,-,"if (Rs<=#0) jump:nt #r13:2"
+0,1,1,0,0,0,0,1,1,1,j,s,s,s,s,s,P,P,j,1,j,j,j,j,j,j,j,j,j,j,j,-,"if (Rs<=#0) jump:t #r13:2"
+0,0,0,1,0,1,1,0,-,-,j,j,d,d,d,d,P,P,I,I,I,I,I,I,j,j,j,j,j,j,j,-,"Rd=#U6 ; jump #r9:2"
+0,0,0,1,0,1,1,1,-,-,j,j,s,s,s,s,P,P,-,-,d,d,d,d,j,j,j,j,j,j,j,-,"Rd=Rs ; jump #r9:2"
+0,0,1,1,1,0,1,0,1,1,0,s,s,s,s,s,P,P,j,t,t,t,t,t,j,-,-,d,d,d,d,d,"Rdd=memd(Rs+Rt<<#u2)"
+0,1,0,0,1,j,j,1,1,1,0,j,j,j,j,j,P,P,j,j,j,j,j,j,j,j,j,d,d,d,d,d,"Rdd=memd(gp+#u16:3)"
+1,0,0,1,0,j,j,1,1,1,0,s,s,s,s,s,P,P,j,j,j,j,j,j,j,j,j,d,d,d,d,d,"Rdd=memd(Rs+#s11:3)"
+1,0,0,1,1,0,0,1,1,1,0,x,x,x,x,x,P,P,u,0,-,-,0,j,j,j,j,d,d,d,d,d,"Rdd=memd(Rx++#s4:3:circ(Mu))"
+1,0,0,1,1,0,0,1,1,1,0,x,x,x,x,x,P,P,u,0,-,-,1,-,0,-,-,d,d,d,d,d,"Rdd=memd(Rx++I:circ(Mu))"
+1,0,0,1,1,0,1,1,1,1,0,e,e,e,e,e,P,P,0,1,I,I,I,I,-,I,I,d,d,d,d,d,"Rdd=memd(Re=#U6)"
+1,0,0,1,1,0,1,1,1,1,0,x,x,x,x,x,P,P,0,0,-,-,-,j,j,j,j,d,d,d,d,d,"Rdd=memd(Rx++#s4:3)"
+1,0,0,1,1,1,0,1,1,1,0,t,t,t,t,t,P,P,j,1,I,I,I,I,j,I,I,d,d,d,d,d,"Rdd=memd(Rt<<#u2+#U6)"
+1,0,0,1,1,1,0,1,1,1,0,x,x,x,x,x,P,P,u,0,-,-,-,-,0,-,-,d,d,d,d,d,"Rdd=memd(Rx++Mu)"
+1,0,0,1,1,1,1,1,1,1,0,x,x,x,x,x,P,P,u,0,-,-,-,-,0,-,-,d,d,d,d,d,"Rdd=memd(Rx++Mu:brev)"
+0,0,1,1,0,0,0,0,1,1,0,s,s,s,s,s,P,P,j,t,t,t,t,t,j,v,v,d,d,d,d,d,"if (Pv)Rdd=memd(Rs+Rt<<#u2)"
+0,0,1,1,0,0,0,1,1,1,0,s,s,s,s,s,P,P,j,t,t,t,t,t,j,v,v,d,d,d,d,d,"if (!Pv)Rdd=memd(Rs+Rt<<#u2)"
+0,0,1,1,0,0,1,0,1,1,0,s,s,s,s,s,P,P,j,t,t,t,t,t,j,v,v,d,d,d,d,d,"if (Pv.new)Rdd=memd(Rs+Rt<<#u2)"
+0,0,1,1,0,0,1,1,1,1,0,s,s,s,s,s,P,P,j,t,t,t,t,t,j,v,v,d,d,d,d,d,"if (!Pv.new)Rdd=memd(Rs+Rt<<#u2)"
+0,1,0,0,0,0,0,1,1,1,0,s,s,s,s,s,P,P,0,t,t,j,j,j,j,j,j,d,d,d,d,d,"if (Pt)Rdd=memd(Rs+#u6:3)"
+0,1,0,0,0,0,1,1,1,1,0,s,s,s,s,s,P,P,0,t,t,j,j,j,j,j,j,d,d,d,d,d,"if (Pt.new)Rdd=memd(Rs+#u6:3)"
+0,1,0,0,0,1,0,1,1,1,0,s,s,s,s,s,P,P,0,t,t,j,j,j,j,j,j,d,d,d,d,d,"if (!Pt)Rdd=memd(Rs+#u6:3)"
+0,1,0,0,0,1,1,1,1,1,0,s,s,s,s,s,P,P,0,t,t,j,j,j,j,j,j,d,d,d,d,d,"if (!Pt.new)Rdd=memd(Rs+#u6:3)"
+1,0,0,1,1,0,1,1,1,1,0,x,x,x,x,x,P,P,1,0,0,t,t,j,j,j,j,d,d,d,d,d,"if (Pt)Rdd=memd(Rx++#s4:3)"
+1,0,0,1,1,0,1,1,1,1,0,x,x,x,x,x,P,P,1,0,1,t,t,j,j,j,j,d,d,d,d,d,"if (!Pt)Rdd=memd(Rx++#s4:3)"
+1,0,0,1,1,0,1,1,1,1,0,x,x,x,x,x,P,P,1,1,0,t,t,j,j,j,j,d,d,d,d,d,"if (Pt.new)Rdd=memd(Rx++#s4:3)"
+1,0,0,1,1,0,1,1,1,1,0,x,x,x,x,x,P,P,1,1,1,t,t,j,j,j,j,d,d,d,d,d,"if (!Pt.new)Rdd=memd(Rx++#s4:3)"
+1,0,0,1,1,1,1,1,1,1,0,j,j,j,j,j,P,P,1,0,0,t,t,j,1,-,-,d,d,d,d,d,"if (Pt) Rdd=memd(#u6)"
+1,0,0,1,1,1,1,1,1,1,0,j,j,j,j,j,P,P,1,0,1,t,t,j,1,-,-,d,d,d,d,d,"if (!Pt) Rdd=memd(#u6)"
+1,0,0,1,1,1,1,1,1,1,0,j,j,j,j,j,P,P,1,1,0,t,t,j,1,-,-,d,d,d,d,d,"if (Pt.new) Rdd=memd(#u6)"
+1,0,0,1,1,1,1,1,1,1,0,j,j,j,j,j,P,P,1,1,1,t,t,j,1,-,-,d,d,d,d,d,"if (!Pt.new)Rdd=memd(#u6)"
+0,0,1,1,1,0,1,0,0,0,0,s,s,s,s,s,P,P,j,t,t,t,t,t,j,-,-,d,d,d,d,d,"Rd=memb(Rs+Rt<<#u2)"
+0,1,0,0,1,j,j,1,0,0,0,j,j,j,j,j,P,P,j,j,j,j,j,j,j,j,j,d,d,d,d,d,"Rd=memb(gp+#u16:0)"
+1,0,0,1,0,j,j,1,0,0,0,s,s,s,s,s,P,P,j,j,j,j,j,j,j,j,j,d,d,d,d,d,"Rd=memb(Rs+#s11:0)"
+1,0,0,1,1,0,0,1,0,0,0,x,x,x,x,x,P,P,u,0,-,-,0,j,j,j,j,d,d,d,d,d,"Rd=memb(Rx++#s4:0:circ(Mu))"
+1,0,0,1,1,0,0,1,0,0,0,x,x,x,x,x,P,P,u,0,-,-,1,-,0,-,-,d,d,d,d,d,"Rd=memb(Rx++I:circ(Mu))"
+1,0,0,1,1,0,1,1,0,0,0,e,e,e,e,e,P,P,0,1,I,I,I,I,-,I,I,d,d,d,d,d,"Rd=memb(Re=#U6)"
+1,0,0,1,1,0,1,1,0,0,0,x,x,x,x,x,P,P,0,0,-,-,-,j,j,j,j,d,d,d,d,d,"Rd=memb(Rx++#s4:0)"
+1,0,0,1,1,1,0,1,0,0,0,t,t,t,t,t,P,P,j,1,I,I,I,I,j,I,I,d,d,d,d,d,"Rd=memb(Rt<<#u2+#U6)"
+1,0,0,1,1,1,0,1,0,0,0,x,x,x,x,x,P,P,u,0,-,-,-,-,0,-,-,d,d,d,d,d,"Rd=memb(Rx++Mu)"
+1,0,0,1,1,1,1,1,0,0,0,x,x,x,x,x,P,P,u,0,-,-,-,-,0,-,-,d,d,d,d,d,"Rd=memb(Rx++Mu:brev)"
+0,0,1,1,0,0,0,0,0,0,0,s,s,s,s,s,P,P,j,t,t,t,t,t,j,v,v,d,d,d,d,d,"if (Pv)Rd=memb(Rs+Rt<<#u2)"
+0,0,1,1,0,0,0,1,0,0,0,s,s,s,s,s,P,P,j,t,t,t,t,t,j,v,v,d,d,d,d,d,"if (!Pv)Rd=memb(Rs+Rt<<#u2)"
+0,0,1,1,0,0,1,0,0,0,0,s,s,s,s,s,P,P,j,t,t,t,t,t,j,v,v,d,d,d,d,d,"if (Pv.new)Rd=memb(Rs+Rt<<#u2)"
+0,0,1,1,0,0,1,1,0,0,0,s,s,s,s,s,P,P,j,t,t,t,t,t,j,v,v,d,d,d,d,d,"if (!Pv.new)Rd=memb(Rs+Rt<<#u2)"
+0,1,0,0,0,0,0,1,0,0,0,s,s,s,s,s,P,P,0,t,t,j,j,j,j,j,j,d,d,d,d,d,"if (Pt) Rd=memb(Rs+#u6:0)"
+0,1,0,0,0,0,1,1,0,0,0,s,s,s,s,s,P,P,0,t,t,j,j,j,j,j,j,d,d,d,d,d,"if (Pt.new)Rd=memb(Rs+#u6:0)"
+0,1,0,0,0,1,0,1,0,0,0,s,s,s,s,s,P,P,0,t,t,j,j,j,j,j,j,d,d,d,d,d,"if (!Pt)Rd=memb(Rs+#u6:0)"
+0,1,0,0,0,1,1,1,0,0,0,s,s,s,s,s,P,P,0,t,t,j,j,j,j,j,j,d,d,d,d,d,"if (!Pt.new)Rd=memb(Rs+#u6:0)"
+1,0,0,1,1,0,1,1,0,0,0,x,x,x,x,x,P,P,1,0,0,t,t,j,j,j,j,d,d,d,d,d,"if (Pt)Rd=memb(Rx++#s4:0)"
+1,0,0,1,1,0,1,1,0,0,0,x,x,x,x,x,P,P,1,0,1,t,t,j,j,j,j,d,d,d,d,d,"if (!Pt)Rd=memb(Rx++#s4:0)"
+1,0,0,1,1,0,1,1,0,0,0,x,x,x,x,x,P,P,1,1,0,t,t,j,j,j,j,d,d,d,d,d,"if (Pt.new)Rd=memb(Rx++#s4:0)"
+1,0,0,1,1,0,1,1,0,0,0,x,x,x,x,x,P,P,1,1,1,t,t,j,j,j,j,d,d,d,d,d,"if (!Pt.new)Rd=memb(Rx++#s4:0)"
+1,0,0,1,1,1,1,1,0,0,0,j,j,j,j,j,P,P,1,0,0,t,t,j,1,-,-,d,d,d,d,d,"if (Pt) Rd=memb(#u6)"
+1,0,0,1,1,1,1,1,0,0,0,j,j,j,j,j,P,P,1,0,1,t,t,j,1,-,-,d,d,d,d,d,"if (!Pt) Rd=memb(#u6)"
+1,0,0,1,1,1,1,1,0,0,0,j,j,j,j,j,P,P,1,1,0,t,t,j,1,-,-,d,d,d,d,d,"if (Pt.new) Rd=memb(#u6)"
+1,0,0,1,1,1,1,1,0,0,0,j,j,j,j,j,P,P,1,1,1,t,t,j,1,-,-,d,d,d,d,d,"if (!Pt.new) Rd=memb(#u6)"
+1,0,0,1,0,j,j,0,1,0,0,s,s,s,s,s,P,P,j,j,j,j,j,j,j,j,j,y,y,y,y,y,"Ryy=memb_fifo(Rs+#s11:0)"
+1,0,0,1,1,0,0,0,1,0,0,x,x,x,x,x,P,P,u,0,-,-,0,j,j,j,j,y,y,y,y,y,"Ryy=memb_fifo(Rx++#s4:0:circ(Mu))"
+1,0,0,1,1,0,0,0,1,0,0,x,x,x,x,x,P,P,u,0,-,-,1,-,0,-,-,y,y,y,y,y,"Ryy=memb_fifo(Rx++I:circ(Mu))"
+1,0,0,1,1,0,1,0,1,0,0,e,e,e,e,e,P,P,0,1,I,I,I,I,-,I,I,y,y,y,y,y,"Ryy=memb_fifo(Re=#U6)"
+1,0,0,1,1,0,1,0,1,0,0,x,x,x,x,x,P,P,0,0,-,-,-,j,j,j,j,y,y,y,y,y,"Ryy=memb_fifo(Rx++#s4:0)"
+1,0,0,1,1,1,0,0,1,0,0,t,t,t,t,t,P,P,j,1,I,I,I,I,j,I,I,y,y,y,y,y,"Ryy=memb_fifo(Rt<<#u2+#U6)"
+1,0,0,1,1,1,0,0,1,0,0,x,x,x,x,x,P,P,u,0,-,-,-,-,0,-,-,y,y,y,y,y,"Ryy=memb_fifo(Rx++Mu)"
+1,0,0,1,1,1,1,0,1,0,0,x,x,x,x,x,P,P,u,0,-,-,-,-,0,-,-,y,y,y,y,y,"Ryy=memb_fifo(Rx++Mu:brev)"
+1,0,0,1,0,j,j,0,0,1,0,s,s,s,s,s,P,P,j,j,j,j,j,j,j,j,j,y,y,y,y,y,"Ryy=memh_fifo(Rs+#s11:1)"
+1,0,0,1,1,0,0,0,0,1,0,x,x,x,x,x,P,P,u,0,-,-,0,j,j,j,j,y,y,y,y,y,"Ryy=memh_fifo(Rx++#s4:1:circ(Mu))"
+1,0,0,1,1,0,0,0,0,1,0,x,x,x,x,x,P,P,u,0,-,-,1,-,0,-,-,y,y,y,y,y,"Ryy=memh_fifo(Rx++I:circ(Mu))"
+1,0,0,1,1,0,1,0,0,1,0,e,e,e,e,e,P,P,0,1,I,I,I,I,-,I,I,y,y,y,y,y,"Ryy=memh_fifo(Re=#U6)"
+1,0,0,1,1,0,1,0,0,1,0,x,x,x,x,x,P,P,0,0,-,-,-,j,j,j,j,y,y,y,y,y,"Ryy=memh_fifo(Rx++#s4:1)"
+1,0,0,1,1,1,0,0,0,1,0,t,t,t,t,t,P,P,j,1,I,I,I,I,j,I,I,y,y,y,y,y,"Ryy=memh_fifo(Rt<<#u2+#U6)"
+1,0,0,1,1,1,0,0,0,1,0,x,x,x,x,x,P,P,u,0,-,-,-,-,0,-,-,y,y,y,y,y,"Ryy=memh_fifo(Rx++Mu)"
+1,0,0,1,1,1,1,0,0,1,0,x,x,x,x,x,P,P,u,0,-,-,-,-,0,-,-,y,y,y,y,y,"Ryy=memh_fifo(Rx++Mu:brev)"
+0,0,1,1,1,0,1,0,0,1,0,s,s,s,s,s,P,P,j,t,t,t,t,t,j,-,-,d,d,d,d,d,"Rd=memh(Rs+Rt<<#u2)"
+0,1,0,0,1,j,j,1,0,1,0,j,j,j,j,j,P,P,j,j,j,j,j,j,j,j,j,d,d,d,d,d,"Rd=memh(gp+#u16:1)"
+1,0,0,1,0,j,j,1,0,1,0,s,s,s,s,s,P,P,j,j,j,j,j,j,j,j,j,d,d,d,d,d,"Rd=memh(Rs+#s11:1)"
+1,0,0,1,1,0,0,1,0,1,0,x,x,x,x,x,P,P,u,0,-,-,0,j,j,j,j,d,d,d,d,d,"Rd=memh(Rx++#s4:1:circ(Mu))"
+1,0,0,1,1,0,0,1,0,1,0,x,x,x,x,x,P,P,u,0,-,-,1,-,0,-,-,d,d,d,d,d,"Rd=memh(Rx++I:circ(Mu))"
+1,0,0,1,1,0,1,1,0,1,0,e,e,e,e,e,P,P,0,1,I,I,I,I,-,I,I,d,d,d,d,d,"Rd=memh(Re=#U6)"
+1,0,0,1,1,0,1,1,0,1,0,x,x,x,x,x,P,P,0,0,-,-,-,j,j,j,j,d,d,d,d,d,"Rd=memh(Rx++#s4:1)"
+1,0,0,1,1,1,0,1,0,1,0,t,t,t,t,t,P,P,j,1,I,I,I,I,j,I,I,d,d,d,d,d,"Rd=memh(Rt<<#u2+#U6)"
+1,0,0,1,1,1,0,1,0,1,0,x,x,x,x,x,P,P,u,0,-,-,-,-,0,-,-,d,d,d,d,d,"Rd=memh(Rx++Mu)"
+1,0,0,1,1,1,1,1,0,1,0,x,x,x,x,x,P,P,u,0,-,-,-,-,0,-,-,d,d,d,d,d,"Rd=memh(Rx++Mu:brev)"
+0,0,1,1,0,0,0,0,0,1,0,s,s,s,s,s,P,P,j,t,t,t,t,t,j,v,v,d,d,d,d,d,"if (Pv)Rd=memh(Rs+Rt<<#u2)"
+0,0,1,1,0,0,0,1,0,1,0,s,s,s,s,s,P,P,j,t,t,t,t,t,j,v,v,d,d,d,d,d,"if (!Pv)Rd=memh(Rs+Rt<<#u2)"
+0,0,1,1,0,0,1,0,0,1,0,s,s,s,s,s,P,P,j,t,t,t,t,t,j,v,v,d,d,d,d,d,"if (Pv.new)Rd=memh(Rs+Rt<<#u2)"
+0,0,1,1,0,0,1,1,0,1,0,s,s,s,s,s,P,P,j,t,t,t,t,t,j,v,v,d,d,d,d,d,"if (!Pv.new)Rd=memh(Rs+Rt<<#u2)"
+0,1,0,0,0,0,0,1,0,1,0,s,s,s,s,s,P,P,0,t,t,j,j,j,j,j,j,d,d,d,d,d,"if (Pt) Rd=memh(Rs+#u6:1)"
+0,1,0,0,0,0,1,1,0,1,0,s,s,s,s,s,P,P,0,t,t,j,j,j,j,j,j,d,d,d,d,d,"if (Pt.new)Rd=memh(Rs+#u6:1)"
+0,1,0,0,0,1,0,1,0,1,0,s,s,s,s,s,P,P,0,t,t,j,j,j,j,j,j,d,d,d,d,d,"if (!Pt)Rd=memh(Rs+#u6:1)"
+0,1,0,0,0,1,1,1,0,1,0,s,s,s,s,s,P,P,0,t,t,j,j,j,j,j,j,d,d,d,d,d,"if (!Pt.new)Rd=memh(Rs+#u6:1)"
+1,0,0,1,1,0,1,1,0,1,0,x,x,x,x,x,P,P,1,0,0,t,t,j,j,j,j,d,d,d,d,d,"if (Pt)Rd=memh(Rx++#s4:1)"
+1,0,0,1,1,0,1,1,0,1,0,x,x,x,x,x,P,P,1,0,1,t,t,j,j,j,j,d,d,d,d,d,"if (!Pt)Rd=memh(Rx++#s4:1)"
+1,0,0,1,1,0,1,1,0,1,0,x,x,x,x,x,P,P,1,1,0,t,t,j,j,j,j,d,d,d,d,d,"if (Pt.new)Rd=memh(Rx++#s4:1)"
+1,0,0,1,1,0,1,1,0,1,0,x,x,x,x,x,P,P,1,1,1,t,t,j,j,j,j,d,d,d,d,d,"if (!Pt.new)Rd=memh(Rx++#s4:1)"
+1,0,0,1,1,1,1,1,0,1,0,j,j,j,j,j,P,P,1,0,0,t,t,j,1,-,-,d,d,d,d,d,"if (Pt) Rd=memh(#u6)"
+1,0,0,1,1,1,1,1,0,1,0,j,j,j,j,j,P,P,1,0,1,t,t,j,1,-,-,d,d,d,d,d,"if (!Pt) Rd=memh(#u6)"
+1,0,0,1,1,1,1,1,0,1,0,j,j,j,j,j,P,P,1,1,0,t,t,j,1,-,-,d,d,d,d,d,"if (Pt.new) Rd=memh(#u6)"
+1,0,0,1,1,1,1,1,0,1,0,j,j,j,j,j,P,P,1,1,1,t,t,j,1,-,-,d,d,d,d,d,"if (!Pt.new) Rd=memh(#u6)"
+0,0,1,1,1,0,1,0,0,0,1,s,s,s,s,s,P,P,j,t,t,t,t,t,j,-,-,d,d,d,d,d,"Rd=memub(Rs+Rt<<#u2)"
+0,1,0,0,1,j,j,1,0,0,1,j,j,j,j,j,P,P,j,j,j,j,j,j,j,j,j,d,d,d,d,d,"Rd=memub(gp+#u16:0)"
+1,0,0,1,0,j,j,1,0,0,1,s,s,s,s,s,P,P,j,j,j,j,j,j,j,j,j,d,d,d,d,d,"Rd=memub(Rs+#s11:0)"
+1,0,0,1,1,0,0,1,0,0,1,x,x,x,x,x,P,P,u,0,-,-,0,j,j,j,j,d,d,d,d,d,"Rd=memub(Rx++#s4:0:circ(Mu))"
+1,0,0,1,1,0,0,1,0,0,1,x,x,x,x,x,P,P,u,0,-,-,1,-,0,-,-,d,d,d,d,d,"Rd=memub(Rx++I:circ(Mu))"
+1,0,0,1,1,0,1,1,0,0,1,e,e,e,e,e,P,P,0,1,I,I,I,I,-,I,I,d,d,d,d,d,"Rd=memub(Re=#U6)"
+1,0,0,1,1,0,1,1,0,0,1,x,x,x,x,x,P,P,0,0,-,-,-,j,j,j,j,d,d,d,d,d,"Rd=memub(Rx++#s4:0)"
+1,0,0,1,1,1,0,1,0,0,1,t,t,t,t,t,P,P,j,1,I,I,I,I,j,I,I,d,d,d,d,d,"Rd=memub(Rt<<#u2+#U6)"
+1,0,0,1,1,1,0,1,0,0,1,x,x,x,x,x,P,P,u,0,-,-,-,-,0,-,-,d,d,d,d,d,"Rd=memub(Rx++Mu)"
+1,0,0,1,1,1,1,1,0,0,1,x,x,x,x,x,P,P,u,0,-,-,-,-,0,-,-,d,d,d,d,d,"Rd=memub(Rx++Mu:brev)"
+0,0,1,1,0,0,0,0,0,0,1,s,s,s,s,s,P,P,j,t,t,t,t,t,j,v,v,d,d,d,d,d,"if (Pv)Rd=memub(Rs+Rt<<#u2)"
+0,0,1,1,0,0,0,1,0,0,1,s,s,s,s,s,P,P,j,t,t,t,t,t,j,v,v,d,d,d,d,d,"if (!Pv)Rd=memub(Rs+Rt<<#u2)"
+0,0,1,1,0,0,1,0,0,0,1,s,s,s,s,s,P,P,j,t,t,t,t,t,j,v,v,d,d,d,d,d,"if (Pv.new)Rd=memub(Rs+Rt<<#u2)"
+0,0,1,1,0,0,1,1,0,0,1,s,s,s,s,s,P,P,j,t,t,t,t,t,j,v,v,d,d,d,d,d,"if (!Pv.new)Rd=memub(Rs+Rt<<#u2)"
+0,1,0,0,0,0,0,1,0,0,1,s,s,s,s,s,P,P,0,t,t,j,j,j,j,j,j,d,d,d,d,d,"if (Pt)Rd=memub(Rs+#u6:0)"
+0,1,0,0,0,0,1,1,0,0,1,s,s,s,s,s,P,P,0,t,t,j,j,j,j,j,j,d,d,d,d,d,"if (Pt.new)Rd=memub(Rs+#u6:0)"
+0,1,0,0,0,1,0,1,0,0,1,s,s,s,s,s,P,P,0,t,t,j,j,j,j,j,j,d,d,d,d,d,"if (!Pt)Rd=memub(Rs+#u6:0)"
+0,1,0,0,0,1,1,1,0,0,1,s,s,s,s,s,P,P,0,t,t,j,j,j,j,j,j,d,d,d,d,d,"if (!Pt.new)Rd=memub(Rs+#u6:0)"
+1,0,0,1,1,0,1,1,0,0,1,x,x,x,x,x,P,P,1,0,0,t,t,j,j,j,j,d,d,d,d,d,"if (Pt)Rd=memub(Rx++#s4:0)"
+1,0,0,1,1,0,1,1,0,0,1,x,x,x,x,x,P,P,1,0,1,t,t,j,j,j,j,d,d,d,d,d,"if (!Pt)Rd=memub(Rx++#s4:0)"
+1,0,0,1,1,0,1,1,0,0,1,x,x,x,x,x,P,P,1,1,0,t,t,j,j,j,j,d,d,d,d,d,"if (Pt.new)Rd=memub(Rx++#s4:0)"
+1,0,0,1,1,0,1,1,0,0,1,x,x,x,x,x,P,P,1,1,1,t,t,j,j,j,j,d,d,d,d,d,"if (!Pt.new)Rd=memub(Rx++#s4:0)"
+1,0,0,1,1,1,1,1,0,0,1,j,j,j,j,j,P,P,1,0,0,t,t,j,1,-,-,d,d,d,d,d,"if (Pt) Rd=memub(#u6)"
+1,0,0,1,1,1,1,1,0,0,1,j,j,j,j,j,P,P,1,0,1,t,t,j,1,-,-,d,d,d,d,d,"if (!Pt) Rd=memub(#u6)"
+1,0,0,1,1,1,1,1,0,0,1,j,j,j,j,j,P,P,1,1,0,t,t,j,1,-,-,d,d,d,d,d,"if (Pt.new) Rd=memub(#u6)"
+1,0,0,1,1,1,1,1,0,0,1,j,j,j,j,j,P,P,1,1,1,t,t,j,1,-,-,d,d,d,d,d,"if (!Pt.new)Rd=memub(#u6)"
+0,0,1,1,1,0,1,0,0,1,1,s,s,s,s,s,P,P,j,t,t,t,t,t,j,-,-,d,d,d,d,d,"Rd=memuh(Rs+Rt<<#u2)"
+0,1,0,0,1,j,j,1,0,1,1,j,j,j,j,j,P,P,j,j,j,j,j,j,j,j,j,d,d,d,d,d,"Rd=memuh(gp+#u16:1)"
+1,0,0,1,0,j,j,1,0,1,1,s,s,s,s,s,P,P,j,j,j,j,j,j,j,j,j,d,d,d,d,d,"Rd=memuh(Rs+#s11:1)"
+1,0,0,1,1,0,0,1,0,1,1,x,x,x,x,x,P,P,u,0,-,-,0,j,j,j,j,d,d,d,d,d,"Rd=memuh(Rx++#s4:1:circ(Mu))"
+1,0,0,1,1,0,0,1,0,1,1,x,x,x,x,x,P,P,u,0,-,-,1,-,0,-,-,d,d,d,d,d,"Rd=memuh(Rx++I:circ(Mu))"
+1,0,0,1,1,0,1,1,0,1,1,e,e,e,e,e,P,P,0,1,I,I,I,I,-,I,I,d,d,d,d,d,"Rd=memuh(Re=#U6)"
+1,0,0,1,1,0,1,1,0,1,1,x,x,x,x,x,P,P,0,0,-,-,-,j,j,j,j,d,d,d,d,d,"Rd=memuh(Rx++#s4:1)"
+1,0,0,1,1,1,0,1,0,1,1,t,t,t,t,t,P,P,j,1,I,I,I,I,j,I,I,d,d,d,d,d,"Rd=memuh(Rt<<#u2+#U6)"
+1,0,0,1,1,1,0,1,0,1,1,x,x,x,x,x,P,P,u,0,-,-,-,-,0,-,-,d,d,d,d,d,"Rd=memuh(Rx++Mu)"
+1,0,0,1,1,1,1,1,0,1,1,x,x,x,x,x,P,P,u,0,-,-,-,-,0,-,-,d,d,d,d,d,"Rd=memuh(Rx++Mu:brev)"
+0,0,1,1,0,0,0,0,0,1,1,s,s,s,s,s,P,P,j,t,t,t,t,t,j,v,v,d,d,d,d,d,"if (Pv)Rd=memuh(Rs+Rt<<#u2)"
+0,0,1,1,0,0,0,1,0,1,1,s,s,s,s,s,P,P,j,t,t,t,t,t,j,v,v,d,d,d,d,d,"if (!Pv)Rd=memuh(Rs+Rt<<#u2)"
+0,0,1,1,0,0,1,0,0,1,1,s,s,s,s,s,P,P,j,t,t,t,t,t,j,v,v,d,d,d,d,d,"if (Pv.new)Rd=memuh(Rs+Rt<<#u2)"
+0,0,1,1,0,0,1,1,0,1,1,s,s,s,s,s,P,P,j,t,t,t,t,t,j,v,v,d,d,d,d,d,"if (!Pv.new)Rd=memuh(Rs+Rt<<#u2)"
+0,1,0,0,0,0,0,1,0,1,1,s,s,s,s,s,P,P,0,t,t,j,j,j,j,j,j,d,d,d,d,d,"if (Pt)Rd=memuh(Rs+#u6:1)"
+0,1,0,0,0,0,1,1,0,1,1,s,s,s,s,s,P,P,0,t,t,j,j,j,j,j,j,d,d,d,d,d,"if (Pt.new)Rd=memuh(Rs+#u6:1)"
+0,1,0,0,0,1,0,1,0,1,1,s,s,s,s,s,P,P,0,t,t,j,j,j,j,j,j,d,d,d,d,d,"if (!Pt)Rd=memuh(Rs+#u6:1)"
+0,1,0,0,0,1,1,1,0,1,1,s,s,s,s,s,P,P,0,t,t,j,j,j,j,j,j,d,d,d,d,d,"if (!Pt.new)Rd=memuh(Rs+#u6:1)"
+1,0,0,1,1,0,1,1,0,1,1,x,x,x,x,x,P,P,1,0,0,t,t,j,j,j,j,d,d,d,d,d,"if (Pt)Rd=memuh(Rx++#s4:1)"
+1,0,0,1,1,0,1,1,0,1,1,x,x,x,x,x,P,P,1,0,1,t,t,j,j,j,j,d,d,d,d,d,"if (!Pt)Rd=memuh(Rx++#s4:1)"
+1,0,0,1,1,0,1,1,0,1,1,x,x,x,x,x,P,P,1,1,0,t,t,j,j,j,j,d,d,d,d,d,"if (Pt.new)Rd=memuh(Rx++#s4:1)"
+1,0,0,1,1,0,1,1,0,1,1,x,x,x,x,x,P,P,1,1,1,t,t,j,j,j,j,d,d,d,d,d,"if (!Pt.new)Rd=memuh(Rx++#s4:1)"
+1,0,0,1,1,1,1,1,0,1,1,j,j,j,j,j,P,P,1,0,0,t,t,j,1,-,-,d,d,d,d,d,"if (Pt) Rd=memuh(#u6)"
+1,0,0,1,1,1,1,1,0,1,1,j,j,j,j,j,P,P,1,0,1,t,t,j,1,-,-,d,d,d,d,d,"if (!Pt) Rd=memuh(#u6)"
+1,0,0,1,1,1,1,1,0,1,1,j,j,j,j,j,P,P,1,1,0,t,t,j,1,-,-,d,d,d,d,d,"if (Pt.new) Rd=memuh(#u6)"
+1,0,0,1,1,1,1,1,0,1,1,j,j,j,j,j,P,P,1,1,1,t,t,j,1,-,-,d,d,d,d,d,"if (!Pt.new)Rd=memuh(#u6)"
+0,0,1,1,1,0,1,0,1,0,0,s,s,s,s,s,P,P,j,t,t,t,t,t,j,-,-,d,d,d,d,d,"Rd=memw(Rs+Rt<<#u2)"
+0,1,0,0,1,j,j,1,1,0,0,j,j,j,j,j,P,P,j,j,j,j,j,j,j,j,j,d,d,d,d,d,"Rd=memw(gp+#u16:2)"
+1,0,0,1,0,j,j,1,1,0,0,s,s,s,s,s,P,P,j,j,j,j,j,j,j,j,j,d,d,d,d,d,"Rd=memw(Rs+#s11:2)"
+1,0,0,1,1,0,0,1,1,0,0,x,x,x,x,x,P,P,u,0,-,-,0,j,j,j,j,d,d,d,d,d,"Rd=memw(Rx++#s4:2:circ(Mu))"
+1,0,0,1,1,0,0,1,1,0,0,x,x,x,x,x,P,P,u,0,-,-,1,-,0,-,-,d,d,d,d,d,"Rd=memw(Rx++I:circ(Mu))"
+1,0,0,1,1,0,1,1,1,0,0,e,e,e,e,e,P,P,0,1,I,I,I,I,-,I,I,d,d,d,d,d,"Rd=memw(Re=#U6)"
+1,0,0,1,1,0,1,1,1,0,0,x,x,x,x,x,P,P,0,0,-,-,-,j,j,j,j,d,d,d,d,d,"Rd=memw(Rx++#s4:2)"
+1,0,0,1,1,1,0,1,1,0,0,t,t,t,t,t,P,P,j,1,I,I,I,I,j,I,I,d,d,d,d,d,"Rd=memw(Rt<<#u2+#U6)"
+1,0,0,1,1,1,0,1,1,0,0,x,x,x,x,x,P,P,u,0,-,-,-,-,0,-,-,d,d,d,d,d,"Rd=memw(Rx++Mu)"
+1,0,0,1,1,1,1,1,1,0,0,x,x,x,x,x,P,P,u,0,-,-,-,-,0,-,-,d,d,d,d,d,"Rd=memw(Rx++Mu:brev)"
+0,0,1,1,0,0,0,0,1,0,0,s,s,s,s,s,P,P,j,t,t,t,t,t,j,v,v,d,d,d,d,d,"if (Pv)Rd=memw(Rs+Rt<<#u2)"
+0,0,1,1,0,0,0,1,1,0,0,s,s,s,s,s,P,P,j,t,t,t,t,t,j,v,v,d,d,d,d,d,"if (!Pv)Rd=memw(Rs+Rt<<#u2)"
+0,0,1,1,0,0,1,0,1,0,0,s,s,s,s,s,P,P,j,t,t,t,t,t,j,v,v,d,d,d,d,d,"if (Pv.new)Rd=memw(Rs+Rt<<#u2)"
+0,0,1,1,0,0,1,1,1,0,0,s,s,s,s,s,P,P,j,t,t,t,t,t,j,v,v,d,d,d,d,d,"if (!Pv.new)Rd=memw(Rs+Rt<<#u2)"
+0,1,0,0,0,0,0,1,1,0,0,s,s,s,s,s,P,P,0,t,t,j,j,j,j,j,j,d,d,d,d,d,"if (Pt)Rd=memw(Rs+#u6:2)"
+0,1,0,0,0,0,1,1,1,0,0,s,s,s,s,s,P,P,0,t,t,j,j,j,j,j,j,d,d,d,d,d,"if (Pt.new)Rd=memw(Rs+#u6:2)"
+0,1,0,0,0,1,0,1,1,0,0,s,s,s,s,s,P,P,0,t,t,j,j,j,j,j,j,d,d,d,d,d,"if (!Pt)Rd=memw(Rs+#u6:2)"
+0,1,0,0,0,1,1,1,1,0,0,s,s,s,s,s,P,P,0,t,t,j,j,j,j,j,j,d,d,d,d,d,"if (!Pt.new)Rd=memw(Rs+#u6:2)"
+1,0,0,1,1,0,1,1,1,0,0,x,x,x,x,x,P,P,1,0,0,t,t,j,j,j,j,d,d,d,d,d,"if (Pt)Rd=memw(Rx++#s4:2)"
+1,0,0,1,1,0,1,1,1,0,0,x,x,x,x,x,P,P,1,0,1,t,t,j,j,j,j,d,d,d,d,d,"if (!Pt)Rd=memw(Rx++#s4:2)"
+1,0,0,1,1,0,1,1,1,0,0,x,x,x,x,x,P,P,1,1,0,t,t,j,j,j,j,d,d,d,d,d,"if (Pt.new)Rd=memw(Rx++#s4:2)"
+1,0,0,1,1,0,1,1,1,0,0,x,x,x,x,x,P,P,1,1,1,t,t,j,j,j,j,d,d,d,d,d,"if (!Pt.new)Rd=memw(Rx++#s4:2)"
+1,0,0,1,1,1,1,1,1,0,0,j,j,j,j,j,P,P,1,0,0,t,t,j,1,-,-,d,d,d,d,d,"if (Pt) Rd=memw(#u6)"
+1,0,0,1,1,1,1,1,1,0,0,j,j,j,j,j,P,P,1,0,1,t,t,j,1,-,-,d,d,d,d,d,"if (!Pt) Rd=memw(#u6)"
+1,0,0,1,1,1,1,1,1,0,0,j,j,j,j,j,P,P,1,1,0,t,t,j,1,-,-,d,d,d,d,d,"if (Pt.new) Rd=memw(#u6)"
+1,0,0,1,1,1,1,1,1,0,0,j,j,j,j,j,P,P,1,1,1,t,t,j,1,-,-,d,d,d,d,d,"if (!Pt.new) Rd=memw(#u6)"
+1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,P,P,0,-,-,-,-,-,-,-,-,1,1,1,1,0,"deallocframe"
+1,0,0,1,0,1,1,0,0,0,0,1,1,1,1,0,P,P,0,0,0,0,-,-,-,-,-,1,1,1,1,0,"dealloc_return"
+1,0,0,1,0,1,1,0,0,0,0,1,1,1,1,0,P,P,0,0,1,0,s,s,-,-,-,1,1,1,1,0,"if (Ps.new)dealloc_return:nt"
+1,0,0,1,0,1,1,0,0,0,0,1,1,1,1,0,P,P,0,1,0,0,s,s,-,-,-,1,1,1,1,0,"if (Ps) dealloc_return"
+1,0,0,1,0,1,1,0,0,0,0,1,1,1,1,0,P,P,0,1,1,0,s,s,-,-,-,1,1,1,1,0,"if (Ps.new) dealloc_return:t"
+1,0,0,1,0,1,1,0,0,0,0,1,1,1,1,0,P,P,1,0,1,0,s,s,-,-,-,1,1,1,1,0,"if (!Ps.new)dealloc_return:nt"
+1,0,0,1,0,1,1,0,0,0,0,1,1,1,1,0,P,P,1,1,0,0,s,s,-,-,-,1,1,1,1,0,"if (!Ps) dealloc_return"
+1,0,0,1,0,1,1,0,0,0,0,1,1,1,1,0,P,P,1,1,1,0,s,s,-,-,-,1,1,1,1,0,"if (!Ps.new) dealloc_return:t"
+1,0,0,1,0,j,j,0,0,0,1,s,s,s,s,s,P,P,j,j,j,j,j,j,j,j,j,d,d,d,d,d,"Rd=membh(Rs+#s11:1)"
+1,0,0,1,0,j,j,0,0,1,1,s,s,s,s,s,P,P,j,j,j,j,j,j,j,j,j,d,d,d,d,d,"Rd=memubh(Rs+#s11:1)"
+1,0,0,1,0,j,j,0,1,0,1,s,s,s,s,s,P,P,j,j,j,j,j,j,j,j,j,d,d,d,d,d,"Rdd=memubh(Rs+#s11:2)"
+1,0,0,1,0,j,j,0,1,1,1,s,s,s,s,s,P,P,j,j,j,j,j,j,j,j,j,d,d,d,d,d,"Rdd=membh(Rs+#s11:2)"
+1,0,0,1,1,0,0,0,0,0,1,x,x,x,x,x,P,P,u,0,-,-,0,j,j,j,j,d,d,d,d,d,"Rd=membh(Rx++#s4:1:circ(Mu))"
+1,0,0,1,1,0,0,0,0,0,1,x,x,x,x,x,P,P,u,0,-,-,1,-,0,-,-,d,d,d,d,d,"Rd=membh(Rx++I:circ(Mu))"
+1,0,0,1,1,0,0,0,0,1,1,x,x,x,x,x,P,P,u,0,-,-,0,j,j,j,j,d,d,d,d,d,"Rd=memubh(Rx++#s4:1:circ(Mu))"
+1,0,0,1,1,0,0,0,0,1,1,x,x,x,x,x,P,P,u,0,-,-,1,-,0,-,-,d,d,d,d,d,"Rd=memubh(Rx++I:circ(Mu))"
+1,0,0,1,1,0,0,0,1,0,1,x,x,x,x,x,P,P,u,0,-,-,0,j,j,j,j,d,d,d,d,d,"Rdd=memubh(Rx++#s4:2:circ(Mu))"
+1,0,0,1,1,0,0,0,1,0,1,x,x,x,x,x,P,P,u,0,-,-,1,-,0,-,-,d,d,d,d,d,"Rdd=memubh(Rx++I:circ(Mu))"
+1,0,0,1,1,0,0,0,1,1,1,x,x,x,x,x,P,P,u,0,-,-,0,j,j,j,j,d,d,d,d,d,"Rdd=membh(Rx++#s4:2:circ(Mu))"
+1,0,0,1,1,0,0,0,1,1,1,x,x,x,x,x,P,P,u,0,-,-,1,-,0,-,-,d,d,d,d,d,"Rdd=membh(Rx++I:circ(Mu))"
+1,0,0,1,1,0,1,0,0,0,1,e,e,e,e,e,P,P,0,1,I,I,I,I,-,I,I,d,d,d,d,d,"Rd=membh(Re=#U6)"
+1,0,0,1,1,0,1,0,0,0,1,x,x,x,x,x,P,P,0,0,-,-,-,j,j,j,j,d,d,d,d,d,"Rd=membh(Rx++#s4:1)"
+1,0,0,1,1,0,1,0,0,1,1,e,e,e,e,e,P,P,0,1,I,I,I,I,-,I,I,d,d,d,d,d,"Rd=memubh(Re=#U6)"
+1,0,0,1,1,0,1,0,0,1,1,x,x,x,x,x,P,P,0,0,-,-,-,j,j,j,j,d,d,d,d,d,"Rd=memubh(Rx++#s4:1)"
+1,0,0,1,1,0,1,0,1,0,1,e,e,e,e,e,P,P,0,1,I,I,I,I,-,I,I,d,d,d,d,d,"Rdd=memubh(Re=#U6)"
+1,0,0,1,1,0,1,0,1,0,1,x,x,x,x,x,P,P,0,0,-,-,-,j,j,j,j,d,d,d,d,d,"Rdd=memubh(Rx++#s4:2)"
+1,0,0,1,1,0,1,0,1,1,1,e,e,e,e,e,P,P,0,1,I,I,I,I,-,I,I,d,d,d,d,d,"Rdd=membh(Re=#U6)"
+1,0,0,1,1,0,1,0,1,1,1,x,x,x,x,x,P,P,0,0,-,-,-,j,j,j,j,d,d,d,d,d,"Rdd=membh(Rx++#s4:2)"
+1,0,0,1,1,1,0,0,0,0,1,t,t,t,t,t,P,P,j,1,I,I,I,I,j,I,I,d,d,d,d,d,"Rd=membh(Rt<<#u2+#U6)"
+1,0,0,1,1,1,0,0,0,0,1,x,x,x,x,x,P,P,u,0,-,-,-,-,0,-,-,d,d,d,d,d,"Rd=membh(Rx++Mu)"
+1,0,0,1,1,1,0,0,0,1,1,t,t,t,t,t,P,P,j,1,I,I,I,I,j,I,I,d,d,d,d,d,"Rd=memubh(Rt<<#u2+#U6)"
+1,0,0,1,1,1,0,0,0,1,1,x,x,x,x,x,P,P,u,0,-,-,-,-,0,-,-,d,d,d,d,d,"Rd=memubh(Rx++Mu)"
+1,0,0,1,1,1,0,0,1,0,1,t,t,t,t,t,P,P,j,1,I,I,I,I,j,I,I,d,d,d,d,d,"Rdd=memubh(Rt<<#u2+#U6)"
+1,0,0,1,1,1,0,0,1,0,1,x,x,x,x,x,P,P,u,0,-,-,-,-,0,-,-,d,d,d,d,d,"Rdd=memubh(Rx++Mu)"
+1,0,0,1,1,1,0,0,1,1,1,t,t,t,t,t,P,P,j,1,I,I,I,I,j,I,I,d,d,d,d,d,"Rdd=membh(Rt<<#u2+#U6)"
+1,0,0,1,1,1,0,0,1,1,1,x,x,x,x,x,P,P,u,0,-,-,-,-,0,-,-,d,d,d,d,d,"Rdd=membh(Rx++Mu)"
+1,0,0,1,1,1,1,0,0,0,1,x,x,x,x,x,P,P,u,0,-,-,-,-,0,-,-,d,d,d,d,d,"Rd=membh(Rx++Mu:brev)"
+1,0,0,1,1,1,1,0,0,1,1,x,x,x,x,x,P,P,u,0,-,-,-,-,0,-,-,d,d,d,d,d,"Rd=memubh(Rx++Mu:brev)"
+1,0,0,1,1,1,1,0,1,0,1,x,x,x,x,x,P,P,u,0,-,-,-,-,0,-,-,d,d,d,d,d,"Rdd=memubh(Rx++Mu:brev)"
+1,0,0,1,1,1,1,0,1,1,1,x,x,x,x,x,P,P,u,0,-,-,-,-,0,-,-,d,d,d,d,d,"Rdd=membh(Rx++Mu:brev)"
+0,0,1,1,1,1,1,0,-,0,0,s,s,s,s,s,P,P,0,j,j,j,j,j,j,0,0,t,t,t,t,t,"memb(Rs+#u6:0)+=Rt"
+0,0,1,1,1,1,1,0,-,0,0,s,s,s,s,s,P,P,0,j,j,j,j,j,j,0,1,t,t,t,t,t,"memb(Rs+#u6:0)-=Rt"
+0,0,1,1,1,1,1,0,-,0,0,s,s,s,s,s,P,P,0,j,j,j,j,j,j,1,0,t,t,t,t,t,"memb(Rs+#u6:0)&=Rt"
+0,0,1,1,1,1,1,0,-,0,0,s,s,s,s,s,P,P,0,j,j,j,j,j,j,1,1,t,t,t,t,t,"memb(Rs+#u6:0)|=Rt"
+0,0,1,1,1,1,1,1,-,0,0,s,s,s,s,s,P,P,0,j,j,j,j,j,j,0,0,I,I,I,I,I,"memb(Rs+#u6:0)+=#U5"
+0,0,1,1,1,1,1,1,-,0,0,s,s,s,s,s,P,P,0,j,j,j,j,j,j,0,1,I,I,I,I,I,"memb(Rs+#u6:0)-=#U5"
+0,0,1,1,1,1,1,1,-,0,0,s,s,s,s,s,P,P,0,j,j,j,j,j,j,1,0,I,I,I,I,I,"memb(Rs+#u6:0)=clrbit(#U5)"
+0,0,1,1,1,1,1,1,-,0,0,s,s,s,s,s,P,P,0,j,j,j,j,j,j,1,1,I,I,I,I,I,"memb(Rs+#u6:0)=setbit(#U5)"
+0,0,1,1,1,1,1,0,-,0,1,s,s,s,s,s,P,P,0,j,j,j,j,j,j,0,0,t,t,t,t,t,"memh(Rs+#u6:1)+=Rt"
+0,0,1,1,1,1,1,0,-,0,1,s,s,s,s,s,P,P,0,j,j,j,j,j,j,0,1,t,t,t,t,t,"memh(Rs+#u6:1)-=Rt"
+0,0,1,1,1,1,1,0,-,0,1,s,s,s,s,s,P,P,0,j,j,j,j,j,j,1,0,t,t,t,t,t,"memh(Rs+#u6:1)&=Rt"
+0,0,1,1,1,1,1,0,-,0,1,s,s,s,s,s,P,P,0,j,j,j,j,j,j,1,1,t,t,t,t,t,"memh(Rs+#u6:1)|=Rt"
+0,0,1,1,1,1,1,1,-,0,1,s,s,s,s,s,P,P,0,j,j,j,j,j,j,0,0,I,I,I,I,I,"memh(Rs+#u6:1)+=#U5"
+0,0,1,1,1,1,1,1,-,0,1,s,s,s,s,s,P,P,0,j,j,j,j,j,j,0,1,I,I,I,I,I,"memh(Rs+#u6:1)-=#U5"
+0,0,1,1,1,1,1,1,-,0,1,s,s,s,s,s,P,P,0,j,j,j,j,j,j,1,0,I,I,I,I,I,"memh(Rs+#u6:1)=clrbit(#U5)"
+0,0,1,1,1,1,1,1,-,0,1,s,s,s,s,s,P,P,0,j,j,j,j,j,j,1,1,I,I,I,I,I,"memh(Rs+#u6:1)=setbit(#U5)"
+0,0,1,1,1,1,1,0,-,1,0,s,s,s,s,s,P,P,0,j,j,j,j,j,j,0,0,t,t,t,t,t,"memw(Rs+#u6:2)+=Rt"
+0,0,1,1,1,1,1,0,-,1,0,s,s,s,s,s,P,P,0,j,j,j,j,j,j,0,1,t,t,t,t,t,"memw(Rs+#u6:2)-=Rt"
+0,0,1,1,1,1,1,0,-,1,0,s,s,s,s,s,P,P,0,j,j,j,j,j,j,1,0,t,t,t,t,t,"memw(Rs+#u6:2)&=Rt"
+0,0,1,1,1,1,1,0,-,1,0,s,s,s,s,s,P,P,0,j,j,j,j,j,j,1,1,t,t,t,t,t,"memw(Rs+#u6:2)|=Rt"
+0,0,1,1,1,1,1,1,-,1,0,s,s,s,s,s,P,P,0,j,j,j,j,j,j,0,0,I,I,I,I,I,"memw(Rs+#u6:2)+=#U5"
+0,0,1,1,1,1,1,1,-,1,0,s,s,s,s,s,P,P,0,j,j,j,j,j,j,0,1,I,I,I,I,I,"memw(Rs+#u6:2)-=#U5"
+0,0,1,1,1,1,1,1,-,1,0,s,s,s,s,s,P,P,0,j,j,j,j,j,j,1,0,I,I,I,I,I,"memw(Rs+#u6:2)=clrbit(#U5)"
+0,0,1,1,1,1,1,1,-,1,0,s,s,s,s,s,P,P,0,j,j,j,j,j,j,1,1,I,I,I,I,I,"memw(Rs+#u6:2)=setbit(#U5)"
+0,0,1,0,0,0,0,0,0,0,j,j,-,s,s,s,P,P,0,t,t,t,t,t,j,j,j,j,j,j,j,-,"if (cmp.eq(Ns.new,Rt))jump:nt #r9:2"
+0,0,1,0,0,0,0,0,0,0,j,j,-,s,s,s,P,P,1,t,t,t,t,t,j,j,j,j,j,j,j,-,"if (cmp.eq(Ns.new,Rt))jump:t #r9:2"
+0,0,1,0,0,0,0,0,0,1,j,j,-,s,s,s,P,P,0,t,t,t,t,t,j,j,j,j,j,j,j,-,"if (!cmp.eq(Ns.new,Rt))jump:nt #r9:2"
+0,0,1,0,0,0,0,0,0,1,j,j,-,s,s,s,P,P,1,t,t,t,t,t,j,j,j,j,j,j,j,-,"if (!cmp.eq(Ns.new,Rt))jump:t #r9:2"
+0,0,1,0,0,0,0,0,1,0,j,j,-,s,s,s,P,P,0,t,t,t,t,t,j,j,j,j,j,j,j,-,"if (cmp.gt(Ns.new,Rt))jump:nt #r9:2"
+0,0,1,0,0,0,0,0,1,0,j,j,-,s,s,s,P,P,1,t,t,t,t,t,j,j,j,j,j,j,j,-,"if (cmp.gt(Ns.new,Rt))jump:t #r9:2"
+0,0,1,0,0,0,0,0,1,1,j,j,-,s,s,s,P,P,0,t,t,t,t,t,j,j,j,j,j,j,j,-,"if (!cmp.gt(Ns.new,Rt))jump:nt #r9:2"
+0,0,1,0,0,0,0,0,1,1,j,j,-,s,s,s,P,P,1,t,t,t,t,t,j,j,j,j,j,j,j,-,"if (!cmp.gt(Ns.new,Rt))jump:t #r9:2"
+0,0,1,0,0,0,0,1,0,0,j,j,-,s,s,s,P,P,0,t,t,t,t,t,j,j,j,j,j,j,j,-,"if (cmp.gtu(Ns.new,Rt))jump:nt #r9:2"
+0,0,1,0,0,0,0,1,0,0,j,j,-,s,s,s,P,P,1,t,t,t,t,t,j,j,j,j,j,j,j,-,"if (cmp.gtu(Ns.new,Rt))jump:t #r9:2"
+0,0,1,0,0,0,0,1,0,1,j,j,-,s,s,s,P,P,0,t,t,t,t,t,j,j,j,j,j,j,j,-,"if (!cmp.gtu(Ns.new,Rt))jump:nt #r9:2"
+0,0,1,0,0,0,0,1,0,1,j,j,-,s,s,s,P,P,1,t,t,t,t,t,j,j,j,j,j,j,j,-,"if (!cmp.gtu(Ns.new,Rt))jump:t #r9:2"
+0,0,1,0,0,0,0,1,1,0,j,j,-,s,s,s,P,P,0,t,t,t,t,t,j,j,j,j,j,j,j,-,"if (cmp.gt(Rt,Ns.new))jump:nt #r9:2"
+0,0,1,0,0,0,0,1,1,0,j,j,-,s,s,s,P,P,1,t,t,t,t,t,j,j,j,j,j,j,j,-,"if (cmp.gt(Rt,Ns.new))jump:t #r9:2"
+0,0,1,0,0,0,0,1,1,1,j,j,-,s,s,s,P,P,0,t,t,t,t,t,j,j,j,j,j,j,j,-,"if (!cmp.gt(Rt,Ns.new))jump:nt #r9:2"
+0,0,1,0,0,0,0,1,1,1,j,j,-,s,s,s,P,P,1,t,t,t,t,t,j,j,j,j,j,j,j,-,"if (!cmp.gt(Rt,Ns.new))jump:t #r9:2"
+0,0,1,0,0,0,1,0,0,0,j,j,-,s,s,s,P,P,0,t,t,t,t,t,j,j,j,j,j,j,j,-,"if (cmp.gtu(Rt,Ns.new))jump:nt #r9:2"
+0,0,1,0,0,0,1,0,0,0,j,j,-,s,s,s,P,P,1,t,t,t,t,t,j,j,j,j,j,j,j,-,"if (cmp.gtu(Rt,Ns.new))jump:t #r9:2"
+0,0,1,0,0,0,1,0,0,1,j,j,-,s,s,s,P,P,0,t,t,t,t,t,j,j,j,j,j,j,j,-,"if (!cmp.gtu(Rt,Ns.new))jump:nt #r9:2"
+0,0,1,0,0,0,1,0,0,1,j,j,-,s,s,s,P,P,1,t,t,t,t,t,j,j,j,j,j,j,j,-,"if (!cmp.gtu(Rt,Ns.new))jump:t #r9:2"
+0,0,1,0,0,1,0,0,0,0,j,j,-,s,s,s,P,P,0,I,I,I,I,I,j,j,j,j,j,j,j,-,"if (cmp.eq(Ns.new,#U5))jump:nt #r9:2"
+0,0,1,0,0,1,0,0,0,0,j,j,-,s,s,s,P,P,1,I,I,I,I,I,j,j,j,j,j,j,j,-,"if (cmp.eq(Ns.new,#U5))jump:t #r9:2"
+0,0,1,0,0,1,0,0,0,1,j,j,-,s,s,s,P,P,0,I,I,I,I,I,j,j,j,j,j,j,j,-,"if (!cmp.eq(Ns.new,#U5))jump:nt #r9:2"
+0,0,1,0,0,1,0,0,0,1,j,j,-,s,s,s,P,P,1,I,I,I,I,I,j,j,j,j,j,j,j,-,"if (!cmp.eq(Ns.new,#U5))jump:t #r9:2"
+0,0,1,0,0,1,0,0,1,0,j,j,-,s,s,s,P,P,0,I,I,I,I,I,j,j,j,j,j,j,j,-,"if (cmp.gt(Ns.new,#U5))jump:nt #r9:2"
+0,0,1,0,0,1,0,0,1,0,j,j,-,s,s,s,P,P,1,I,I,I,I,I,j,j,j,j,j,j,j,-,"if (cmp.gt(Ns.new,#U5))jump:t #r9:2"
+0,0,1,0,0,1,0,0,1,1,j,j,-,s,s,s,P,P,0,I,I,I,I,I,j,j,j,j,j,j,j,-,"if (!cmp.gt(Ns.new,#U5))jump:nt #r9:2"
+0,0,1,0,0,1,0,0,1,1,j,j,-,s,s,s,P,P,1,I,I,I,I,I,j,j,j,j,j,j,j,-,"if (!cmp.gt(Ns.new,#U5))jump:t #r9:2"
+0,0,1,0,0,1,0,1,0,0,j,j,-,s,s,s,P,P,0,I,I,I,I,I,j,j,j,j,j,j,j,-,"if (cmp.gtu(Ns.new,#U5))jump:nt #r9:2"
+0,0,1,0,0,1,0,1,0,0,j,j,-,s,s,s,P,P,1,I,I,I,I,I,j,j,j,j,j,j,j,-,"if (cmp.gtu(Ns.new,#U5))jump:t #r9:2"
+0,0,1,0,0,1,0,1,0,1,j,j,-,s,s,s,P,P,0,I,I,I,I,I,j,j,j,j,j,j,j,-,"if (!cmp.gtu(Ns.new,#U5))jump:nt #r9:2"
+0,0,1,0,0,1,0,1,0,1,j,j,-,s,s,s,P,P,1,I,I,I,I,I,j,j,j,j,j,j,j,-,"if (!cmp.gtu(Ns.new,#U5))jump:t #r9:2"
+0,0,1,0,0,1,0,1,1,0,j,j,-,s,s,s,P,P,0,-,-,-,-,-,j,j,j,j,j,j,j,-,"if (tstbit(Ns.new,#0))jump:nt #r9:2"
+0,0,1,0,0,1,0,1,1,0,j,j,-,s,s,s,P,P,1,-,-,-,-,-,j,j,j,j,j,j,j,-,"if (tstbit(Ns.new,#0)) jump:t#r9:2"
+0,0,1,0,0,1,0,1,1,1,j,j,-,s,s,s,P,P,0,-,-,-,-,-,j,j,j,j,j,j,j,-,"if (!tstbit(Ns.new,#0))jump:nt #r9:2"
+0,0,1,0,0,1,0,1,1,1,j,j,-,s,s,s,P,P,1,-,-,-,-,-,j,j,j,j,j,j,j,-,"if (!tstbit(Ns.new,#0)) jump:t#r9:2"
+0,0,1,0,0,1,1,0,0,0,j,j,-,s,s,s,P,P,0,-,-,-,-,-,j,j,j,j,j,j,j,-,"if (cmp.eq(Ns.new,#-1))jump:nt #r9:2"
+0,0,1,0,0,1,1,0,0,0,j,j,-,s,s,s,P,P,1,-,-,-,-,-,j,j,j,j,j,j,j,-,"if (cmp.eq(Ns.new,#-1))jump:t #r9:2"
+0,0,1,0,0,1,1,0,0,1,j,j,-,s,s,s,P,P,0,-,-,-,-,-,j,j,j,j,j,j,j,-,"if (!cmp.eq(Ns.new,#-1))jump:nt #r9:2"
+0,0,1,0,0,1,1,0,0,1,j,j,-,s,s,s,P,P,1,-,-,-,-,-,j,j,j,j,j,j,j,-,"if (!cmp.eq(Ns.new,#-1))jump:t #r9:2"
+0,0,1,0,0,1,1,0,1,0,j,j,-,s,s,s,P,P,0,-,-,-,-,-,j,j,j,j,j,j,j,-,"if (cmp.gt(Ns.new,#-1))jump:nt #r9:2"
+0,0,1,0,0,1,1,0,1,0,j,j,-,s,s,s,P,P,1,-,-,-,-,-,j,j,j,j,j,j,j,-,"if (cmp.gt(Ns.new,#-1))jump:t #r9:2"
+0,0,1,0,0,1,1,0,1,1,j,j,-,s,s,s,P,P,0,-,-,-,-,-,j,j,j,j,j,j,j,-,"if (!cmp.gt(Ns.new,#-1))jump:nt #r9:2"
+0,0,1,0,0,1,1,0,1,1,j,j,-,s,s,s,P,P,1,-,-,-,-,-,j,j,j,j,j,j,j,-,"if (!cmp.gt(Ns.new,#-1))jump:t #r9:2"
+0,0,1,1,1,0,1,1,1,0,1,s,s,s,s,s,P,P,j,u,u,u,u,u,j,-,-,0,0,t,t,t,"memb(Rs+Ru<<#u2)=Nt.new"
+0,1,0,0,1,j,j,0,1,0,1,j,j,j,j,j,P,P,j,0,0,t,t,t,j,j,j,j,j,j,j,j,"memb(gp+#u16:0)=Nt.new"
+1,0,1,0,0,j,j,1,1,0,1,s,s,s,s,s,P,P,j,0,0,t,t,t,j,j,j,j,j,j,j,j,"memb(Rs+#s11:0)=Nt.new"
+1,0,1,0,1,0,0,1,1,0,1,x,x,x,x,x,P,P,u,0,0,t,t,t,0,-,-,-,-,-,1,-,"memb(Rx++I:circ(Mu))=Nt.new"
+1,0,1,0,1,0,0,1,1,0,1,x,x,x,x,x,P,P,u,0,0,t,t,t,0,j,j,j,j,-,0,-,"memb(Rx++#s4:0:circ(Mu))=Nt.new"
+1,0,1,0,1,0,1,1,1,0,1,e,e,e,e,e,P,P,0,0,0,t,t,t,1,-,I,I,I,I,I,I,"memb(Re=#U6)=Nt.new"
+1,0,1,0,1,0,1,1,1,0,1,x,x,x,x,x,P,P,0,0,0,t,t,t,0,j,j,j,j,-,0,-,"memb(Rx++#s4:0)=Nt.new"
+1,0,1,0,1,1,0,1,1,0,1,u,u,u,u,u,P,P,j,0,0,t,t,t,1,j,I,I,I,I,I,I,"memb(Ru<<#u2+#U6)=Nt.new"
+1,0,1,0,1,1,0,1,1,0,1,x,x,x,x,x,P,P,u,0,0,t,t,t,0,-,-,-,-,-,-,-,"memb(Rx++Mu)=Nt.new"
+1,0,1,0,1,1,1,1,1,0,1,x,x,x,x,x,P,P,u,0,0,t,t,t,0,-,-,-,-,-,-,-,"memb(Rx++Mu:brev)=Nt.new"
+0,0,1,1,0,1,0,0,1,0,1,s,s,s,s,s,P,P,j,u,u,u,u,u,j,v,v,0,0,t,t,t,"if (Pv)memb(Rs+Ru<<#u2)=Nt.new"
+0,0,1,1,0,1,0,1,1,0,1,s,s,s,s,s,P,P,j,u,u,u,u,u,j,v,v,0,0,t,t,t,"if (!Pv)memb(Rs+Ru<<#u2)=Nt.new"
+0,0,1,1,0,1,1,0,1,0,1,s,s,s,s,s,P,P,j,u,u,u,u,u,j,v,v,0,0,t,t,t,"if (Pv.new)memb(Rs+Ru<<#u2)=Nt.new"
+0,0,1,1,0,1,1,1,1,0,1,s,s,s,s,s,P,P,j,u,u,u,u,u,j,v,v,0,0,t,t,t,"if (!Pv.new)memb(Rs+Ru<<#u2)=Nt.new"
+0,1,0,0,0,0,0,0,1,0,1,s,s,s,s,s,P,P,j,0,0,t,t,t,j,j,j,j,j,0,v,v,"if (Pv)memb(Rs+#u6:0)=Nt.new"
+0,1,0,0,0,0,1,0,1,0,1,s,s,s,s,s,P,P,j,0,0,t,t,t,j,j,j,j,j,0,v,v,"if (Pv.new)memb(Rs+#u6:0)=Nt.new"
+0,1,0,0,0,1,0,0,1,0,1,s,s,s,s,s,P,P,j,0,0,t,t,t,j,j,j,j,j,0,v,v,"if (!Pv)memb(Rs+#u6:0)=Nt.new"
+0,1,0,0,0,1,1,0,1,0,1,s,s,s,s,s,P,P,j,0,0,t,t,t,j,j,j,j,j,0,v,v,"if (!Pv.new)memb(Rs+#u6:0)=Nt.new"
+1,0,1,0,1,0,1,1,1,0,1,x,x,x,x,x,P,P,1,0,0,t,t,t,0,j,j,j,j,0,v,v,"if (Pv)memb(Rx++#s4:0)=Nt.new"
+1,0,1,0,1,0,1,1,1,0,1,x,x,x,x,x,P,P,1,0,0,t,t,t,0,j,j,j,j,1,v,v,"if (!Pv)memb(Rx++#s4:0)=Nt.new"
+1,0,1,0,1,0,1,1,1,0,1,x,x,x,x,x,P,P,1,0,0,t,t,t,1,j,j,j,j,0,v,v,"if (Pv.new)memb(Rx++#s4:0)=Nt.new"
+1,0,1,0,1,0,1,1,1,0,1,x,x,x,x,x,P,P,1,0,0,t,t,t,1,j,j,j,j,1,v,v,"if (!Pv.new)memb(Rx++#s4:0)=Nt.new"
+1,0,1,0,1,1,1,1,1,0,1,-,-,-,j,j,P,P,0,0,0,t,t,t,1,j,j,j,j,0,v,v,"if (Pv) memb(#u6)=Nt.new"
+1,0,1,0,1,1,1,1,1,0,1,-,-,-,j,j,P,P,0,0,0,t,t,t,1,j,j,j,j,1,v,v,"if (!Pv) memb(#u6)=Nt.new"
+1,0,1,0,1,1,1,1,1,0,1,-,-,-,j,j,P,P,1,0,0,t,t,t,1,j,j,j,j,0,v,v,"if (Pv.new)memb(#u6)=Nt.new"
+1,0,1,0,1,1,1,1,1,0,1,-,-,-,j,j,P,P,1,0,0,t,t,t,1,j,j,j,j,1,v,v,"if (!Pv.new)memb(#u6)=Nt.new"
+0,0,1,1,1,0,1,1,1,0,1,s,s,s,s,s,P,P,j,u,u,u,u,u,j,-,-,0,1,t,t,t,"memh(Rs+Ru<<#u2)=Nt.new"
+0,1,0,0,1,j,j,0,1,0,1,j,j,j,j,j,P,P,j,0,1,t,t,t,j,j,j,j,j,j,j,j,"memh(gp+#u16:1)=Nt.new"
+1,0,1,0,0,j,j,1,1,0,1,s,s,s,s,s,P,P,j,0,1,t,t,t,j,j,j,j,j,j,j,j,"memh(Rs+#s11:1)=Nt.new"
+1,0,1,0,1,0,0,1,1,0,1,x,x,x,x,x,P,P,u,0,1,t,t,t,0,-,-,-,-,-,1,-,"memh(Rx++I:circ(Mu))=Nt.new"
+1,0,1,0,1,0,0,1,1,0,1,x,x,x,x,x,P,P,u,0,1,t,t,t,0,j,j,j,j,-,0,-,"memh(Rx++#s4:1:circ(Mu))=Nt.new"
+1,0,1,0,1,0,1,1,1,0,1,e,e,e,e,e,P,P,0,0,1,t,t,t,1,-,I,I,I,I,I,I,"memh(Re=#U6)=Nt.new"
+1,0,1,0,1,0,1,1,1,0,1,x,x,x,x,x,P,P,0,0,1,t,t,t,0,j,j,j,j,-,0,-,"memh(Rx++#s4:1)=Nt.new"
+1,0,1,0,1,1,0,1,1,0,1,u,u,u,u,u,P,P,j,0,1,t,t,t,1,j,I,I,I,I,I,I,"memh(Ru<<#u2+#U6)=Nt.new"
+1,0,1,0,1,1,0,1,1,0,1,x,x,x,x,x,P,P,u,0,1,t,t,t,0,-,-,-,-,-,-,-,"memh(Rx++Mu)=Nt.new"
+1,0,1,0,1,1,1,1,1,0,1,x,x,x,x,x,P,P,u,0,1,t,t,t,0,-,-,-,-,-,-,-,"memh(Rx++Mu:brev)=Nt.new"
+0,0,1,1,0,1,0,0,1,0,1,s,s,s,s,s,P,P,j,u,u,u,u,u,j,v,v,0,1,t,t,t,"if (Pv)memh(Rs+Ru<<#u2)=Nt.new"
+0,0,1,1,0,1,0,1,1,0,1,s,s,s,s,s,P,P,j,u,u,u,u,u,j,v,v,0,1,t,t,t,"if (!Pv)memh(Rs+Ru<<#u2)=Nt.new"
+0,0,1,1,0,1,1,0,1,0,1,s,s,s,s,s,P,P,j,u,u,u,u,u,j,v,v,0,1,t,t,t,"if (Pv.new)memh(Rs+Ru<<#u2)=Nt.new"
+0,0,1,1,0,1,1,1,1,0,1,s,s,s,s,s,P,P,j,u,u,u,u,u,j,v,v,0,1,t,t,t,"if (!Pv.new)memh(Rs+Ru<<#u2)=Nt.new"
+0,1,0,0,0,0,0,0,1,0,1,s,s,s,s,s,P,P,j,0,1,t,t,t,j,j,j,j,j,0,v,v,"if (Pv)memh(Rs+#u6:1)=Nt.new"
+0,1,0,0,0,0,1,0,1,0,1,s,s,s,s,s,P,P,j,0,1,t,t,t,j,j,j,j,j,0,v,v,"if (Pv.new)memh(Rs+#u6:1)=Nt.new"
+0,1,0,0,0,1,0,0,1,0,1,s,s,s,s,s,P,P,j,0,1,t,t,t,j,j,j,j,j,0,v,v,"if (!Pv)memh(Rs+#u6:1)=Nt.new"
+0,1,0,0,0,1,1,0,1,0,1,s,s,s,s,s,P,P,j,0,1,t,t,t,j,j,j,j,j,0,v,v,"if (!Pv.new)memh(Rs+#u6:1)=Nt.new"
+1,0,1,0,1,0,1,1,1,0,1,x,x,x,x,x,P,P,1,0,1,t,t,t,0,j,j,j,j,0,v,v,"if (Pv)memh(Rx++#s4:1)=Nt.new"
+1,0,1,0,1,0,1,1,1,0,1,x,x,x,x,x,P,P,1,0,1,t,t,t,0,j,j,j,j,1,v,v,"if (!Pv)memh(Rx++#s4:1)=Nt.new"
+1,0,1,0,1,0,1,1,1,0,1,x,x,x,x,x,P,P,1,0,1,t,t,t,1,j,j,j,j,0,v,v,"if (Pv.new)memh(Rx++#s4:1)=Nt.new"
+1,0,1,0,1,0,1,1,1,0,1,x,x,x,x,x,P,P,1,0,1,t,t,t,1,j,j,j,j,1,v,v,"if (!Pv.new)memh(Rx++#s4:1)=Nt.new"
+1,0,1,0,1,1,1,1,1,0,1,-,-,-,j,j,P,P,0,0,1,t,t,t,1,j,j,j,j,0,v,v,"if (Pv) memh(#u6)=Nt.new"
+1,0,1,0,1,1,1,1,1,0,1,-,-,-,j,j,P,P,0,0,1,t,t,t,1,j,j,j,j,1,v,v,"if (!Pv) memh(#u6)=Nt.new"
+1,0,1,0,1,1,1,1,1,0,1,-,-,-,j,j,P,P,1,0,1,t,t,t,1,j,j,j,j,0,v,v,"if (Pv.new)memh(#u6)=Nt.new"
+1,0,1,0,1,1,1,1,1,0,1,-,-,-,j,j,P,P,1,0,1,t,t,t,1,j,j,j,j,1,v,v,"if (!Pv.new)memh(#u6)=Nt.new"
+0,0,1,1,1,0,1,1,1,0,1,s,s,s,s,s,P,P,j,u,u,u,u,u,j,-,-,1,0,t,t,t,"memw(Rs+Ru<<#u2)=Nt.new"
+0,1,0,0,1,j,j,0,1,0,1,j,j,j,j,j,P,P,j,1,0,t,t,t,j,j,j,j,j,j,j,j,"memw(gp+#u16:2)=Nt.new"
+1,0,1,0,0,j,j,1,1,0,1,s,s,s,s,s,P,P,j,1,0,t,t,t,j,j,j,j,j,j,j,j,"memw(Rs+#s11:2)=Nt.new"
+1,0,1,0,1,0,0,1,1,0,1,x,x,x,x,x,P,P,u,1,0,t,t,t,0,-,-,-,-,-,1,-,"memw(Rx++I:circ(Mu))=Nt.new"
+1,0,1,0,1,0,0,1,1,0,1,x,x,x,x,x,P,P,u,1,0,t,t,t,0,j,j,j,j,-,0,-,"memw(Rx++#s4:2:circ(Mu))=Nt.new"
+1,0,1,0,1,0,1,1,1,0,1,e,e,e,e,e,P,P,0,1,0,t,t,t,1,-,I,I,I,I,I,I,"memw(Re=#U6)=Nt.new"
+1,0,1,0,1,0,1,1,1,0,1,x,x,x,x,x,P,P,0,1,0,t,t,t,0,j,j,j,j,-,0,-,"memw(Rx++#s4:2)=Nt.new"
+1,0,1,0,1,1,0,1,1,0,1,u,u,u,u,u,P,P,j,1,0,t,t,t,1,j,I,I,I,I,I,I,"memw(Ru<<#u2+#U6)=Nt.new"
+1,0,1,0,1,1,0,1,1,0,1,x,x,x,x,x,P,P,u,1,0,t,t,t,0,-,-,-,-,-,-,-,"memw(Rx++Mu)=Nt.new"
+1,0,1,0,1,1,1,1,1,0,1,x,x,x,x,x,P,P,u,1,0,t,t,t,0,-,-,-,-,-,-,-,"memw(Rx++Mu:brev)=Nt.new"
+0,0,1,1,0,1,0,0,1,0,1,s,s,s,s,s,P,P,j,u,u,u,u,u,j,v,v,1,0,t,t,t,"if (Pv)memw(Rs+Ru<<#u2)=Nt.new"
+0,0,1,1,0,1,0,1,1,0,1,s,s,s,s,s,P,P,j,u,u,u,u,u,j,v,v,1,0,t,t,t,"if (!Pv)memw(Rs+Ru<<#u2)=Nt.new"
+0,0,1,1,0,1,1,0,1,0,1,s,s,s,s,s,P,P,j,u,u,u,u,u,j,v,v,1,0,t,t,t,"if (Pv.new)memw(Rs+Ru<<#u2)=Nt.new"
+0,0,1,1,0,1,1,1,1,0,1,s,s,s,s,s,P,P,j,u,u,u,u,u,j,v,v,1,0,t,t,t,"if (!Pv.new)memw(Rs+Ru<<#u2)=Nt.new"
+0,1,0,0,0,0,0,0,1,0,1,s,s,s,s,s,P,P,j,1,0,t,t,t,j,j,j,j,j,0,v,v,"if (Pv)memw(Rs+#u6:2)=Nt.new"
+0,1,0,0,0,0,1,0,1,0,1,s,s,s,s,s,P,P,j,1,0,t,t,t,j,j,j,j,j,0,v,v,"if (Pv.new)memw(Rs+#u6:2)=Nt.new"
+0,1,0,0,0,1,0,0,1,0,1,s,s,s,s,s,P,P,j,1,0,t,t,t,j,j,j,j,j,0,v,v,"if (!Pv)memw(Rs+#u6:2)=Nt.new"
+0,1,0,0,0,1,1,0,1,0,1,s,s,s,s,s,P,P,j,1,0,t,t,t,j,j,j,j,j,0,v,v,"if (!Pv.new)memw(Rs+#u6:2)=Nt.new"
+1,0,1,0,1,0,1,1,1,0,1,x,x,x,x,x,P,P,1,1,0,t,t,t,0,j,j,j,j,0,v,v,"if (Pv)memw(Rx++#s4:2)=Nt.new"
+1,0,1,0,1,0,1,1,1,0,1,x,x,x,x,x,P,P,1,1,0,t,t,t,0,j,j,j,j,1,v,v,"if (!Pv)memw(Rx++#s4:2)=Nt.new"
+1,0,1,0,1,0,1,1,1,0,1,x,x,x,x,x,P,P,1,1,0,t,t,t,1,j,j,j,j,0,v,v,"if (Pv.new)memw(Rx++#s4:2)=Nt.new"
+1,0,1,0,1,0,1,1,1,0,1,x,x,x,x,x,P,P,1,1,0,t,t,t,1,j,j,j,j,1,v,v,"if (!Pv.new)memw(Rx++#s4:2)=Nt.new"
+1,0,1,0,1,1,1,1,1,0,1,-,-,-,j,j,P,P,0,1,0,t,t,t,1,j,j,j,j,0,v,v,"if (Pv) memw(#u6)=Nt.new"
+1,0,1,0,1,1,1,1,1,0,1,-,-,-,j,j,P,P,0,1,0,t,t,t,1,j,j,j,j,1,v,v,"if (!Pv) memw(#u6)=Nt.new"
+1,0,1,0,1,1,1,1,1,0,1,-,-,-,j,j,P,P,1,1,0,t,t,t,1,j,j,j,j,0,v,v,"if (Pv.new)memw(#u6)=Nt.new"
+1,0,1,0,1,1,1,1,1,0,1,-,-,-,j,j,P,P,1,1,0,t,t,t,1,j,j,j,j,1,v,v,"if (!Pv.new)memw(#u6)=Nt.new"
+0,0,1,1,1,0,1,1,1,1,0,s,s,s,s,s,P,P,j,u,u,u,u,u,j,-,-,t,t,t,t,t,"memd(Rs+Ru<<#u2)=Rtt"
+0,1,0,0,1,j,j,0,1,1,0,j,j,j,j,j,P,P,j,t,t,t,t,t,j,j,j,j,j,j,j,j,"memd(gp+#u16:3)=Rtt"
+1,0,1,0,0,j,j,1,1,1,0,s,s,s,s,s,P,P,j,t,t,t,t,t,j,j,j,j,j,j,j,j,"memd(Rs+#s11:3)=Rtt"
+1,0,1,0,1,0,0,1,1,1,0,x,x,x,x,x,P,P,u,t,t,t,t,t,0,-,-,-,-,-,1,-,"memd(Rx++I:circ(Mu))=Rtt"
+1,0,1,0,1,0,0,1,1,1,0,x,x,x,x,x,P,P,u,t,t,t,t,t,0,j,j,j,j,-,0,-,"memd(Rx++#s4:3:circ(Mu))=Rtt"
+1,0,1,0,1,0,1,1,1,1,0,e,e,e,e,e,P,P,0,t,t,t,t,t,1,-,I,I,I,I,I,I,"memd(Re=#U6)=Rtt"
+1,0,1,0,1,0,1,1,1,1,0,x,x,x,x,x,P,P,0,t,t,t,t,t,0,j,j,j,j,-,0,-,"memd(Rx++#s4:3)=Rtt"
+1,0,1,0,1,1,0,1,1,1,0,u,u,u,u,u,P,P,j,t,t,t,t,t,1,j,I,I,I,I,I,I,"memd(Ru<<#u2+#U6)=Rtt"
+1,0,1,0,1,1,0,1,1,1,0,x,x,x,x,x,P,P,u,t,t,t,t,t,0,-,-,-,-,-,-,-,"memd(Rx++Mu)=Rtt"
+1,0,1,0,1,1,1,1,1,1,0,x,x,x,x,x,P,P,u,t,t,t,t,t,0,-,-,-,-,-,-,-,"memd(Rx++Mu:brev)=Rtt"
+0,0,1,1,0,1,0,0,1,1,0,s,s,s,s,s,P,P,j,u,u,u,u,u,j,v,v,t,t,t,t,t,"if (Pv)memd(Rs+Ru<<#u2)=Rtt"
+0,0,1,1,0,1,0,1,1,1,0,s,s,s,s,s,P,P,j,u,u,u,u,u,j,v,v,t,t,t,t,t,"if (!Pv)memd(Rs+Ru<<#u2)=Rtt"
+0,0,1,1,0,1,1,0,1,1,0,s,s,s,s,s,P,P,j,u,u,u,u,u,j,v,v,t,t,t,t,t,"if (Pv.new)memd(Rs+Ru<<#u2)=Rtt"
+0,0,1,1,0,1,1,1,1,1,0,s,s,s,s,s,P,P,j,u,u,u,u,u,j,v,v,t,t,t,t,t,"if (!Pv.new)memd(Rs+Ru<<#u2)=Rtt"
+0,1,0,0,0,0,0,0,1,1,0,s,s,s,s,s,P,P,j,t,t,t,t,t,j,j,j,j,j,0,v,v,"if (Pv)memd(Rs+#u6:3)=Rtt"
+0,1,0,0,0,0,1,0,1,1,0,s,s,s,s,s,P,P,j,t,t,t,t,t,j,j,j,j,j,0,v,v,"if (Pv.new)memd(Rs+#u6:3)=Rtt"
+0,1,0,0,0,1,0,0,1,1,0,s,s,s,s,s,P,P,j,t,t,t,t,t,j,j,j,j,j,0,v,v,"if (!Pv)memd(Rs+#u6:3)=Rtt"
+0,1,0,0,0,1,1,0,1,1,0,s,s,s,s,s,P,P,j,t,t,t,t,t,j,j,j,j,j,0,v,v,"if (!Pv.new)memd(Rs+#u6:3)=Rtt"
+1,0,1,0,1,0,1,1,1,1,0,x,x,x,x,x,P,P,1,t,t,t,t,t,0,j,j,j,j,0,v,v,"if (Pv)memd(Rx++#s4:3)=Rtt"
+1,0,1,0,1,0,1,1,1,1,0,x,x,x,x,x,P,P,1,t,t,t,t,t,0,j,j,j,j,1,v,v,"if (!Pv)memd(Rx++#s4:3)=Rtt"
+1,0,1,0,1,0,1,1,1,1,0,x,x,x,x,x,P,P,1,t,t,t,t,t,1,j,j,j,j,0,v,v,"if (Pv.new)memd(Rx++#s4:3)=Rtt"
+1,0,1,0,1,0,1,1,1,1,0,x,x,x,x,x,P,P,1,t,t,t,t,t,1,j,j,j,j,1,v,v,"if (!Pv.new)memd(Rx++#s4:3)=Rtt"
+1,0,1,0,1,1,1,1,1,1,0,-,-,-,j,j,P,P,0,t,t,t,t,t,1,j,j,j,j,0,v,v,"if (Pv) memd(#u6)=Rtt"
+1,0,1,0,1,1,1,1,1,1,0,-,-,-,j,j,P,P,0,t,t,t,t,t,1,j,j,j,j,1,v,v,"if (!Pv) memd(#u6)=Rtt"
+1,0,1,0,1,1,1,1,1,1,0,-,-,-,j,j,P,P,1,t,t,t,t,t,1,j,j,j,j,0,v,v,"if (Pv.new) memd(#u6)=Rtt"
+1,0,1,0,1,1,1,1,1,1,0,-,-,-,j,j,P,P,1,t,t,t,t,t,1,j,j,j,j,1,v,v,"if (!Pv.new) memd(#u6)=Rtt"
+0,0,1,1,1,0,1,1,0,0,0,s,s,s,s,s,P,P,j,u,u,u,u,u,j,-,-,t,t,t,t,t,"memb(Rs+Ru<<#u2)=Rt"
+0,0,1,1,1,1,0,-,-,0,0,s,s,s,s,s,P,P,I,j,j,j,j,j,j,I,I,I,I,I,I,I,"memb(Rs+#u6:0)=#S8"
+0,1,0,0,1,j,j,0,0,0,0,j,j,j,j,j,P,P,j,t,t,t,t,t,j,j,j,j,j,j,j,j,"memb(gp+#u16:0)=Rt"
+1,0,1,0,0,j,j,1,0,0,0,s,s,s,s,s,P,P,j,t,t,t,t,t,j,j,j,j,j,j,j,j,"memb(Rs+#s11:0)=Rt"
+1,0,1,0,1,0,0,1,0,0,0,x,x,x,x,x,P,P,u,t,t,t,t,t,0,-,-,-,-,-,1,-,"memb(Rx++I:circ(Mu))=Rt"
+1,0,1,0,1,0,0,1,0,0,0,x,x,x,x,x,P,P,u,t,t,t,t,t,0,j,j,j,j,-,0,-,"memb(Rx++#s4:0:circ(Mu))=Rt"
+1,0,1,0,1,0,1,1,0,0,0,e,e,e,e,e,P,P,0,t,t,t,t,t,1,-,I,I,I,I,I,I,"memb(Re=#U6)=Rt"
+1,0,1,0,1,0,1,1,0,0,0,x,x,x,x,x,P,P,0,t,t,t,t,t,0,j,j,j,j,-,0,-,"memb(Rx++#s4:0)=Rt"
+1,0,1,0,1,1,0,1,0,0,0,u,u,u,u,u,P,P,j,t,t,t,t,t,1,j,I,I,I,I,I,I,"memb(Ru<<#u2+#U6)=Rt"
+1,0,1,0,1,1,0,1,0,0,0,x,x,x,x,x,P,P,u,t,t,t,t,t,0,-,-,-,-,-,-,-,"memb(Rx++Mu)=Rt"
+1,0,1,0,1,1,1,1,0,0,0,x,x,x,x,x,P,P,u,t,t,t,t,t,0,-,-,-,-,-,-,-,"memb(Rx++Mu:brev)=Rt"
+0,0,1,1,0,1,0,0,0,0,0,s,s,s,s,s,P,P,j,u,u,u,u,u,j,v,v,t,t,t,t,t,"if (Pv)memb(Rs+Ru<<#u2)=Rt"
+0,0,1,1,0,1,0,1,0,0,0,s,s,s,s,s,P,P,j,u,u,u,u,u,j,v,v,t,t,t,t,t,"if (!Pv)memb(Rs+Ru<<#u2)=Rt"
+0,0,1,1,0,1,1,0,0,0,0,s,s,s,s,s,P,P,j,u,u,u,u,u,j,v,v,t,t,t,t,t,"if (Pv.new)memb(Rs+Ru<<#u2)=Rt"
+0,0,1,1,0,1,1,1,0,0,0,s,s,s,s,s,P,P,j,u,u,u,u,u,j,v,v,t,t,t,t,t,"if (!Pv.new)memb(Rs+Ru<<#u2)=Rt"
+0,0,1,1,1,0,0,0,0,0,0,s,s,s,s,s,P,P,I,j,j,j,j,j,j,v,v,I,I,I,I,I,"if (Pv)memb(Rs+#u6:0)=#S6"
+0,0,1,1,1,0,0,0,1,0,0,s,s,s,s,s,P,P,I,j,j,j,j,j,j,v,v,I,I,I,I,I,"if (!Pv)memb(Rs+#u6:0)=#S6"
+0,0,1,1,1,0,0,1,0,0,0,s,s,s,s,s,P,P,I,j,j,j,j,j,j,v,v,I,I,I,I,I,"if (Pv.new)memb(Rs+#u6:0)=#S6"
+0,0,1,1,1,0,0,1,1,0,0,s,s,s,s,s,P,P,I,j,j,j,j,j,j,v,v,I,I,I,I,I,"if (!Pv.new)memb(Rs+#u6:0)=#S6"
+0,1,0,0,0,0,0,0,0,0,0,s,s,s,s,s,P,P,j,t,t,t,t,t,j,j,j,j,j,0,v,v,"if (Pv) memb(Rs+#u6:0)=Rt"
+0,1,0,0,0,0,1,0,0,0,0,s,s,s,s,s,P,P,j,t,t,t,t,t,j,j,j,j,j,0,v,v,"if (Pv.new)memb(Rs+#u6:0)=Rt"
+0,1,0,0,0,1,0,0,0,0,0,s,s,s,s,s,P,P,j,t,t,t,t,t,j,j,j,j,j,0,v,v,"if (!Pv)memb(Rs+#u6:0)=Rt"
+0,1,0,0,0,1,1,0,0,0,0,s,s,s,s,s,P,P,j,t,t,t,t,t,j,j,j,j,j,0,v,v,"if (!Pv.new)memb(Rs+#u6:0)=Rt"
+1,0,1,0,1,0,1,1,0,0,0,x,x,x,x,x,P,P,1,t,t,t,t,t,0,j,j,j,j,0,v,v,"if (Pv)memb(Rx++#s4:0)=Rt"
+1,0,1,0,1,0,1,1,0,0,0,x,x,x,x,x,P,P,1,t,t,t,t,t,0,j,j,j,j,1,v,v,"if (!Pv)memb(Rx++#s4:0)=Rt"
+1,0,1,0,1,0,1,1,0,0,0,x,x,x,x,x,P,P,1,t,t,t,t,t,1,j,j,j,j,0,v,v,"if (Pv.new)memb(Rx++#s4:0)=Rt"
+1,0,1,0,1,0,1,1,0,0,0,x,x,x,x,x,P,P,1,t,t,t,t,t,1,j,j,j,j,1,v,v,"if (!Pv.new)memb(Rx++#s4:0)=Rt"
+1,0,1,0,1,1,1,1,0,0,0,-,-,-,j,j,P,P,0,t,t,t,t,t,1,j,j,j,j,0,v,v,"if (Pv) memb(#u6)=Rt"
+1,0,1,0,1,1,1,1,0,0,0,-,-,-,j,j,P,P,0,t,t,t,t,t,1,j,j,j,j,1,v,v,"if (!Pv) memb(#u6)=Rt"
+1,0,1,0,1,1,1,1,0,0,0,-,-,-,j,j,P,P,1,t,t,t,t,t,1,j,j,j,j,0,v,v,"if (Pv.new) memb(#u6)=Rt"
+1,0,1,0,1,1,1,1,0,0,0,-,-,-,j,j,P,P,1,t,t,t,t,t,1,j,j,j,j,1,v,v,"if (!Pv.new) memb(#u6)=Rt"
+0,0,1,1,1,0,1,1,0,1,0,s,s,s,s,s,P,P,j,u,u,u,u,u,j,-,-,t,t,t,t,t,"memh(Rs+Ru<<#u2)=Rt"
+0,0,1,1,1,0,1,1,0,1,1,s,s,s,s,s,P,P,j,u,u,u,u,u,j,-,-,t,t,t,t,t,"memh(Rs+Ru<<#u2)=Rt.H"
+0,0,1,1,1,1,0,-,-,0,1,s,s,s,s,s,P,P,I,j,j,j,j,j,j,I,I,I,I,I,I,I,"memh(Rs+#u6:1)=#S8"
+0,1,0,0,1,j,j,0,0,1,0,j,j,j,j,j,P,P,j,t,t,t,t,t,j,j,j,j,j,j,j,j,"memh(gp+#u16:1)=Rt"
+0,1,0,0,1,j,j,0,0,1,1,j,j,j,j,j,P,P,j,t,t,t,t,t,j,j,j,j,j,j,j,j,"memh(gp+#u16:1)=Rt.H"
+1,0,1,0,0,j,j,1,0,1,0,s,s,s,s,s,P,P,j,t,t,t,t,t,j,j,j,j,j,j,j,j,"memh(Rs+#s11:1)=Rt"
+1,0,1,0,0,j,j,1,0,1,1,s,s,s,s,s,P,P,j,t,t,t,t,t,j,j,j,j,j,j,j,j,"memh(Rs+#s11:1)=Rt.H"
+1,0,1,0,1,0,0,1,0,1,0,x,x,x,x,x,P,P,u,t,t,t,t,t,0,-,-,-,-,-,1,-,"memh(Rx++I:circ(Mu))=Rt"
+1,0,1,0,1,0,0,1,0,1,0,x,x,x,x,x,P,P,u,t,t,t,t,t,0,j,j,j,j,-,0,-,"memh(Rx++#s4:1:circ(Mu))=Rt"
+1,0,1,0,1,0,0,1,0,1,1,x,x,x,x,x,P,P,u,t,t,t,t,t,0,-,-,-,-,-,1,-,"memh(Rx++I:circ(Mu))=Rt.H"
+1,0,1,0,1,0,0,1,0,1,1,x,x,x,x,x,P,P,u,t,t,t,t,t,0,j,j,j,j,-,0,-,"memh(Rx++#s4:1:circ(Mu))=Rt.H"
+1,0,1,0,1,0,1,1,0,1,0,e,e,e,e,e,P,P,0,t,t,t,t,t,1,-,I,I,I,I,I,I,"memh(Re=#U6)=Rt"
+1,0,1,0,1,0,1,1,0,1,0,x,x,x,x,x,P,P,0,t,t,t,t,t,0,j,j,j,j,-,0,-,"memh(Rx++#s4:1)=Rt"
+1,0,1,0,1,0,1,1,0,1,1,e,e,e,e,e,P,P,0,t,t,t,t,t,1,-,I,I,I,I,I,I,"memh(Re=#U6)=Rt.H"
+1,0,1,0,1,0,1,1,0,1,1,x,x,x,x,x,P,P,0,t,t,t,t,t,0,j,j,j,j,-,0,-,"memh(Rx++#s4:1)=Rt.H"
+1,0,1,0,1,1,0,1,0,1,0,u,u,u,u,u,P,P,j,t,t,t,t,t,1,j,I,I,I,I,I,I,"memh(Ru<<#u2+#U6)=Rt"
+1,0,1,0,1,1,0,1,0,1,0,x,x,x,x,x,P,P,u,t,t,t,t,t,0,-,-,-,-,-,-,-,"memh(Rx++Mu)=Rt"
+1,0,1,0,1,1,0,1,0,1,1,u,u,u,u,u,P,P,j,t,t,t,t,t,1,j,I,I,I,I,I,I,"memh(Ru<<#u2+#U6)=Rt.H"
+1,0,1,0,1,1,0,1,0,1,1,x,x,x,x,x,P,P,u,t,t,t,t,t,0,-,-,-,-,-,-,-,"memh(Rx++Mu)=Rt.H"
+1,0,1,0,1,1,1,1,0,1,0,x,x,x,x,x,P,P,u,t,t,t,t,t,0,-,-,-,-,-,-,-,"memh(Rx++Mu:brev)=Rt"
+1,0,1,0,1,1,1,1,0,1,1,x,x,x,x,x,P,P,u,t,t,t,t,t,0,-,-,-,-,-,-,-,"memh(Rx++Mu:brev)=Rt.H"
+0,0,1,1,0,1,0,0,0,1,0,s,s,s,s,s,P,P,j,u,u,u,u,u,j,v,v,t,t,t,t,t,"if (Pv)memh(Rs+Ru<<#u2)=Rt"
+0,0,1,1,0,1,0,0,0,1,1,s,s,s,s,s,P,P,j,u,u,u,u,u,j,v,v,t,t,t,t,t,"if (Pv)memh(Rs+Ru<<#u2)=Rt.H"
+0,0,1,1,0,1,0,1,0,1,0,s,s,s,s,s,P,P,j,u,u,u,u,u,j,v,v,t,t,t,t,t,"if (!Pv)memh(Rs+Ru<<#u2)=Rt"
+0,0,1,1,0,1,0,1,0,1,1,s,s,s,s,s,P,P,j,u,u,u,u,u,j,v,v,t,t,t,t,t,"if (!Pv)memh(Rs+Ru<<#u2)=Rt.H"
+0,0,1,1,0,1,1,0,0,1,0,s,s,s,s,s,P,P,j,u,u,u,u,u,j,v,v,t,t,t,t,t,"if (Pv.new)memh(Rs+Ru<<#u2)=Rt"
+0,0,1,1,0,1,1,0,0,1,1,s,s,s,s,s,P,P,j,u,u,u,u,u,j,v,v,t,t,t,t,t,"if (Pv.new)memh(Rs+Ru<<#u2)=Rt.H"
+0,0,1,1,0,1,1,1,0,1,0,s,s,s,s,s,P,P,j,u,u,u,u,u,j,v,v,t,t,t,t,t,"if (!Pv.new)memh(Rs+Ru<<#u2)=Rt"
+0,0,1,1,0,1,1,1,0,1,1,s,s,s,s,s,P,P,j,u,u,u,u,u,j,v,v,t,t,t,t,t,"if (!Pv.new)memh(Rs+Ru<<#u2)=Rt.H"
+0,0,1,1,1,0,0,0,0,0,1,s,s,s,s,s,P,P,I,j,j,j,j,j,j,v,v,I,I,I,I,I,"if (Pv)memh(Rs+#u6:1)=#S6"
+0,0,1,1,1,0,0,0,1,0,1,s,s,s,s,s,P,P,I,j,j,j,j,j,j,v,v,I,I,I,I,I,"if (!Pv)memh(Rs+#u6:1)=#S6"
+0,0,1,1,1,0,0,1,0,0,1,s,s,s,s,s,P,P,I,j,j,j,j,j,j,v,v,I,I,I,I,I,"if (Pv.new)memh(Rs+#u6:1)=#S6"
+0,0,1,1,1,0,0,1,1,0,1,s,s,s,s,s,P,P,I,j,j,j,j,j,j,v,v,I,I,I,I,I,"if (!Pv.new)memh(Rs+#u6:1)=#S6"
+0,1,0,0,0,0,0,0,0,1,0,s,s,s,s,s,P,P,j,t,t,t,t,t,j,j,j,j,j,0,v,v,"if (Pv) memh(Rs+#u6:1)=Rt"
+0,1,0,0,0,0,0,0,0,1,1,s,s,s,s,s,P,P,j,t,t,t,t,t,j,j,j,j,j,0,v,v,"if (Pv)memh(Rs+#u6:1)=Rt.H"
+0,1,0,0,0,0,1,0,0,1,0,s,s,s,s,s,P,P,j,t,t,t,t,t,j,j,j,j,j,0,v,v,"if (Pv.new)memh(Rs+#u6:1)=Rt"
+0,1,0,0,0,0,1,0,0,1,1,s,s,s,s,s,P,P,j,t,t,t,t,t,j,j,j,j,j,0,v,v,"if (Pv.new)memh(Rs+#u6:1)=Rt.H"
+0,1,0,0,0,1,0,0,0,1,0,s,s,s,s,s,P,P,j,t,t,t,t,t,j,j,j,j,j,0,v,v,"if (!Pv)memh(Rs+#u6:1)=Rt"
+0,1,0,0,0,1,0,0,0,1,1,s,s,s,s,s,P,P,j,t,t,t,t,t,j,j,j,j,j,0,v,v,"if (!Pv)memh(Rs+#u6:1)=Rt.H"
+0,1,0,0,0,1,1,0,0,1,0,s,s,s,s,s,P,P,j,t,t,t,t,t,j,j,j,j,j,0,v,v,"if (!Pv.new)memh(Rs+#u6:1)=Rt"
+0,1,0,0,0,1,1,0,0,1,1,s,s,s,s,s,P,P,j,t,t,t,t,t,j,j,j,j,j,0,v,v,"if (!Pv.new)memh(Rs+#u6:1)=Rt.H"
+1,0,1,0,1,0,1,1,0,1,0,x,x,x,x,x,P,P,1,t,t,t,t,t,0,j,j,j,j,0,v,v,"if (Pv)memh(Rx++#s4:1)=Rt"
+1,0,1,0,1,0,1,1,0,1,0,x,x,x,x,x,P,P,1,t,t,t,t,t,0,j,j,j,j,1,v,v,"if (!Pv)memh(Rx++#s4:1)=Rt"
+1,0,1,0,1,0,1,1,0,1,0,x,x,x,x,x,P,P,1,t,t,t,t,t,1,j,j,j,j,0,v,v,"if (Pv.new)memh(Rx++#s4:1)=Rt"
+1,0,1,0,1,0,1,1,0,1,0,x,x,x,x,x,P,P,1,t,t,t,t,t,1,j,j,j,j,1,v,v,"if (!Pv.new)memh(Rx++#s4:1)=Rt"
+1,0,1,0,1,0,1,1,0,1,1,x,x,x,x,x,P,P,1,t,t,t,t,t,0,j,j,j,j,0,v,v,"if (Pv)memh(Rx++#s4:1)=Rt.H"
+1,0,1,0,1,0,1,1,0,1,1,x,x,x,x,x,P,P,1,t,t,t,t,t,0,j,j,j,j,1,v,v,"if (!Pv)memh(Rx++#s4:1)=Rt.H"
+1,0,1,0,1,0,1,1,0,1,1,x,x,x,x,x,P,P,1,t,t,t,t,t,1,j,j,j,j,0,v,v,"if (Pv.new)memh(Rx++#s4:1)=Rt.H"
+1,0,1,0,1,0,1,1,0,1,1,x,x,x,x,x,P,P,1,t,t,t,t,t,1,j,j,j,j,1,v,v,"if (!Pv.new)memh(Rx++#s4:1)=Rt.H"
+1,0,1,0,1,1,1,1,0,1,0,-,-,-,j,j,P,P,0,t,t,t,t,t,1,j,j,j,j,0,v,v,"if (Pv) memh(#u6)=Rt"
+1,0,1,0,1,1,1,1,0,1,0,-,-,-,j,j,P,P,0,t,t,t,t,t,1,j,j,j,j,1,v,v,"if (!Pv) memh(#u6)=Rt"
+1,0,1,0,1,1,1,1,0,1,0,-,-,-,j,j,P,P,1,t,t,t,t,t,1,j,j,j,j,0,v,v,"if (Pv.new) memh(#u6)=Rt"
+1,0,1,0,1,1,1,1,0,1,0,-,-,-,j,j,P,P,1,t,t,t,t,t,1,j,j,j,j,1,v,v,"if (!Pv.new) memh(#u6)=Rt"
+1,0,1,0,1,1,1,1,0,1,1,-,-,-,j,j,P,P,0,t,t,t,t,t,1,j,j,j,j,0,v,v,"if (Pv) memh(#u6)=Rt.H"
+1,0,1,0,1,1,1,1,0,1,1,-,-,-,j,j,P,P,0,t,t,t,t,t,1,j,j,j,j,1,v,v,"if (!Pv) memh(#u6)=Rt.H"
+1,0,1,0,1,1,1,1,0,1,1,-,-,-,j,j,P,P,1,t,t,t,t,t,1,j,j,j,j,0,v,v,"if (Pv.new)memh(#u6)=Rt.H"
+1,0,1,0,1,1,1,1,0,1,1,-,-,-,j,j,P,P,1,t,t,t,t,t,1,j,j,j,j,1,v,v,"if (!Pv.new)memh(#u6)=Rt.H"
+0,0,1,1,1,0,1,1,1,0,0,s,s,s,s,s,P,P,j,u,u,u,u,u,j,-,-,t,t,t,t,t,"memw(Rs+Ru<<#u2)=Rt"
+0,0,1,1,1,1,0,-,-,1,0,s,s,s,s,s,P,P,I,j,j,j,j,j,j,I,I,I,I,I,I,I,"memw(Rs+#u6:2)=#S8"
+0,1,0,0,1,j,j,0,1,0,0,j,j,j,j,j,P,P,j,t,t,t,t,t,j,j,j,j,j,j,j,j,"memw(gp+#u16:2)=Rt"
+1,0,1,0,0,j,j,1,1,0,0,s,s,s,s,s,P,P,j,t,t,t,t,t,j,j,j,j,j,j,j,j,"memw(Rs+#s11:2)=Rt"
+1,0,1,0,1,0,0,1,1,0,0,x,x,x,x,x,P,P,u,t,t,t,t,t,0,-,-,-,-,-,1,-,"memw(Rx++I:circ(Mu))=Rt"
+1,0,1,0,1,0,0,1,1,0,0,x,x,x,x,x,P,P,u,t,t,t,t,t,0,j,j,j,j,-,0,-,"memw(Rx++#s4:2:circ(Mu))=Rt"
+1,0,1,0,1,0,1,1,1,0,0,e,e,e,e,e,P,P,0,t,t,t,t,t,1,-,I,I,I,I,I,I,"memw(Re=#U6)=Rt"
+1,0,1,0,1,0,1,1,1,0,0,x,x,x,x,x,P,P,0,t,t,t,t,t,0,j,j,j,j,-,0,-,"memw(Rx++#s4:2)=Rt"
+1,0,1,0,1,1,0,1,1,0,0,u,u,u,u,u,P,P,j,t,t,t,t,t,1,j,I,I,I,I,I,I,"memw(Ru<<#u2+#U6)=Rt"
+1,0,1,0,1,1,0,1,1,0,0,x,x,x,x,x,P,P,u,t,t,t,t,t,0,-,-,-,-,-,-,-,"memw(Rx++Mu)=Rt"
+1,0,1,0,1,1,1,1,1,0,0,x,x,x,x,x,P,P,u,t,t,t,t,t,0,-,-,-,-,-,-,-,"memw(Rx++Mu:brev)=Rt"
+0,0,1,1,0,1,0,0,1,0,0,s,s,s,s,s,P,P,j,u,u,u,u,u,j,v,v,t,t,t,t,t,"if (Pv)memw(Rs+Ru<<#u2)=Rt"
+0,0,1,1,0,1,0,1,1,0,0,s,s,s,s,s,P,P,j,u,u,u,u,u,j,v,v,t,t,t,t,t,"if (!Pv)memw(Rs+Ru<<#u2)=Rt"
+0,0,1,1,0,1,1,0,1,0,0,s,s,s,s,s,P,P,j,u,u,u,u,u,j,v,v,t,t,t,t,t,"if (Pv.new)memw(Rs+Ru<<#u2)=Rt"
+0,0,1,1,0,1,1,1,1,0,0,s,s,s,s,s,P,P,j,u,u,u,u,u,j,v,v,t,t,t,t,t,"if (!Pv.new)memw(Rs+Ru<<#u2)=Rt"
+0,0,1,1,1,0,0,0,0,1,0,s,s,s,s,s,P,P,I,j,j,j,j,j,j,v,v,I,I,I,I,I,"if (Pv)memw(Rs+#u6:2)=#S6"
+0,0,1,1,1,0,0,0,1,1,0,s,s,s,s,s,P,P,I,j,j,j,j,j,j,v,v,I,I,I,I,I,"if (!Pv)memw(Rs+#u6:2)=#S6"
+0,0,1,1,1,0,0,1,0,1,0,s,s,s,s,s,P,P,I,j,j,j,j,j,j,v,v,I,I,I,I,I,"if (Pv.new)memw(Rs+#u6:2)=#S6"
+0,0,1,1,1,0,0,1,1,1,0,s,s,s,s,s,P,P,I,j,j,j,j,j,j,v,v,I,I,I,I,I,"if (!Pv.new)memw(Rs+#u6:2)=#S6"
+0,1,0,0,0,0,0,0,1,0,0,s,s,s,s,s,P,P,j,t,t,t,t,t,j,j,j,j,j,0,v,v,"if (Pv)memw(Rs+#u6:2)=Rt"
+0,1,0,0,0,0,1,0,1,0,0,s,s,s,s,s,P,P,j,t,t,t,t,t,j,j,j,j,j,0,v,v,"if (Pv.new)memw(Rs+#u6:2)=Rt"
+0,1,0,0,0,1,0,0,1,0,0,s,s,s,s,s,P,P,j,t,t,t,t,t,j,j,j,j,j,0,v,v,"if (!Pv)memw(Rs+#u6:2)=Rt"
+0,1,0,0,0,1,1,0,1,0,0,s,s,s,s,s,P,P,j,t,t,t,t,t,j,j,j,j,j,0,v,v,"if (!Pv.new)memw(Rs+#u6:2)=Rt"
+1,0,1,0,1,0,1,1,1,0,0,x,x,x,x,x,P,P,1,t,t,t,t,t,0,j,j,j,j,0,v,v,"if (Pv)memw(Rx++#s4:2)=Rt"
+1,0,1,0,1,0,1,1,1,0,0,x,x,x,x,x,P,P,1,t,t,t,t,t,0,j,j,j,j,1,v,v,"if (!Pv)memw(Rx++#s4:2)=Rt"
+1,0,1,0,1,0,1,1,1,0,0,x,x,x,x,x,P,P,1,t,t,t,t,t,1,j,j,j,j,0,v,v,"if (Pv.new)memw(Rx++#s4:2)=Rt"
+1,0,1,0,1,0,1,1,1,0,0,x,x,x,x,x,P,P,1,t,t,t,t,t,1,j,j,j,j,1,v,v,"if (!Pv.new)memw(Rx++#s4:2)=Rt"
+1,0,1,0,1,1,1,1,1,0,0,-,-,-,j,j,P,P,0,t,t,t,t,t,1,j,j,j,j,0,v,v,"if (Pv) memw(#u6)=Rt"
+1,0,1,0,1,1,1,1,1,0,0,-,-,-,j,j,P,P,0,t,t,t,t,t,1,j,j,j,j,1,v,v,"if (!Pv) memw(#u6)=Rt"
+1,0,1,0,1,1,1,1,1,0,0,-,-,-,j,j,P,P,1,t,t,t,t,t,1,j,j,j,j,0,v,v,"if (Pv.new) memw(#u6)=Rt"
+1,0,1,0,1,1,1,1,1,0,0,-,-,-,j,j,P,P,1,t,t,t,t,t,1,j,j,j,j,1,v,v,"if (!Pv.new) memw(#u6)=Rt"
+1,0,1,0,0,0,0,0,1,0,0,1,1,1,0,1,P,P,0,0,0,j,j,j,j,j,j,j,j,j,j,j,"allocframe(#u11:3)"
+0,1,1,0,0,0,1,0,0,0,0,s,s,s,s,s,P,P,-,-,-,-,-,-,-,-,-,d,d,d,d,d,"Gd=Rs"
+0,1,1,0,0,0,1,1,0,0,0,s,s,s,s,s,P,P,-,-,-,-,-,-,-,-,-,d,d,d,d,d,"Gdd=Rss"
+0,1,1,0,1,0,0,0,0,0,1,s,s,s,s,s,P,P,-,-,-,-,-,-,-,-,-,d,d,d,d,d,"Rdd=Gss"
+0,1,1,0,1,0,1,0,0,0,1,s,s,s,s,s,P,P,-,-,-,-,-,-,-,-,-,d,d,d,d,d,"Rd=Gs"
+0,1,1,0,0,1,0,0,0,0,0,s,s,s,s,s,P,P,-,-,-,-,-,-,0,1,1,-,-,-,-,-,"ciad(Rs)"
+0,1,1,0,0,1,0,1,0,0,0,x,x,x,x,x,P,P,-,-,-,-,-,-,-,-,-,-,-,-,-,-,"crswap(Rx,sgp0)"
+0,1,1,0,0,1,0,1,0,0,1,x,x,x,x,x,P,P,-,-,-,-,-,-,-,-,-,-,-,-,-,-,"crswap(Rx,sgp1)"
+0,1,1,0,1,1,0,1,1,0,-,x,x,x,x,x,P,P,-,-,-,-,-,-,-,-,-,0,0,0,0,0,"crswap(Rxx,sgp1:0)"
+0,1,1,0,0,1,0,0,0,0,0,s,s,s,s,s,P,P,-,-,-,-,-,-,0,0,1,-,-,-,-,-,"cswi(Rs)"
+1,0,1,0,0,0,1,0,0,0,0,-,-,-,-,-,P,P,-,-,-,-,-,-,-,-,-,-,-,-,-,-,"dckill"
+1,0,1,0,0,0,1,0,0,0,1,s,s,s,s,s,P,P,-,-,-,-,-,-,-,-,-,-,-,-,-,-,"dccleanidx(Rs)"
+1,0,1,0,0,0,1,0,0,1,0,s,s,s,s,s,P,P,-,-,-,-,-,-,-,-,-,-,-,-,-,-,"dcinvidx(Rs)"
+1,0,1,0,0,0,1,0,0,1,1,s,s,s,s,s,P,P,-,-,-,-,-,-,-,-,-,-,-,-,-,-,"dccleaninvidx(Rs)"
+1,0,1,0,0,1,0,0,0,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,-,-,-,-,-,"dctagw(Rs,Rt)"
+1,0,1,0,0,1,0,0,0,0,1,s,s,s,s,s,P,P,-,-,-,-,-,-,-,-,-,d,d,d,d,d,"Rd=dctagr(Rs)"
+0,1,1,0,0,1,1,0,0,0,0,s,s,s,s,s,P,P,-,-,-,-,-,-,-,-,-,d,d,d,d,d,"Rd=getimask(Rs)"
+0,1,1,0,1,1,0,0,0,0,1,-,-,-,-,-,P,P,-,-,-,-,-,-,0,0,1,-,-,-,-,-,"tlblock"
+0,1,1,0,1,1,0,0,0,0,1,-,-,-,-,-,P,P,-,-,-,-,-,-,0,1,1,-,-,-,-,-,"k0lock"
+0,1,1,0,1,1,0,0,0,0,1,-,-,-,-,-,P,P,-,-,-,-,-,-,0,1,0,-,-,-,-,-,"tlbunlock"
+0,1,1,0,1,1,0,0,0,0,1,-,-,-,-,-,P,P,-,-,-,-,-,-,1,0,0,-,-,-,-,-,"k0unlock"
+0,1,1,0,0,1,1,0,0,1,1,s,s,s,s,s,P,P,-,-,-,-,-,-,-,-,-,d,d,d,d,d,"Rd=iassignr(Rs)"
+0,1,1,0,0,1,0,0,0,0,0,s,s,s,s,s,P,P,-,-,-,-,-,-,0,1,0,-,-,-,-,-,"iassignw(Rs)"
+0,1,0,1,0,1,0,1,1,0,1,s,s,s,s,s,P,P,-,-,-,-,-,-,-,-,-,d,d,d,d,d,"Rd=icdatar(Rs)"
+0,1,0,1,0,1,0,1,1,1,1,s,s,s,s,s,P,P,-,-,-,-,-,-,-,-,-,d,d,d,d,d,"Rd=ictagr(Rs)"
+0,1,0,1,0,1,1,0,1,1,0,s,s,s,s,s,P,P,0,0,1,-,-,-,-,-,-,-,-,-,-,-,"icinvidx(Rs)"
+0,1,0,1,0,1,0,1,1,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,-,-,-,-,-,"ictagw(Rs,Rt)"
+0,1,0,1,0,1,1,0,1,1,0,-,-,-,-,-,P,P,0,1,0,-,-,-,-,-,-,-,-,-,-,-,"ickill"
+1,0,1,0,0,1,1,0,0,0,1,s,s,s,s,s,P,P,-,-,-,-,-,-,-,-,-,-,-,-,-,-,"l2cleanidx(Rs)"
+1,0,1,0,0,1,1,0,0,1,0,s,s,s,s,s,P,P,-,-,-,-,-,-,-,-,-,-,-,-,-,-,"l2invidx(Rs)"
+1,0,1,0,1,0,0,0,0,1,1,s,s,s,s,s,P,P,-,-,-,-,-,-,-,-,-,-,-,-,-,-,"l2cleaninvidx(Rs)"
+1,0,1,0,0,1,1,0,1,0,1,-,-,-,-,-,P,P,-,t,t,t,t,t,-,-,-,-,-,-,-,-,"l2gclean(Rtt)"
+1,0,1,0,0,1,1,0,1,1,0,-,-,-,-,-,P,P,-,t,t,t,t,t,-,-,-,-,-,-,-,-,"l2gcleaninv(Rtt)"
+1,0,1,0,1,0,0,0,0,0,1,-,-,-,-,-,P,P,-,0,0,0,-,-,-,-,-,-,-,-,-,-,"l2kill"
+1,0,1,0,1,0,0,0,0,0,1,-,-,-,-,-,P,P,-,0,1,0,-,-,-,-,-,-,-,-,-,-,"l2gunlock"
+1,0,1,0,1,0,0,0,0,0,1,-,-,-,-,-,P,P,-,1,0,0,-,-,-,-,-,-,-,-,-,-,"l2gclean"
+1,0,1,0,1,0,0,0,0,0,1,-,-,-,-,-,P,P,-,1,1,0,-,-,-,-,-,-,-,-,-,-,"l2gcleaninv"
+1,0,1,0,0,0,0,0,1,1,1,s,s,s,s,s,P,P,1,-,-,-,-,-,-,-,-,-,-,-,d,d,"Pd=l2locka(Rs)"
+1,0,1,0,0,1,1,0,0,1,1,s,s,s,s,s,P,P,-,-,-,-,-,-,-,-,-,-,-,-,-,-,"l2unlocka(Rs)"
+1,0,1,0,0,1,0,0,0,1,0,s,s,s,s,s,P,P,0,t,t,t,t,t,-,-,-,-,-,-,-,-,"l2tagw(Rs,Rt)"
+1,0,1,0,0,1,0,0,0,1,1,s,s,s,s,s,P,P,-,-,-,-,-,-,-,-,-,d,d,d,d,d,"Rd=l2tagr(Rs)"
+1,0,0,1,0,0,1,0,0,0,0,s,s,s,s,s,P,P,1,t,t,t,t,t,-,-,0,d,d,d,d,d,"Rd=memw_phys(Rs,Rt)"
+0,1,1,0,0,1,0,0,0,1,1,s,s,s,s,s,P,P,-,-,-,-,-,-,0,1,0,-,-,-,-,-,"nmi(Rs)"
+0,1,1,0,0,1,0,0,0,1,0,s,s,s,s,s,P,P,-,-,-,-,-,-,0,0,1,-,-,-,-,-,"resume(Rs)"
+0,1,0,1,0,1,1,1,1,1,1,-,-,-,-,-,P,P,0,0,-,-,-,-,0,0,0,-,-,-,-,-,"rte"
+0,1,0,1,0,1,1,1,1,1,1,-,-,-,-,-,P,P,0,1,-,-,-,-,0,0,0,-,-,-,-,-,"rteunlock"
+0,1,1,0,0,1,0,0,1,0,0,s,s,s,s,s,P,P,-,-,-,-,t,t,0,0,0,-,-,-,-,-,"setimask(Pt,Rs)"
+0,1,1,0,0,1,0,0,1,0,0,s,s,s,s,s,P,P,-,-,-,-,-,-,0,1,1,-,-,-,-,-,"siad(Rs)"
+0,1,1,0,0,1,0,0,0,1,1,s,s,s,s,s,P,P,-,-,-,-,-,-,0,0,1,-,-,-,-,-,"start(Rs)"
+0,1,1,0,0,1,0,0,0,1,1,s,s,s,s,s,P,P,-,-,-,-,-,-,0,0,0,-,-,-,-,-,"stop(Rs)"
+0,1,1,0,0,1,0,0,0,0,0,s,s,s,s,s,P,P,-,-,-,-,-,-,0,0,0,-,-,-,-,-,"swi(Rs)"
+0,1,1,0,1,1,0,0,0,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,-,-,-,-,-,-,-,-,"tlbw(Rss,Rt)"
+0,1,1,0,1,1,0,0,0,1,0,s,s,s,s,s,P,P,-,-,-,-,-,-,-,-,-,d,d,d,d,d,"Rdd=tlbr(Rs)"
+0,1,1,0,1,1,0,0,1,0,0,s,s,s,s,s,P,P,-,-,-,-,-,-,-,-,-,d,d,d,d,d,"Rd=tlbp(Rs)"
+0,1,1,0,1,1,0,0,1,0,1,s,s,s,s,s,P,P,-,-,-,-,-,-,-,-,-,-,-,-,-,-,"tlbinvasid(Rs)"
+0,1,1,0,1,1,0,0,1,1,0,s,s,s,s,s,P,P,0,t,t,t,t,t,-,-,-,d,d,d,d,d,"Rd=ctlbw(Rss,Rt)"
+0,1,1,0,1,1,0,0,1,1,1,s,s,s,s,s,P,P,-,-,-,-,-,-,-,-,-,d,d,d,d,d,"Rd=tlboc(Rss)"
+0,1,1,0,0,1,1,1,0,0,-,s,s,s,s,s,P,P,-,-,-,-,-,-,-,-,d,d,d,d,d,d,"Sd=Rs"
+0,1,1,0,1,1,0,1,0,0,-,s,s,s,s,s,P,P,-,-,-,-,-,-,-,-,d,d,d,d,d,d,"Sdd=Rss"
+0,1,1,0,1,1,1,0,1,-,s,s,s,s,s,s,P,P,-,-,-,-,-,-,-,-,-,d,d,d,d,d,"Rd=Ss"
+0,1,1,0,1,1,1,1,0,-,s,s,s,s,s,s,P,P,-,-,-,-,-,-,-,-,-,d,d,d,d,d,"Rdd=Sss"
+0,1,1,0,0,1,0,0,0,1,0,s,s,s,s,s,P,P,-,-,-,-,-,-,0,0,0,-,-,-,-,-,"wait(Rs)"
+1,0,0,1,0,0,1,0,0,0,0,s,s,s,s,s,P,P,0,0,-,-,-,-,-,-,0,d,d,d,d,d,"Rd=memw_locked(Rs)"
+1,0,0,1,0,0,1,0,0,0,0,s,s,s,s,s,P,P,0,1,-,-,-,-,-,-,0,d,d,d,d,d,"Rdd=memd_locked(Rs)"
+1,0,1,0,0,0,0,0,1,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,-,-,-,d,d,"memw_locked(Rs,Pd)=Rt"
+1,0,1,0,0,0,0,0,1,1,1,s,s,s,s,s,P,P,0,t,t,t,t,t,-,-,-,-,-,-,d,d,"memd_locked(Rs,Pd)=Rtt"
+1,0,1,0,0,0,0,0,1,1,0,s,s,s,s,s,P,P,0,-,-,-,-,-,-,-,-,-,-,-,-,-,"dczeroa(Rs)"
+1,0,1,0,1,0,0,0,0,0,0,-,-,-,-,-,P,P,-,-,-,-,-,-,-,-,-,-,-,-,-,-,"barrier"
+0,1,1,0,1,1,0,0,0,0,1,-,-,-,-,-,P,P,-,-,-,-,-,-,0,0,0,-,-,-,-,-,"brkpt"
+1,0,0,1,0,1,0,0,0,0,0,s,s,s,s,s,P,P,0,-,-,j,j,j,j,j,j,j,j,j,j,j,"dcfetch(Rs+#u11:3)"
+1,0,1,0,0,0,0,0,0,0,0,s,s,s,s,s,P,P,-,-,-,-,-,-,-,-,-,-,-,-,-,-,"dccleana(Rs)"
+1,0,1,0,0,0,0,0,0,0,1,s,s,s,s,s,P,P,-,-,-,-,-,-,-,-,-,-,-,-,-,-,"dcinva(Rs)"
+1,0,1,0,0,0,0,0,0,1,0,s,s,s,s,s,P,P,-,-,-,-,-,-,-,-,-,-,-,-,-,-,"dccleaninva(Rs)"
+0,1,0,1,0,1,1,0,1,1,0,s,s,s,s,s,P,P,0,0,0,-,-,-,-,-,-,-,-,-,-,-,"icinva(Rs)"
+0,1,0,1,0,1,1,1,1,1,0,0,0,0,0,0,P,P,0,-,-,-,0,0,0,0,0,0,0,0,1,0,"isync"
+1,0,1,0,0,1,1,0,0,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,-,-,-,-,-,"l2fetch(Rs,Rt)"
+1,0,1,0,0,1,1,0,1,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,-,-,-,-,-,"l2fetch(Rs,Rtt)"
+0,1,0,1,0,1,0,0,0,1,-,-,-,-,-,-,P,P,-,j,j,j,j,j,-,-,-,j,j,j,-,-,"pause(#u8)"
+1,0,1,0,1,0,0,0,0,1,0,-,-,-,-,-,P,P,-,-,-,-,-,-,-,-,-,-,-,-,-,-,"syncht"
+0,1,1,0,0,0,1,0,0,1,0,s,s,s,s,s,P,P,-,-,-,-,-,-,-,-,-,-,-,-,-,-,"trace(Rs)"
+0,1,0,1,0,1,0,0,0,0,-,-,-,-,-,-,P,P,-,j,j,j,j,j,-,-,-,j,j,j,-,-,"trap0(#u8)"
+0,1,0,1,0,1,0,0,1,0,-,-,-,-,-,-,P,P,-,j,j,j,j,j,-,-,-,j,j,j,-,-,"trap1(#u8)"
+1,0,0,0,0,0,0,0,1,0,0,s,s,s,s,s,P,P,-,-,-,-,-,-,1,1,0,d,d,d,d,d,"Rdd=abs(Rss)"
+1,0,0,0,1,1,0,0,1,0,0,s,s,s,s,s,P,P,-,-,-,-,-,-,1,0,0,d,d,d,d,d,"Rd=abs(Rs)"
+1,0,0,0,1,1,0,0,1,0,0,s,s,s,s,s,P,P,-,-,-,-,-,-,1,0,1,d,d,d,d,d,"Rd=abs(Rs):sat"
+1,1,0,1,1,0,1,1,0,j,j,s,s,s,s,s,P,P,j,d,d,d,d,d,j,j,j,u,u,u,u,u,"Rd=add(Rs,add(Ru,#s6))"
+1,1,0,1,1,0,1,1,1,j,j,s,s,s,s,s,P,P,j,d,d,d,d,d,j,j,j,u,u,u,u,u,"Rd=add(Rs,sub(#u6,Ru))"
+1,1,1,0,0,0,1,0,0,-,-,s,s,s,s,s,P,P,0,j,j,j,j,j,j,j,j,x,x,x,x,x,"Rx+=add(Rs,#s8)"
+1,1,1,0,0,0,1,0,1,-,-,s,s,s,s,s,P,P,0,j,j,j,j,j,j,j,j,x,x,x,x,x,"Rx-=add(Rs,#s8)"
+1,1,1,0,1,1,1,1,0,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,1,x,x,x,x,x,"Rx+=add(Rs,Rt)"
+1,1,1,0,1,1,1,1,1,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,1,x,x,x,x,x,"Rx-=add(Rs,Rt)"
+1,1,0,1,0,0,1,1,0,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,1,d,d,d,d,d,"Rdd=add(Rss,Rtt)"
+1,1,0,1,0,0,1,1,0,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,1,d,d,d,d,d,"Rdd=add(Rss,Rtt):sat"
+1,1,0,1,0,0,1,1,0,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,0,d,d,d,d,d,"Rdd=add(Rss,Rtt):raw:lo"
+1,1,0,1,0,0,1,1,0,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,1,d,d,d,d,d,"Rdd=add(Rss,Rtt):raw:hi"
+1,1,0,1,0,1,0,1,1,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,-,-,d,d,d,d,d,"Rd=add(Rs,Rt):sat:deprecated"
+1,1,0,1,0,1,0,1,0,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,-,d,d,d,d,d,"Rd=add(Rt.L,Rs.L)"
+1,1,0,1,0,1,0,1,0,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,-,d,d,d,d,d,"Rd=add(Rt.L,Rs.H)"
+1,1,0,1,0,1,0,1,0,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,-,d,d,d,d,d,"Rd=add(Rt.L,Rs.L):sat"
+1,1,0,1,0,1,0,1,0,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,-,d,d,d,d,d,"Rd=add(Rt.L,Rs.H):sat"
+1,1,0,1,0,1,0,1,0,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,0,d,d,d,d,d,"Rd=add(Rt.L,Rs.L):<<16"
+1,1,0,1,0,1,0,1,0,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,1,d,d,d,d,d,"Rd=add(Rt.L,Rs.H):<<16"
+1,1,0,1,0,1,0,1,0,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,0,d,d,d,d,d,"Rd=add(Rt.H,Rs.L):<<16"
+1,1,0,1,0,1,0,1,0,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,1,d,d,d,d,d,"Rd=add(Rt.H,Rs.H):<<16"
+1,1,0,1,0,1,0,1,0,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,0,d,d,d,d,d,"Rd=add(Rt.L,Rs.L):sat:<<16"
+1,1,0,1,0,1,0,1,0,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,1,d,d,d,d,d,"Rd=add(Rt.L,Rs.H):sat:<<16"
+1,1,0,1,0,1,0,1,0,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,0,d,d,d,d,d,"Rd=add(Rt.H,Rs.L):sat:<<16"
+1,1,0,1,0,1,0,1,0,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,1,d,d,d,d,d,"Rd=add(Rt.H,Rs.H):sat:<<16"
+1,1,0,0,0,0,1,0,1,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,-,x,x,d,d,d,d,d,"Rdd=add(Rss,Rtt,Px):carry"
+1,1,0,0,0,0,1,0,1,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,-,x,x,d,d,d,d,d,"Rdd=sub(Rss,Rtt,Px):carry"
+1,0,0,0,0,0,0,0,1,0,0,s,s,s,s,s,P,P,-,-,-,-,-,-,1,0,0,d,d,d,d,d,"Rdd=not(Rss)"
+1,1,0,1,0,0,1,1,1,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,0,d,d,d,d,d,"Rdd=and(Rss,Rtt)"
+1,1,0,1,0,0,1,1,1,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,1,d,d,d,d,d,"Rdd=and(Rtt,~Rss)"
+1,1,0,1,0,0,1,1,1,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,0,d,d,d,d,d,"Rdd=or(Rss,Rtt)"
+1,1,0,1,0,0,1,1,1,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,1,d,d,d,d,d,"Rdd=or(Rtt,~Rss)"
+1,1,0,1,0,0,1,1,1,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,0,d,d,d,d,d,"Rdd=xor(Rss,Rtt)"
+1,1,0,0,1,0,1,0,1,0,-,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,0,x,x,x,x,x,"Rxx^=xor(Rss,Rtt)"
+1,1,0,1,1,0,1,0,0,0,j,s,s,s,s,s,P,P,j,j,j,j,j,j,j,j,j,x,x,x,x,x,"Rx|=and(Rs,#s10)"
+1,1,0,1,1,0,1,0,0,1,j,x,x,x,x,x,P,P,j,j,j,j,j,j,j,j,j,u,u,u,u,u,"Rx=or(Ru,and(Rx,#s10))"
+1,1,0,1,1,0,1,0,1,0,j,s,s,s,s,s,P,P,j,j,j,j,j,j,j,j,j,x,x,x,x,x,"Rx|=or(Rs,#s10)"
+1,1,1,0,1,1,1,1,0,0,1,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,0,x,x,x,x,x,"Rx|=and(Rs,~Rt)"
+1,1,1,0,1,1,1,1,0,0,1,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,1,x,x,x,x,x,"Rx&=and(Rs,~Rt)"
+1,1,1,0,1,1,1,1,0,0,1,s,s,s,s,s,P,P,0,t,t,t,t,t,0,1,0,x,x,x,x,x,"Rx^=and(Rs,~Rt)"
+1,1,1,0,1,1,1,1,0,1,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,0,x,x,x,x,x,"Rx&=and(Rs,Rt)"
+1,1,1,0,1,1,1,1,0,1,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,1,x,x,x,x,x,"Rx&=or(Rs,Rt)"
+1,1,1,0,1,1,1,1,0,1,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,1,0,x,x,x,x,x,"Rx&=xor(Rs,Rt)"
+1,1,1,0,1,1,1,1,0,1,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,1,1,x,x,x,x,x,"Rx|=and(Rs,Rt)"
+1,1,1,0,1,1,1,1,1,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,1,1,x,x,x,x,x,"Rx^=xor(Rs,Rt)"
+1,1,1,0,1,1,1,1,1,1,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,0,x,x,x,x,x,"Rx|=or(Rs,Rt)"
+1,1,1,0,1,1,1,1,1,1,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,1,x,x,x,x,x,"Rx|=xor(Rs,Rt)"
+1,1,1,0,1,1,1,1,1,1,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,1,0,x,x,x,x,x,"Rx^=and(Rs,Rt)"
+1,1,1,0,1,1,1,1,1,1,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,1,1,x,x,x,x,x,"Rx^=or(Rs,Rt)"
+1,1,0,1,0,1,0,1,1,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,-,-,d,d,d,d,d,"Rd=max(Rs,Rt)"
+1,1,0,1,0,1,0,1,1,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,1,-,-,d,d,d,d,d,"Rd=maxu(Rs,Rt)"
+1,1,0,1,0,0,1,1,1,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,0,d,d,d,d,d,"Rdd=max(Rss,Rtt)"
+1,1,0,1,0,0,1,1,1,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,1,d,d,d,d,d,"Rdd=maxu(Rss,Rtt)"
+1,1,0,1,0,1,0,1,1,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,-,-,d,d,d,d,d,"Rd=min(Rt,Rs)"
+1,1,0,1,0,1,0,1,1,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,1,-,-,d,d,d,d,d,"Rd=minu(Rt,Rs)"
+1,1,0,1,0,0,1,1,1,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,0,d,d,d,d,d,"Rdd=min(Rtt,Rss)"
+1,1,0,1,0,0,1,1,1,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,1,d,d,d,d,d,"Rdd=minu(Rtt,Rss)"
+1,1,0,1,0,0,1,1,1,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,1,d,d,d,d,d,"Rd=modwrap(Rs,Rt)"
+1,0,0,0,0,0,0,0,1,0,0,s,s,s,s,s,P,P,-,-,-,-,-,-,1,0,1,d,d,d,d,d,"Rdd=neg(Rss)"
+1,0,0,0,1,1,0,0,1,0,0,s,s,s,s,s,P,P,-,-,-,-,-,-,1,1,0,d,d,d,d,d,"Rd=neg(Rs):sat"
+1,0,0,0,1,0,0,0,1,1,0,s,s,s,s,s,P,P,-,-,-,-,-,-,0,0,1,d,d,d,d,d,"Rd=round(Rss):sat"
+1,0,0,0,1,1,0,0,1,1,1,s,s,s,s,s,P,P,0,j,j,j,j,j,0,0,-,d,d,d,d,d,"Rd=cround(Rs,#u5)"
+1,0,0,0,1,1,0,0,1,1,1,s,s,s,s,s,P,P,0,j,j,j,j,j,1,0,-,d,d,d,d,d,"Rd=round(Rs,#u5)"
+1,0,0,0,1,1,0,0,1,1,1,s,s,s,s,s,P,P,0,j,j,j,j,j,1,1,-,d,d,d,d,d,"Rd=round(Rs,#u5):sat"
+1,1,0,0,0,1,1,0,1,1,-,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,-,d,d,d,d,d,"Rd=cround(Rs,Rt)"
+1,1,0,0,0,1,1,0,1,1,-,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,-,d,d,d,d,d,"Rd=round(Rs,Rt)"
+1,1,0,0,0,1,1,0,1,1,-,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,-,d,d,d,d,d,"Rd=round(Rs,Rt):sat"
+1,1,0,1,0,0,1,1,0,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,1,d,d,d,d,d,"Rdd=sub(Rtt,Rss)"
+1,1,0,1,0,1,0,1,1,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,1,-,-,d,d,d,d,d,"Rd=sub(Rt,Rs):sat:deprecated"
+1,1,1,0,1,1,1,1,0,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,1,1,x,x,x,x,x,"Rx+=sub(Rt,Rs)"
+1,1,0,1,0,1,0,1,0,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,-,d,d,d,d,d,"Rd=sub(Rt.L,Rs.L)"
+1,1,0,1,0,1,0,1,0,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,-,d,d,d,d,d,"Rd=sub(Rt.L,Rs.H)"
+1,1,0,1,0,1,0,1,0,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,-,d,d,d,d,d,"Rd=sub(Rt.L,Rs.L):sat"
+1,1,0,1,0,1,0,1,0,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,-,d,d,d,d,d,"Rd=sub(Rt.L,Rs.H):sat"
+1,1,0,1,0,1,0,1,0,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,0,d,d,d,d,d,"Rd=sub(Rt.L,Rs.L):<<16"
+1,1,0,1,0,1,0,1,0,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,1,d,d,d,d,d,"Rd=sub(Rt.L,Rs.H):<<16"
+1,1,0,1,0,1,0,1,0,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,0,d,d,d,d,d,"Rd=sub(Rt.H,Rs.L):<<16"
+1,1,0,1,0,1,0,1,0,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,1,d,d,d,d,d,"Rd=sub(Rt.H,Rs.H):<<16"
+1,1,0,1,0,1,0,1,0,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,0,d,d,d,d,d,"Rd=sub(Rt.L,Rs.L):sat:<<16"
+1,1,0,1,0,1,0,1,0,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,1,d,d,d,d,d,"Rd=sub(Rt.L,Rs.H):sat:<<16"
+1,1,0,1,0,1,0,1,0,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,0,d,d,d,d,d,"Rd=sub(Rt.H,Rs.L):sat:<<16"
+1,1,0,1,0,1,0,1,0,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,1,d,d,d,d,d,"Rd=sub(Rt.H,Rs.H):sat:<<16"
+1,0,0,0,0,1,0,0,0,1,-,s,s,s,s,s,P,P,-,-,-,-,-,-,0,0,-,d,d,d,d,d,"Rdd=sxtw(Rs)"
+1,0,0,0,0,0,0,0,0,1,0,s,s,s,s,s,P,P,-,-,-,-,-,-,1,0,0,d,d,d,d,d,"Rdd=vabsh(Rss)"
+1,0,0,0,0,0,0,0,0,1,0,s,s,s,s,s,P,P,-,-,-,-,-,-,1,0,1,d,d,d,d,d,"Rdd=vabsh(Rss):sat"
+1,0,0,0,0,0,0,0,0,1,0,s,s,s,s,s,P,P,-,-,-,-,-,-,1,1,0,d,d,d,d,d,"Rdd=vabsw(Rss)"
+1,0,0,0,0,0,0,0,0,1,0,s,s,s,s,s,P,P,-,-,-,-,-,-,1,1,1,d,d,d,d,d,"Rdd=vabsw(Rss):sat"
+1,1,1,0,1,0,0,0,1,0,1,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,0,d,d,d,d,d,"Rdd=vabsdiffub(Rtt,Rss)"
+1,1,1,0,1,0,0,0,1,1,1,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,0,d,d,d,d,d,"Rdd=vabsdiffb(Rtt,Rss)"
+1,1,1,0,1,0,0,0,0,1,1,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,0,d,d,d,d,d,"Rdd=vabsdiffh(Rtt,Rss)"
+1,1,1,0,1,0,0,0,0,0,1,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,0,d,d,d,d,d,"Rdd=vabsdiffw(Rtt,Rss)"
+1,1,1,0,1,0,1,0,1,0,1,s,s,s,s,s,P,P,0,t,t,t,t,t,0,e,e,x,x,x,x,x,"Rxx,Pe=vacsh(Rss,Rtt)"
+1,1,0,1,0,0,1,1,0,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,0,d,d,d,d,d,"Rdd=vaddh(Rss,Rtt)"
+1,1,0,1,0,0,1,1,0,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,1,d,d,d,d,d,"Rdd=vaddh(Rss,Rtt):sat"
+1,1,0,1,0,0,1,1,0,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,0,d,d,d,d,d,"Rdd=vadduh(Rss,Rtt):sat"
+1,1,0,0,0,0,0,1,0,1,-,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,1,d,d,d,d,d,"Rd=vaddhub(Rss,Rtt):sat"
+1,1,1,0,1,0,0,0,0,1,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,1,d,d,d,d,d,"Rdd=vraddub(Rss,Rtt)"
+1,1,1,0,1,0,1,0,0,1,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,1,x,x,x,x,x,"Rxx+=vraddub(Rss,Rtt)"
+1,1,1,0,1,0,0,1,0,-,-,s,s,s,s,s,P,P,0,t,t,t,t,t,-,0,1,d,d,d,d,d,"Rd=vradduh(Rss,Rtt)"
+1,1,1,0,1,0,0,1,0,-,1,s,s,s,s,s,P,P,0,t,t,t,t,t,1,1,1,d,d,d,d,d,"Rd=vraddh(Rss,Rtt)"
+1,1,0,1,0,0,1,1,0,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,0,d,d,d,d,d,"Rdd=vaddub(Rss,Rtt)"
+1,1,0,1,0,0,1,1,0,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,1,d,d,d,d,d,"Rdd=vaddub(Rss,Rtt):sat"
+1,1,0,1,0,0,1,1,0,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,1,d,d,d,d,d,"Rdd=vaddw(Rss,Rtt)"
+1,1,0,1,0,0,1,1,0,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,0,d,d,d,d,d,"Rdd=vaddw(Rss,Rtt):sat"
+1,1,0,1,0,0,1,1,0,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,0,d,d,d,d,d,"Rdd=vavgh(Rss,Rtt)"
+1,1,0,1,0,0,1,1,0,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,1,d,d,d,d,d,"Rdd=vavgh(Rss,Rtt):rnd"
+1,1,0,1,0,0,1,1,0,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,0,d,d,d,d,d,"Rdd=vavgh(Rss,Rtt):crnd"
+1,1,0,1,0,0,1,1,0,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,1,d,d,d,d,d,"Rdd=vavguh(Rss,Rtt)"
+1,1,0,1,0,0,1,1,0,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,-,d,d,d,d,d,"Rdd=vavguh(Rss,Rtt):rnd"
+1,1,0,1,0,0,1,1,1,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,0,d,d,d,d,d,"Rdd=vnavgh(Rtt,Rss)"
+1,1,0,1,0,0,1,1,1,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,1,d,d,d,d,d,"Rdd=vnavgh(Rtt,Rss):rnd:sat"
+1,1,0,1,0,0,1,1,1,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,0,d,d,d,d,d,"Rdd=vnavgh(Rtt,Rss):crnd:sat"
+1,1,0,1,0,0,1,1,0,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,0,d,d,d,d,d,"Rdd=vavgub(Rss,Rtt)"
+1,1,0,1,0,0,1,1,0,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,1,d,d,d,d,d,"Rdd=vavgub(Rss,Rtt):rnd"
+1,1,0,1,0,0,1,1,0,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,0,d,d,d,d,d,"Rdd=vavgw(Rss,Rtt)"
+1,1,0,1,0,0,1,1,0,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,1,d,d,d,d,d,"Rdd=vavgw(Rss,Rtt):rnd"
+1,1,0,1,0,0,1,1,0,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,0,d,d,d,d,d,"Rdd=vavgw(Rss,Rtt):crnd"
+1,1,0,1,0,0,1,1,0,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,1,d,d,d,d,d,"Rdd=vavguw(Rss,Rtt)"
+1,1,0,1,0,0,1,1,0,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,0,d,d,d,d,d,"Rdd=vavguw(Rss,Rtt):rnd"
+1,1,0,1,0,0,1,1,1,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,1,d,d,d,d,d,"Rdd=vnavgw(Rtt,Rss)"
+1,1,0,1,0,0,1,1,1,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,-,d,d,d,d,d,"Rdd=vnavgw(Rtt,Rss):rnd:sat"
+1,1,0,1,0,0,1,1,1,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,-,d,d,d,d,d,"Rdd=vnavgw(Rtt,Rss):crnd:sat"
+1,1,0,0,0,0,1,1,1,1,-,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,-,d,d,d,d,d,"Rdd=vcnegh(Rss,Rt)"
+1,1,0,0,1,0,1,1,0,0,1,s,s,s,s,s,P,P,1,t,t,t,t,t,1,1,1,x,x,x,x,x,"Rxx+=vrcnegh(Rss,Rt)"
+1,1,0,1,0,0,1,1,1,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,0,d,d,d,d,d,"Rdd=vmaxub(Rtt,Rss)"
+1,1,0,1,0,0,1,1,1,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,0,d,d,d,d,d,"Rdd=vmaxb(Rtt,Rss)"
+1,1,0,1,0,0,1,1,1,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,1,d,d,d,d,d,"Rdd=vmaxh(Rtt,Rss)"
+1,1,0,1,0,0,1,1,1,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,0,d,d,d,d,d,"Rdd=vmaxuh(Rtt,Rss)"
+1,1,0,0,1,0,1,1,0,0,1,s,s,s,s,s,P,P,0,x,x,x,x,x,0,0,1,u,u,u,u,u,"Rxx=vrmaxh(Rss,Ru)"
+1,1,0,0,1,0,1,1,0,0,1,s,s,s,s,s,P,P,1,x,x,x,x,x,0,0,1,u,u,u,u,u,"Rxx=vrmaxuh(Rss,Ru)"
+1,1,0,0,1,0,1,1,0,0,1,s,s,s,s,s,P,P,0,x,x,x,x,x,0,1,0,u,u,u,u,u,"Rxx=vrmaxw(Rss,Ru)"
+1,1,0,0,1,0,1,1,0,0,1,s,s,s,s,s,P,P,1,x,x,x,x,x,0,1,0,u,u,u,u,u,"Rxx=vrmaxuw(Rss,Ru)"
+1,1,0,1,0,0,1,1,1,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,1,d,d,d,d,d,"Rdd=vmaxuw(Rtt,Rss)"
+1,1,0,1,0,0,1,1,1,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,1,d,d,d,d,d,"Rdd=vmaxw(Rtt,Rss)"
+1,1,0,1,0,0,1,1,1,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,0,d,d,d,d,d,"Rdd=vminub(Rtt,Rss)"
+1,1,0,1,0,0,1,1,1,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,1,d,d,d,d,d,"Rdd=vminb(Rtt,Rss)"
+1,1,1,0,1,0,1,0,1,1,1,s,s,s,s,s,P,P,0,t,t,t,t,t,0,e,e,d,d,d,d,d,"Rdd,Pe=vminub(Rtt,Rss)"
+1,1,0,1,0,0,1,1,1,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,1,d,d,d,d,d,"Rdd=vminh(Rtt,Rss)"
+1,1,0,1,0,0,1,1,1,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,0,d,d,d,d,d,"Rdd=vminuh(Rtt,Rss)"
+1,1,0,0,1,0,1,1,0,0,1,s,s,s,s,s,P,P,0,x,x,x,x,x,1,0,1,u,u,u,u,u,"Rxx=vrminh(Rss,Ru)"
+1,1,0,0,1,0,1,1,0,0,1,s,s,s,s,s,P,P,1,x,x,x,x,x,1,0,1,u,u,u,u,u,"Rxx=vrminuh(Rss,Ru)"
+1,1,0,0,1,0,1,1,0,0,1,s,s,s,s,s,P,P,0,x,x,x,x,x,1,1,0,u,u,u,u,u,"Rxx=vrminw(Rss,Ru)"
+1,1,0,0,1,0,1,1,0,0,1,s,s,s,s,s,P,P,1,x,x,x,x,x,1,1,0,u,u,u,u,u,"Rxx=vrminuw(Rss,Ru)"
+1,1,0,1,0,0,1,1,1,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,1,d,d,d,d,d,"Rdd=vminw(Rtt,Rss)"
+1,1,0,1,0,0,1,1,1,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,0,d,d,d,d,d,"Rdd=vminuw(Rtt,Rss)"
+1,1,1,0,1,0,0,0,0,1,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,1,0,d,d,d,d,d,"Rdd=vrsadub(Rss,Rtt)"
+1,1,1,0,1,0,1,0,0,1,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,1,0,x,x,x,x,x,"Rxx+=vrsadub(Rss,Rtt)"
+1,1,0,1,0,0,1,1,0,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,0,d,d,d,d,d,"Rdd=vsubh(Rtt,Rss)"
+1,1,0,1,0,0,1,1,0,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,1,d,d,d,d,d,"Rdd=vsubh(Rtt,Rss):sat"
+1,1,0,1,0,0,1,1,0,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,0,d,d,d,d,d,"Rdd=vsubuh(Rtt,Rss):sat"
+1,1,0,1,0,0,1,1,0,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,0,d,d,d,d,d,"Rdd=vsubub(Rtt,Rss)"
+1,1,0,1,0,0,1,1,0,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,1,d,d,d,d,d,"Rdd=vsubub(Rtt,Rss):sat"
+1,1,0,1,0,0,1,1,0,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,1,d,d,d,d,d,"Rdd=vsubw(Rtt,Rss)"
+1,1,0,1,0,0,1,1,0,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,0,d,d,d,d,d,"Rdd=vsubw(Rtt,Rss):sat"
+1,0,0,0,1,0,0,0,0,1,0,s,s,s,s,s,P,P,-,-,-,-,-,-,0,0,0,d,d,d,d,d,"Rd=clb(Rss)"
+1,0,0,0,1,0,0,0,0,1,0,s,s,s,s,s,P,P,-,-,-,-,-,-,0,1,0,d,d,d,d,d,"Rd=cl0(Rss)"
+1,0,0,0,1,0,0,0,0,1,0,s,s,s,s,s,P,P,-,-,-,-,-,-,1,0,0,d,d,d,d,d,"Rd=cl1(Rss)"
+1,0,0,0,1,0,0,0,0,1,1,s,s,s,s,s,P,P,-,-,-,-,-,-,0,0,0,d,d,d,d,d,"Rd=normamt(Rss)"
+1,0,0,0,1,0,0,0,0,1,1,s,s,s,s,s,P,P,j,j,j,j,j,j,0,1,0,d,d,d,d,d,"Rd=add(clb(Rss),#s6)"
+1,0,0,0,1,1,0,0,0,0,1,s,s,s,s,s,P,P,j,j,j,j,j,j,0,0,0,d,d,d,d,d,"Rd=add(clb(Rs),#s6)"
+1,0,0,0,1,1,0,0,0,0,0,s,s,s,s,s,P,P,-,-,-,-,-,-,1,0,0,d,d,d,d,d,"Rd=clb(Rs)"
+1,0,0,0,1,1,0,0,0,0,0,s,s,s,s,s,P,P,-,-,-,-,-,-,1,0,1,d,d,d,d,d,"Rd=cl0(Rs)"
+1,0,0,0,1,1,0,0,0,0,0,s,s,s,s,s,P,P,-,-,-,-,-,-,1,1,0,d,d,d,d,d,"Rd=cl1(Rs)"
+1,0,0,0,1,1,0,0,0,0,0,s,s,s,s,s,P,P,-,-,-,-,-,-,1,1,1,d,d,d,d,d,"Rd=normamt(Rs)"
+1,0,0,0,1,0,0,0,0,1,1,s,s,s,s,s,P,P,-,-,-,-,-,-,0,1,1,d,d,d,d,d,"Rd=popcount(Rss)"
+1,0,0,0,1,0,0,0,1,1,1,s,s,s,s,s,P,P,-,-,-,-,-,-,0,1,0,d,d,d,d,d,"Rd=ct0(Rss)"
+1,0,0,0,1,0,0,0,1,1,1,s,s,s,s,s,P,P,-,-,-,-,-,-,1,0,0,d,d,d,d,d,"Rd=ct1(Rss)"
+1,0,0,0,1,1,0,0,0,1,0,s,s,s,s,s,P,P,-,-,-,-,-,-,1,0,0,d,d,d,d,d,"Rd=ct0(Rs)"
+1,0,0,0,1,1,0,0,0,1,0,s,s,s,s,s,P,P,-,-,-,-,-,-,1,0,1,d,d,d,d,d,"Rd=ct1(Rs)"
+1,0,0,0,0,0,0,1,I,I,I,s,s,s,s,s,P,P,j,j,j,j,j,j,I,I,I,d,d,d,d,d,"Rdd=extractu(Rss,#u6,#U6)"
+1,0,0,0,1,0,1,0,I,I,I,s,s,s,s,s,P,P,j,j,j,j,j,j,I,I,I,d,d,d,d,d,"Rdd=extract(Rss,#u6,#U6)"
+1,0,0,0,1,1,0,1,0,I,I,s,s,s,s,s,P,P,0,j,j,j,j,j,I,I,I,d,d,d,d,d,"Rd=extractu(Rs,#u5,#U5)"
+1,0,0,0,1,1,0,1,1,I,I,s,s,s,s,s,P,P,0,j,j,j,j,j,I,I,I,d,d,d,d,d,"Rd=extract(Rs,#u5,#U5)"
+1,1,0,0,0,0,0,1,0,0,-,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,-,d,d,d,d,d,"Rdd=extractu(Rss,Rtt)"
+1,1,0,0,0,0,0,1,1,1,-,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,-,d,d,d,d,d,"Rdd=extract(Rss,Rtt)"
+1,1,0,0,1,0,0,1,0,0,-,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,-,d,d,d,d,d,"Rd=extractu(Rs,Rtt)"
+1,1,0,0,1,0,0,1,0,0,-,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,-,d,d,d,d,d,"Rd=extract(Rs,Rtt)"
+1,0,0,0,0,0,1,1,I,I,I,s,s,s,s,s,P,P,j,j,j,j,j,j,I,I,I,x,x,x,x,x,"Rxx=insert(Rss,#u6,#U6)"
+1,0,0,0,1,1,1,1,0,I,I,s,s,s,s,s,P,P,0,j,j,j,j,j,I,I,I,x,x,x,x,x,"Rx=insert(Rs,#u5,#U5)"
+1,1,0,0,1,0,0,0,-,-,-,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,x,x,x,x,x,"Rx=insert(Rs,Rtt)"
+1,1,0,0,1,0,1,0,0,-,-,s,s,s,s,s,P,P,0,t,t,t,t,t,-,-,-,x,x,x,x,x,"Rxx=insert(Rss,Rtt)"
+1,0,0,0,0,0,0,0,1,1,0,s,s,s,s,s,P,P,-,-,-,-,-,-,1,0,0,d,d,d,d,d,"Rdd=deinterleave(Rss)"
+1,0,0,0,0,0,0,0,1,1,0,s,s,s,s,s,P,P,-,-,-,-,-,-,1,0,1,d,d,d,d,d,"Rdd=interleave(Rss)"
+1,1,0,0,0,0,0,1,1,0,-,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,0,d,d,d,d,d,"Rdd=lfs(Rss,Rtt)"
+1,1,0,1,0,0,0,0,-,-,-,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,d,d,d,d,d,"Rd=parity(Rss,Rtt)"
+1,1,0,1,0,1,0,1,1,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,d,d,d,d,d,"Rd=parity(Rs,Rt)"
+1,0,0,0,0,0,0,0,1,1,0,s,s,s,s,s,P,P,-,-,-,-,-,-,1,1,0,d,d,d,d,d,"Rdd=brev(Rss)"
+1,0,0,0,1,1,0,0,0,1,0,s,s,s,s,s,P,P,-,-,-,-,-,-,1,1,0,d,d,d,d,d,"Rd=brev(Rs)"
+1,0,0,0,1,1,0,0,1,1,0,s,s,s,s,s,P,P,0,j,j,j,j,j,0,0,0,d,d,d,d,d,"Rd=setbit(Rs,#u5)"
+1,0,0,0,1,1,0,0,1,1,0,s,s,s,s,s,P,P,0,j,j,j,j,j,0,0,1,d,d,d,d,d,"Rd=clrbit(Rs,#u5)"
+1,0,0,0,1,1,0,0,1,1,0,s,s,s,s,s,P,P,0,j,j,j,j,j,0,1,0,d,d,d,d,d,"Rd=togglebit(Rs,#u5)"
+1,1,0,0,0,1,1,0,1,0,-,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,-,d,d,d,d,d,"Rd=setbit(Rs,Rt)"
+1,1,0,0,0,1,1,0,1,0,-,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,-,d,d,d,d,d,"Rd=clrbit(Rs,Rt)"
+1,1,0,0,0,1,1,0,1,0,-,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,-,d,d,d,d,d,"Rd=togglebit(Rs,Rt)"
+1,0,0,0,1,0,0,0,1,1,0,s,s,s,s,s,P,P,0,j,j,j,j,j,1,0,0,d,d,d,d,d,"Rdd=bitsplit(Rs,#u5)"
+1,1,0,1,0,1,0,0,-,-,1,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,d,d,d,d,d,"Rdd=bitsplit(Rs,Rt)"
+1,0,0,0,0,1,1,1,0,0,j,s,s,s,s,s,P,P,I,I,I,I,I,I,j,j,j,x,x,x,x,x,"Rx=tableidxb(Rs,#u4,#S6):raw"
+1,0,0,0,0,1,1,1,0,1,j,s,s,s,s,s,P,P,I,I,I,I,I,I,j,j,j,x,x,x,x,x,"Rx=tableidxh(Rs,#u4,#S6):raw"
+1,0,0,0,0,1,1,1,1,0,j,s,s,s,s,s,P,P,I,I,I,I,I,I,j,j,j,x,x,x,x,x,"Rx=tableidxw(Rs,#u4,#S6):raw"
+1,0,0,0,0,1,1,1,1,1,j,s,s,s,s,s,P,P,I,I,I,I,I,I,j,j,j,x,x,x,x,x,"Rx=tableidxd(Rs,#u4,#S6):raw"
+1,1,0,0,0,0,0,1,0,1,-,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,0,d,d,d,d,d,"Rdd=vxaddsubh(Rss,Rtt):sat"
+1,1,0,0,0,0,0,1,0,1,-,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,0,d,d,d,d,d,"Rdd=vxsubaddh(Rss,Rtt):sat"
+1,1,0,0,0,0,0,1,1,1,-,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,-,d,d,d,d,d,"Rdd=vxaddsubh(Rss,Rtt):rnd:>>1:sat"
+1,1,0,0,0,0,0,1,1,1,-,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,-,d,d,d,d,d,"Rdd=vxsubaddh(Rss,Rtt):rnd:>>1:sat"
+1,1,0,0,0,0,0,1,0,1,-,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,0,d,d,d,d,d,"Rdd=vxaddsubw(Rss,Rtt):sat"
+1,1,0,0,0,0,0,1,0,1,-,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,0,d,d,d,d,d,"Rdd=vxsubaddw(Rss,Rtt):sat"
+1,1,1,0,0,1,0,1,N,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,1,1,0,d,d,d,d,d,"Rdd=cmpy(Rs,Rt)[:<<N]:sat"
+1,1,1,0,0,1,0,1,N,1,0,s,s,s,s,s,P,P,0,t,t,t,t,t,1,1,0,d,d,d,d,d,"Rdd=cmpy(Rs,Rt*)[:<<N]:sat"
+1,1,1,0,0,1,1,1,N,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,1,1,0,x,x,x,x,x,"Rxx+=cmpy(Rs,Rt)[:<<N]:sat"
+1,1,1,0,0,1,1,1,N,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,1,1,1,x,x,x,x,x,"Rxx-=cmpy(Rs,Rt)[:<<N]:sat"
+1,1,1,0,0,1,1,1,N,1,0,s,s,s,s,s,P,P,0,t,t,t,t,t,1,1,0,x,x,x,x,x,"Rxx+=cmpy(Rs,Rt*)[:<<N]:sat"
+1,1,1,0,0,1,1,1,N,1,0,s,s,s,s,s,P,P,0,t,t,t,t,t,1,1,1,x,x,x,x,x,"Rxx-=cmpy(Rs,Rt*)[:<<N]:sat"
+1,1,1,0,0,1,0,1,0,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,1,d,d,d,d,d,"Rdd=cmpyi(Rs,Rt)"
+1,1,1,0,0,1,0,1,0,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,1,0,d,d,d,d,d,"Rdd=cmpyr(Rs,Rt)"
+1,1,1,0,0,1,1,1,0,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,1,x,x,x,x,x,"Rxx+=cmpyi(Rs,Rt)"
+1,1,1,0,0,1,1,1,0,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,1,0,x,x,x,x,x,"Rxx+=cmpyr(Rs,Rt)"
+1,1,1,0,1,1,0,1,N,0,1,s,s,s,s,s,P,P,0,t,t,t,t,t,1,1,0,d,d,d,d,d,"Rd=cmpy(Rs,Rt)[:<<N]:rnd:sat"
+1,1,1,0,1,1,0,1,N,1,1,s,s,s,s,s,P,P,0,t,t,t,t,t,1,1,0,d,d,d,d,d,"Rd=cmpy(Rs,Rt*)[:<<N]:rnd:sat"
+1,1,0,0,0,1,0,1,-,-,-,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,0,d,d,d,d,d,"Rd=cmpyiwh(Rss,Rt):<<1:rnd:sat"
+1,1,0,0,0,1,0,1,-,-,-,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,1,d,d,d,d,d,"Rd=cmpyiwh(Rss,Rt*):<<1:rnd:sat"
+1,1,0,0,0,1,0,1,-,-,-,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,0,d,d,d,d,d,"Rd=cmpyrwh(Rss,Rt):<<1:rnd:sat"
+1,1,0,0,0,1,0,1,-,-,-,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,1,d,d,d,d,d,"Rd=cmpyrwh(Rss,Rt*):<<1:rnd:sat"
+1,1,1,0,1,0,0,0,N,0,1,s,s,s,s,s,P,P,0,t,t,t,t,t,1,1,0,d,d,d,d,d,"Rdd=vcmpyr(Rss,Rtt)[:<<N]:sat"
+1,1,1,0,1,0,0,0,N,1,0,s,s,s,s,s,P,P,0,t,t,t,t,t,1,1,0,d,d,d,d,d,"Rdd=vcmpyi(Rss,Rtt)[:<<N]:sat"
+1,1,1,0,1,0,1,0,0,0,1,s,s,s,s,s,P,P,0,t,t,t,t,t,1,0,0,x,x,x,x,x,"Rxx+=vcmpyr(Rss,Rtt):sat"
+1,1,1,0,1,0,1,0,0,1,0,s,s,s,s,s,P,P,0,t,t,t,t,t,1,0,0,x,x,x,x,x,"Rxx+=vcmpyi(Rss,Rtt):sat"
+1,0,0,0,0,0,0,0,1,0,0,s,s,s,s,s,P,P,-,-,-,-,-,-,1,1,1,d,d,d,d,d,"Rdd=vconj(Rss):sat"
+1,1,0,0,0,0,1,1,1,1,-,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,-,d,d,d,d,d,"Rdd=vcrotate(Rss,Rt)"
+1,1,1,0,1,0,0,0,0,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,0,d,d,d,d,d,"Rdd=vrcmpyi(Rss,Rtt)"
+1,1,1,0,1,0,0,0,0,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,1,d,d,d,d,d,"Rdd=vrcmpyr(Rss,Rtt)"
+1,1,1,0,1,0,0,0,0,1,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,0,d,d,d,d,d,"Rdd=vrcmpyi(Rss,Rtt*)"
+1,1,1,0,1,0,0,0,0,1,1,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,1,d,d,d,d,d,"Rdd=vrcmpyr(Rss,Rtt*)"
+1,1,1,0,1,0,1,0,0,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,0,x,x,x,x,x,"Rxx+=vrcmpyi(Rss,Rtt)"
+1,1,1,0,1,0,1,0,0,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,1,x,x,x,x,x,"Rxx+=vrcmpyr(Rss,Rtt)"
+1,1,1,0,1,0,1,0,0,1,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,0,x,x,x,x,x,"Rxx+=vrcmpyi(Rss,Rtt*)"
+1,1,1,0,1,0,1,0,0,1,1,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,1,x,x,x,x,x,"Rxx+=vrcmpyr(Rss,Rtt*)"
+1,1,1,0,1,0,0,0,1,0,1,s,s,s,s,s,P,P,0,t,t,t,t,t,1,0,0,d,d,d,d,d,"Rdd=vrcmpys(Rss,Rtt):<<1:sat:raw:hi"
+1,1,1,0,1,0,0,0,1,1,1,s,s,s,s,s,P,P,0,t,t,t,t,t,1,0,0,d,d,d,d,d,"Rdd=vrcmpys(Rss,Rtt):<<1:sat:raw:lo"
+1,1,1,0,1,0,1,0,1,0,1,s,s,s,s,s,P,P,0,t,t,t,t,t,1,0,0,x,x,x,x,x,"Rxx+=vrcmpys(Rss,Rtt):<<1:sat:raw:hi"
+1,1,1,0,1,0,1,0,1,1,1,s,s,s,s,s,P,P,0,t,t,t,t,t,1,0,0,x,x,x,x,x,"Rxx+=vrcmpys(Rss,Rtt):<<1:sat:raw:lo"
+1,1,1,0,1,0,0,1,1,-,1,s,s,s,s,s,P,P,0,t,t,t,t,t,1,1,0,d,d,d,d,d,"Rd=vrcmpys(Rss,Rtt):<<1:rnd:sat:raw:hi"
+1,1,1,0,1,0,0,1,1,-,1,s,s,s,s,s,P,P,0,t,t,t,t,t,1,1,1,d,d,d,d,d,"Rd=vrcmpys(Rss,Rtt):<<1:rnd:sat:raw:lo"
+1,1,0,0,0,0,1,1,1,1,-,s,s,s,s,s,P,P,j,t,t,t,t,t,1,1,j,d,d,d,d,d,"Rdd=vrcrotate(Rss,Rt,#u2)"
+1,1,0,0,1,0,1,1,1,0,1,s,s,s,s,s,P,P,j,t,t,t,t,t,-,-,j,x,x,x,x,x,"Rxx+=vrcrotate(Rss,Rt,#u2)"
+1,1,1,0,1,0,1,1,0,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,0,d,d,d,d,d,"Rd=sfadd(Rs,Rt)"
+1,0,0,0,0,1,0,1,1,1,1,s,s,s,s,s,P,P,0,j,j,j,j,j,-,-,-,-,-,-,d,d,"Pd=sfclass(Rs,#u5)"
+1,1,0,1,1,1,0,0,1,0,0,s,s,s,s,s,P,P,-,0,0,0,j,j,j,j,j,1,0,-,d,d,"Pd=dfclass(Rss,#u5)"
+1,1,0,0,0,1,1,1,1,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,0,-,-,-,d,d,"Pd=sfcmp.ge(Rs,Rt)"
+1,1,0,0,0,1,1,1,1,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,1,-,-,-,d,d,"Pd=sfcmp.uo(Rs,Rt)"
+1,1,0,0,0,1,1,1,1,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,1,-,-,-,d,d,"Pd=sfcmp.eq(Rs,Rt)"
+1,1,0,0,0,1,1,1,1,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,0,-,-,-,d,d,"Pd=sfcmp.gt(Rs,Rt)"
+1,1,0,1,0,0,1,0,1,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,0,-,-,-,d,d,"Pd=dfcmp.eq(Rss,Rtt)"
+1,1,0,1,0,0,1,0,1,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,1,-,-,-,d,d,"Pd=dfcmp.gt(Rss,Rtt)"
+1,1,0,1,0,0,1,0,1,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,0,-,-,-,d,d,"Pd=dfcmp.ge(Rss,Rtt)"
+1,1,0,1,0,0,1,0,1,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,1,-,-,-,d,d,"Pd=dfcmp.uo(Rss,Rtt)"
+1,0,0,0,0,1,0,0,1,-,-,s,s,s,s,s,P,P,-,-,-,-,-,-,0,0,0,d,d,d,d,d,"Rdd=convert_sf2df(Rs)"
+1,0,0,0,1,0,0,0,0,0,0,s,s,s,s,s,P,P,-,-,-,-,-,-,0,0,1,d,d,d,d,d,"Rd=convert_df2sf(Rss)"
+1,0,0,0,0,0,0,0,1,1,1,s,s,s,s,s,P,P,0,-,-,-,-,-,0,1,0,d,d,d,d,d,"Rdd=convert_ud2df(Rss)"
+1,0,0,0,0,0,0,0,1,1,1,s,s,s,s,s,P,P,0,-,-,-,-,-,0,1,1,d,d,d,d,d,"Rdd=convert_d2df(Rss)"
+1,0,0,0,0,1,0,0,1,-,-,s,s,s,s,s,P,P,-,-,-,-,-,-,0,0,1,d,d,d,d,d,"Rdd=convert_uw2df(Rs)"
+1,0,0,0,0,1,0,0,1,-,-,s,s,s,s,s,P,P,-,-,-,-,-,-,0,1,0,d,d,d,d,d,"Rdd=convert_w2df(Rs)"
+1,0,0,0,1,0,0,0,0,0,1,s,s,s,s,s,P,P,-,-,-,-,-,-,0,0,1,d,d,d,d,d,"Rd=convert_ud2sf(Rss)"
+1,0,0,0,1,0,0,0,0,1,0,s,s,s,s,s,P,P,-,-,-,-,-,-,0,0,1,d,d,d,d,d,"Rd=convert_d2sf(Rss)"
+1,0,0,0,1,0,1,1,0,0,1,s,s,s,s,s,P,P,-,-,-,-,-,-,0,0,0,d,d,d,d,d,"Rd=convert_uw2sf(Rs)"
+1,0,0,0,1,0,1,1,0,1,0,s,s,s,s,s,P,P,-,-,-,-,-,-,0,0,0,d,d,d,d,d,"Rd=convert_w2sf(Rs)"
+1,0,0,0,0,0,0,0,1,1,1,s,s,s,s,s,P,P,0,-,-,-,-,-,0,0,0,d,d,d,d,d,"Rdd=convert_df2d(Rss)"
+1,0,0,0,0,0,0,0,1,1,1,s,s,s,s,s,P,P,0,-,-,-,-,-,0,0,1,d,d,d,d,d,"Rdd=convert_df2ud(Rss)"
+1,0,0,0,0,0,0,0,1,1,1,s,s,s,s,s,P,P,0,-,-,-,-,-,1,1,0,d,d,d,d,d,"Rdd=convert_df2d(Rss):chop"
+1,0,0,0,0,0,0,0,1,1,1,s,s,s,s,s,P,P,0,-,-,-,-,-,1,1,1,d,d,d,d,d,"Rdd=convert_df2ud(Rss):chop"
+1,0,0,0,0,1,0,0,1,-,-,s,s,s,s,s,P,P,-,-,-,-,-,-,0,1,1,d,d,d,d,d,"Rdd=convert_sf2ud(Rs)"
+1,0,0,0,0,1,0,0,1,-,-,s,s,s,s,s,P,P,-,-,-,-,-,-,1,0,0,d,d,d,d,d,"Rdd=convert_sf2d(Rs)"
+1,0,0,0,0,1,0,0,1,-,-,s,s,s,s,s,P,P,-,-,-,-,-,-,1,0,1,d,d,d,d,d,"Rdd=convert_sf2ud(Rs):chop"
+1,0,0,0,0,1,0,0,1,-,-,s,s,s,s,s,P,P,-,-,-,-,-,-,1,1,0,d,d,d,d,d,"Rdd=convert_sf2d(Rs):chop"
+1,0,0,0,1,0,0,0,0,1,1,s,s,s,s,s,P,P,-,-,-,-,-,-,0,0,1,d,d,d,d,d,"Rd=convert_df2uw(Rss)"
+1,0,0,0,1,0,0,0,1,0,0,s,s,s,s,s,P,P,-,-,-,-,-,-,0,0,1,d,d,d,d,d,"Rd=convert_df2w(Rss)"
+1,0,0,0,1,0,0,0,1,0,1,s,s,s,s,s,P,P,-,-,-,-,-,-,0,0,1,d,d,d,d,d,"Rd=convert_df2uw(Rss):chop"
+1,0,0,0,1,0,0,0,1,1,1,s,s,s,s,s,P,P,-,-,-,-,-,-,0,0,1,d,d,d,d,d,"Rd=convert_df2w(Rss):chop"
+1,0,0,0,1,0,1,1,0,1,1,s,s,s,s,s,P,P,-,-,-,-,-,-,0,0,0,d,d,d,d,d,"Rd=convert_sf2uw(Rs)"
+1,0,0,0,1,0,1,1,0,1,1,s,s,s,s,s,P,P,-,-,-,-,-,-,0,0,1,d,d,d,d,d,"Rd=convert_sf2uw(Rs):chop"
+1,0,0,0,1,0,1,1,1,0,0,s,s,s,s,s,P,P,-,-,-,-,-,-,0,0,0,d,d,d,d,d,"Rd=convert_sf2w(Rs)"
+1,0,0,0,1,0,1,1,1,0,0,s,s,s,s,s,P,P,-,-,-,-,-,-,0,0,1,d,d,d,d,d,"Rd=convert_sf2w(Rs):chop"
+1,0,0,0,1,0,1,1,1,0,1,s,s,s,s,s,P,P,-,-,-,-,-,-,0,0,0,d,d,d,d,d,"Rd=sffixupr(Rs)"
+1,1,1,0,1,0,1,1,1,1,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,0,d,d,d,d,d,"Rd=sffixupn(Rs,Rt)"
+1,1,1,0,1,0,1,1,1,1,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,1,d,d,d,d,d,"Rd=sffixupd(Rs,Rt)"
+1,1,1,0,1,1,1,1,0,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,1,0,0,x,x,x,x,x,"Rx+=sfmpy(Rs,Rt)"
+1,1,1,0,1,1,1,1,0,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,1,0,1,x,x,x,x,x,"Rx-=sfmpy(Rs,Rt)"
+1,1,1,0,1,1,1,1,0,1,1,s,s,s,s,s,P,P,0,t,t,t,t,t,1,u,u,x,x,x,x,x,"Rx+=sfmpy(Rs,Rt,Pu):scale"
+1,0,0,0,1,0,1,1,1,1,1,s,s,s,s,s,P,P,-,-,-,-,-,-,0,e,e,d,d,d,d,d,"Rd,Pe=sfinvsqrta(Rs)"
+1,1,1,0,1,1,1,1,0,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,1,1,0,x,x,x,x,x,"Rx+=sfmpy(Rs,Rt):lib"
+1,1,1,0,1,1,1,1,0,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,1,1,1,x,x,x,x,x,"Rx-=sfmpy(Rs,Rt):lib"
+1,1,0,1,0,1,1,0,0,0,j,-,-,-,-,-,P,P,j,j,j,j,j,j,j,j,j,d,d,d,d,d,"Rd=sfmake(#u10):pos"
+1,1,0,1,0,1,1,0,0,1,j,-,-,-,-,-,P,P,j,j,j,j,j,j,j,j,j,d,d,d,d,d,"Rd=sfmake(#u10):neg"
+1,1,0,1,1,0,0,1,0,0,j,-,-,-,-,-,P,P,j,j,j,j,j,j,j,j,j,d,d,d,d,d,"Rdd=dfmake(#u10):pos"
+1,1,0,1,1,0,0,1,0,1,j,-,-,-,-,-,P,P,j,j,j,j,j,j,j,j,j,d,d,d,d,d,"Rdd=dfmake(#u10):neg"
+1,1,1,0,1,0,1,1,1,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,0,d,d,d,d,d,"Rd=sfmax(Rs,Rt)"
+1,1,1,0,1,0,1,1,1,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,1,d,d,d,d,d,"Rd=sfmin(Rs,Rt)"
+1,1,1,0,1,0,1,1,0,1,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,0,d,d,d,d,d,"Rd=sfmpy(Rs,Rt)"
+1,1,1,0,1,0,1,1,1,1,1,s,s,s,s,s,P,P,0,t,t,t,t,t,1,e,e,d,d,d,d,d,"Rd,Pe=sfrecipa(Rs,Rt)"
+1,1,1,0,1,0,1,1,0,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,1,d,d,d,d,d,"Rd=sfsub(Rs,Rt)"
+1,1,0,1,0,1,1,1,0,j,j,s,s,s,s,s,P,P,j,t,t,t,t,t,j,j,j,d,d,d,d,d,"Rd=add(#u6,mpyi(Rs,Rt))"
+1,1,0,1,1,0,0,0,I,j,j,s,s,s,s,s,P,P,j,d,d,d,d,d,j,j,j,I,I,I,I,I,"Rd=add(#u6,mpyi(Rs,#U6))"
+1,1,0,1,1,1,1,1,0,j,j,s,s,s,s,s,P,P,j,d,d,d,d,d,j,j,j,u,u,u,u,u,"Rd=add(Ru,mpyi(#u6:2,Rs))"
+1,1,0,1,1,1,1,1,1,j,j,s,s,s,s,s,P,P,j,d,d,d,d,d,j,j,j,u,u,u,u,u,"Rd=add(Ru,mpyi(Rs,#u6))"
+1,1,1,0,0,0,1,1,0,0,0,s,s,s,s,s,P,P,-,y,y,y,y,y,-,-,-,u,u,u,u,u,"Ry=add(Ru,mpyi(Ry,Rs))"
+1,1,1,0,0,0,0,0,0,-,-,s,s,s,s,s,P,P,0,j,j,j,j,j,j,j,j,d,d,d,d,d,"Rd=+mpyi(Rs,#u8)"
+1,1,1,0,0,0,0,0,1,-,-,s,s,s,s,s,P,P,0,j,j,j,j,j,j,j,j,d,d,d,d,d,"Rd=-mpyi(Rs,#u8)"
+1,1,1,0,0,0,0,1,0,-,-,s,s,s,s,s,P,P,0,j,j,j,j,j,j,j,j,x,x,x,x,x,"Rx+=mpyi(Rs,#u8)"
+1,1,1,0,0,0,0,1,1,-,-,s,s,s,s,s,P,P,0,j,j,j,j,j,j,j,j,x,x,x,x,x,"Rx-=mpyi(Rs,#u8)"
+1,1,1,0,1,1,0,1,0,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,0,d,d,d,d,d,"Rd=mpyi(Rs,Rt)"
+1,1,1,0,1,1,1,1,0,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,0,x,x,x,x,x,"Rx+=mpyi(Rs,Rt)"
+1,1,1,0,1,0,0,0,N,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,1,0,1,d,d,d,d,d,"Rdd=vmpyweh(Rss,Rtt)[:<<N]:sat"
+1,1,1,0,1,0,0,0,N,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,1,1,1,d,d,d,d,d,"Rdd=vmpywoh(Rss,Rtt)[:<<N]:sat"
+1,1,1,0,1,0,0,0,N,0,1,s,s,s,s,s,P,P,0,t,t,t,t,t,1,0,1,d,d,d,d,d,"Rdd=vmpyweh(Rss,Rtt)[:<<N]:rnd:sat"
+1,1,1,0,1,0,0,0,N,0,1,s,s,s,s,s,P,P,0,t,t,t,t,t,1,1,1,d,d,d,d,d,"Rdd=vmpywoh(Rss,Rtt)[:<<N]:rnd:sat"
+1,1,1,0,1,0,1,0,N,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,1,0,1,x,x,x,x,x,"Rxx+=vmpyweh(Rss,Rtt)[:<<N]:sat"
+1,1,1,0,1,0,1,0,N,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,1,1,1,x,x,x,x,x,"Rxx+=vmpywoh(Rss,Rtt)[:<<N]:sat"
+1,1,1,0,1,0,1,0,N,0,1,s,s,s,s,s,P,P,0,t,t,t,t,t,1,0,1,x,x,x,x,x,"Rxx+=vmpyweh(Rss,Rtt)[:<<N]:rnd:sat"
+1,1,1,0,1,0,1,0,N,0,1,s,s,s,s,s,P,P,0,t,t,t,t,t,1,1,1,x,x,x,x,x,"Rxx+=vmpywoh(Rss,Rtt)[:<<N]:rnd:sat"
+1,1,1,0,1,0,0,0,N,1,0,s,s,s,s,s,P,P,0,t,t,t,t,t,1,0,1,d,d,d,d,d,"Rdd=vmpyweuh(Rss,Rtt)[:<<N]:sat"
+1,1,1,0,1,0,0,0,N,1,0,s,s,s,s,s,P,P,0,t,t,t,t,t,1,1,1,d,d,d,d,d,"Rdd=vmpywouh(Rss,Rtt)[:<<N]:sat"
+1,1,1,0,1,0,0,0,N,1,1,s,s,s,s,s,P,P,0,t,t,t,t,t,1,0,1,d,d,d,d,d,"Rdd=vmpyweuh(Rss,Rtt)[:<<N]:rnd:sat"
+1,1,1,0,1,0,0,0,N,1,1,s,s,s,s,s,P,P,0,t,t,t,t,t,1,1,1,d,d,d,d,d,"Rdd=vmpywouh(Rss,Rtt)[:<<N]:rnd:sat"
+1,1,1,0,1,0,1,0,N,1,0,s,s,s,s,s,P,P,0,t,t,t,t,t,1,0,1,x,x,x,x,x,"Rxx+=vmpyweuh(Rss,Rtt)[:<<N]:sat"
+1,1,1,0,1,0,1,0,N,1,0,s,s,s,s,s,P,P,0,t,t,t,t,t,1,1,1,x,x,x,x,x,"Rxx+=vmpywouh(Rss,Rtt)[:<<N]:sat"
+1,1,1,0,1,0,1,0,N,1,1,s,s,s,s,s,P,P,0,t,t,t,t,t,1,0,1,x,x,x,x,x,"Rxx+=vmpyweuh(Rss,Rtt)[:<<N]:rnd:sat"
+1,1,1,0,1,0,1,0,N,1,1,s,s,s,s,s,P,P,0,t,t,t,t,t,1,1,1,x,x,x,x,x,"Rxx+=vmpywouh(Rss,Rtt)[:<<N]:rnd:sat"
+1,1,1,0,0,1,0,0,N,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,-,0,0,d,d,d,d,d,"Rdd=mpy(Rs.L,Rt.L)[:<<N]"
+1,1,1,0,0,1,0,0,N,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,-,0,1,d,d,d,d,d,"Rdd=mpy(Rs.L,Rt.H)[:<<N]"
+1,1,1,0,0,1,0,0,N,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,-,1,0,d,d,d,d,d,"Rdd=mpy(Rs.H,Rt.L)[:<<N]"
+1,1,1,0,0,1,0,0,N,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,-,1,1,d,d,d,d,d,"Rdd=mpy(Rs.H,Rt.H)[:<<N]"
+1,1,1,0,0,1,0,0,N,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,-,0,0,d,d,d,d,d,"Rdd=mpy(Rs.L,Rt.L)[:<<N]:rnd"
+1,1,1,0,0,1,0,0,N,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,-,0,1,d,d,d,d,d,"Rdd=mpy(Rs.L,Rt.H)[:<<N]:rnd"
+1,1,1,0,0,1,0,0,N,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,-,1,0,d,d,d,d,d,"Rdd=mpy(Rs.H,Rt.L)[:<<N]:rnd"
+1,1,1,0,0,1,0,0,N,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,-,1,1,d,d,d,d,d,"Rdd=mpy(Rs.H,Rt.H)[:<<N]:rnd"
+1,1,1,0,0,1,1,0,N,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,0,x,x,x,x,x,"Rxx+=mpy(Rs.L,Rt.L)[:<<N]"
+1,1,1,0,0,1,1,0,N,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,1,x,x,x,x,x,"Rxx+=mpy(Rs.L,Rt.H)[:<<N]"
+1,1,1,0,0,1,1,0,N,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,0,x,x,x,x,x,"Rxx+=mpy(Rs.H,Rt.L)[:<<N]"
+1,1,1,0,0,1,1,0,N,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,1,x,x,x,x,x,"Rxx+=mpy(Rs.H,Rt.H)[:<<N]"
+1,1,1,0,0,1,1,0,N,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,0,x,x,x,x,x,"Rxx-=mpy(Rs.L,Rt.L)[:<<N]"
+1,1,1,0,0,1,1,0,N,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,1,x,x,x,x,x,"Rxx-=mpy(Rs.L,Rt.H)[:<<N]"
+1,1,1,0,0,1,1,0,N,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,0,x,x,x,x,x,"Rxx-=mpy(Rs.H,Rt.L)[:<<N]"
+1,1,1,0,0,1,1,0,N,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,1,x,x,x,x,x,"Rxx-=mpy(Rs.H,Rt.H)[:<<N]"
+1,1,1,0,1,1,0,0,N,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,0,d,d,d,d,d,"Rd=mpy(Rs.L,Rt.L)[:<<N]"
+1,1,1,0,1,1,0,0,N,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,1,d,d,d,d,d,"Rd=mpy(Rs.L,Rt.H)[:<<N]"
+1,1,1,0,1,1,0,0,N,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,0,d,d,d,d,d,"Rd=mpy(Rs.H,Rt.L)[:<<N]"
+1,1,1,0,1,1,0,0,N,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,1,d,d,d,d,d,"Rd=mpy(Rs.H,Rt.H)[:<<N]"
+1,1,1,0,1,1,0,0,N,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,0,d,d,d,d,d,"Rd=mpy(Rs.L,Rt.L)[:<<N]:sat"
+1,1,1,0,1,1,0,0,N,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,1,d,d,d,d,d,"Rd=mpy(Rs.L,Rt.H)[:<<N]:sat"
+1,1,1,0,1,1,0,0,N,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,0,d,d,d,d,d,"Rd=mpy(Rs.H,Rt.L)[:<<N]:sat"
+1,1,1,0,1,1,0,0,N,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,1,d,d,d,d,d,"Rd=mpy(Rs.H,Rt.H)[:<<N]:sat"
+1,1,1,0,1,1,0,0,N,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,0,d,d,d,d,d,"Rd=mpy(Rs.L,Rt.L)[:<<N]:rnd"
+1,1,1,0,1,1,0,0,N,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,1,d,d,d,d,d,"Rd=mpy(Rs.L,Rt.H)[:<<N]:rnd"
+1,1,1,0,1,1,0,0,N,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,0,d,d,d,d,d,"Rd=mpy(Rs.H,Rt.L)[:<<N]:rnd"
+1,1,1,0,1,1,0,0,N,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,1,d,d,d,d,d,"Rd=mpy(Rs.H,Rt.H)[:<<N]:rnd"
+1,1,1,0,1,1,0,0,N,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,0,d,d,d,d,d,"Rd=mpy(Rs.L,Rt.L)[:<<N]:rnd:sat"
+1,1,1,0,1,1,0,0,N,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,1,d,d,d,d,d,"Rd=mpy(Rs.L,Rt.H)[:<<N]:rnd:sat"
+1,1,1,0,1,1,0,0,N,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,0,d,d,d,d,d,"Rd=mpy(Rs.H,Rt.L)[:<<N]:rnd:sat"
+1,1,1,0,1,1,0,0,N,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,1,d,d,d,d,d,"Rd=mpy(Rs.H,Rt.H)[:<<N]:rnd:sat"
+1,1,1,0,1,1,1,0,N,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,0,x,x,x,x,x,"Rx+=mpy(Rs.L,Rt.L)[:<<N]"
+1,1,1,0,1,1,1,0,N,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,1,x,x,x,x,x,"Rx+=mpy(Rs.L,Rt.H)[:<<N]"
+1,1,1,0,1,1,1,0,N,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,0,x,x,x,x,x,"Rx+=mpy(Rs.H,Rt.L)[:<<N]"
+1,1,1,0,1,1,1,0,N,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,1,x,x,x,x,x,"Rx+=mpy(Rs.H,Rt.H)[:<<N]"
+1,1,1,0,1,1,1,0,N,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,0,x,x,x,x,x,"Rx+=mpy(Rs.L,Rt.L)[:<<N]:sat"
+1,1,1,0,1,1,1,0,N,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,1,x,x,x,x,x,"Rx+=mpy(Rs.L,Rt.H)[:<<N]:sat"
+1,1,1,0,1,1,1,0,N,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,0,x,x,x,x,x,"Rx+=mpy(Rs.H,Rt.L)[:<<N]:sat"
+1,1,1,0,1,1,1,0,N,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,1,x,x,x,x,x,"Rx+=mpy(Rs.H,Rt.H)[:<<N]:sat"
+1,1,1,0,1,1,1,0,N,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,0,x,x,x,x,x,"Rx-=mpy(Rs.L,Rt.L)[:<<N]"
+1,1,1,0,1,1,1,0,N,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,1,x,x,x,x,x,"Rx-=mpy(Rs.L,Rt.H)[:<<N]"
+1,1,1,0,1,1,1,0,N,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,0,x,x,x,x,x,"Rx-=mpy(Rs.H,Rt.L)[:<<N]"
+1,1,1,0,1,1,1,0,N,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,1,x,x,x,x,x,"Rx-=mpy(Rs.H,Rt.H)[:<<N]"
+1,1,1,0,1,1,1,0,N,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,0,x,x,x,x,x,"Rx-=mpy(Rs.L,Rt.L)[:<<N]:sat"
+1,1,1,0,1,1,1,0,N,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,1,x,x,x,x,x,"Rx-=mpy(Rs.L,Rt.H)[:<<N]:sat"
+1,1,1,0,1,1,1,0,N,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,0,x,x,x,x,x,"Rx-=mpy(Rs.H,Rt.L)[:<<N]:sat"
+1,1,1,0,1,1,1,0,N,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,1,x,x,x,x,x,"Rx-=mpy(Rs.H,Rt.H)[:<<N]:sat"
+1,1,1,0,0,1,0,0,N,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,-,0,0,d,d,d,d,d,"Rdd=mpyu(Rs.L,Rt.L)[:<<N]"
+1,1,1,0,0,1,0,0,N,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,-,0,1,d,d,d,d,d,"Rdd=mpyu(Rs.L,Rt.H)[:<<N]"
+1,1,1,0,0,1,0,0,N,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,-,1,0,d,d,d,d,d,"Rdd=mpyu(Rs.H,Rt.L)[:<<N]"
+1,1,1,0,0,1,0,0,N,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,-,1,1,d,d,d,d,d,"Rdd=mpyu(Rs.H,Rt.H)[:<<N]"
+1,1,1,0,0,1,1,0,N,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,0,x,x,x,x,x,"Rxx+=mpyu(Rs.L,Rt.L)[:<<N]"
+1,1,1,0,0,1,1,0,N,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,1,x,x,x,x,x,"Rxx+=mpyu(Rs.L,Rt.H)[:<<N]"
+1,1,1,0,0,1,1,0,N,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,0,x,x,x,x,x,"Rxx+=mpyu(Rs.H,Rt.L)[:<<N]"
+1,1,1,0,0,1,1,0,N,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,1,x,x,x,x,x,"Rxx+=mpyu(Rs.H,Rt.H)[:<<N]"
+1,1,1,0,0,1,1,0,N,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,0,x,x,x,x,x,"Rxx-=mpyu(Rs.L,Rt.L)[:<<N]"
+1,1,1,0,0,1,1,0,N,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,1,x,x,x,x,x,"Rxx-=mpyu(Rs.L,Rt.H)[:<<N]"
+1,1,1,0,0,1,1,0,N,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,0,x,x,x,x,x,"Rxx-=mpyu(Rs.H,Rt.L)[:<<N]"
+1,1,1,0,0,1,1,0,N,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,1,x,x,x,x,x,"Rxx-=mpyu(Rs.H,Rt.H)[:<<N]"
+1,1,1,0,1,1,0,0,N,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,0,d,d,d,d,d,"Rd=mpyu(Rs.L,Rt.L)[:<<N]"
+1,1,1,0,1,1,0,0,N,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,1,d,d,d,d,d,"Rd=mpyu(Rs.L,Rt.H)[:<<N]"
+1,1,1,0,1,1,0,0,N,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,0,d,d,d,d,d,"Rd=mpyu(Rs.H,Rt.L)[:<<N]"
+1,1,1,0,1,1,0,0,N,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,1,d,d,d,d,d,"Rd=mpyu(Rs.H,Rt.H)[:<<N]"
+1,1,1,0,1,1,1,0,N,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,0,x,x,x,x,x,"Rx+=mpyu(Rs.L,Rt.L)[:<<N]"
+1,1,1,0,1,1,1,0,N,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,1,x,x,x,x,x,"Rx+=mpyu(Rs.L,Rt.H)[:<<N]"
+1,1,1,0,1,1,1,0,N,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,0,x,x,x,x,x,"Rx+=mpyu(Rs.H,Rt.L)[:<<N]"
+1,1,1,0,1,1,1,0,N,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,1,x,x,x,x,x,"Rx+=mpyu(Rs.H,Rt.H)[:<<N]"
+1,1,1,0,1,1,1,0,N,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,0,x,x,x,x,x,"Rx-=mpyu(Rs.L,Rt.L)[:<<N]"
+1,1,1,0,1,1,1,0,N,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,1,x,x,x,x,x,"Rx-=mpyu(Rs.L,Rt.H)[:<<N]"
+1,1,1,0,1,1,1,0,N,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,0,x,x,x,x,x,"Rx-=mpyu(Rs.H,Rt.L)[:<<N]"
+1,1,1,0,1,1,1,0,N,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,1,x,x,x,x,x,"Rx-=mpyu(Rs.H,Rt.H)[:<<N]"
+1,1,1,0,0,1,0,1,0,1,0,s,s,s,s,s,P,P,0,t,t,t,t,t,1,1,1,d,d,d,d,d,"Rdd=pmpyw(Rs,Rt)"
+1,1,1,0,0,1,1,1,0,0,1,s,s,s,s,s,P,P,0,t,t,t,t,t,1,1,1,x,x,x,x,x,"Rxx^=pmpyw(Rs,Rt)"
+1,1,1,0,1,0,0,0,N,0,1,s,s,s,s,s,P,P,0,t,t,t,t,t,0,1,0,d,d,d,d,d,"Rdd=vrmpywoh(Rss,Rtt)[:<<N]"
+1,1,1,0,1,0,0,0,N,1,0,s,s,s,s,s,P,P,0,t,t,t,t,t,1,0,0,d,d,d,d,d,"Rdd=vrmpyweh(Rss,Rtt)[:<<N]"
+1,1,1,0,1,0,1,0,N,0,1,s,s,s,s,s,P,P,0,t,t,t,t,t,1,1,0,x,x,x,x,x,"Rxx+=vrmpyweh(Rss,Rtt)[:<<N]"
+1,1,1,0,1,0,1,0,N,1,1,s,s,s,s,s,P,P,0,t,t,t,t,t,1,1,0,x,x,x,x,x,"Rxx+=vrmpywoh(Rss,Rtt)[:<<N]"
+1,1,1,0,1,1,0,1,0,0,1,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,1,d,d,d,d,d,"Rd=mpy(Rs,Rt):rnd"
+1,1,1,0,1,1,0,1,0,1,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,1,d,d,d,d,d,"Rd=mpyu(Rs,Rt)"
+1,1,1,0,1,1,0,1,0,1,1,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,1,d,d,d,d,d,"Rd=mpysu(Rs,Rt)"
+1,1,1,0,1,1,0,1,1,0,1,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,0,d,d,d,d,d,"Rd=mpy(Rs,Rt.H):<<1:sat"
+1,1,1,0,1,1,0,1,1,0,1,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,1,d,d,d,d,d,"Rd=mpy(Rs,Rt.L):<<1:sat"
+1,1,1,0,1,1,0,1,1,0,1,s,s,s,s,s,P,P,0,t,t,t,t,t,1,0,0,d,d,d,d,d,"Rd=mpy(Rs,Rt.H):<<1:rnd:sat"
+1,1,1,0,1,1,0,1,1,1,1,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,0,d,d,d,d,d,"Rd=mpy(Rs,Rt):<<1:sat"
+1,1,1,0,1,1,0,1,1,1,1,s,s,s,s,s,P,P,0,t,t,t,t,t,1,0,0,d,d,d,d,d,"Rd=mpy(Rs,Rt.L):<<1:rnd:sat"
+1,1,1,0,1,1,0,1,0,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,1,d,d,d,d,d,"Rd=mpy(Rs,Rt)"
+1,1,1,0,1,1,0,1,1,0,1,s,s,s,s,s,P,P,0,t,t,t,t,t,0,1,0,d,d,d,d,d,"Rd=mpy(Rs,Rt):<<1"
+1,1,1,0,1,1,1,1,0,1,1,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,0,x,x,x,x,x,"Rx+=mpy(Rs,Rt):<<1:sat"
+1,1,1,0,1,1,1,1,0,1,1,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,1,x,x,x,x,x,"Rx-=mpy(Rs,Rt):<<1:sat"
+1,1,1,0,0,1,0,1,0,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,0,d,d,d,d,d,"Rdd=mpy(Rs,Rt)"
+1,1,1,0,0,1,0,1,0,1,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,0,d,d,d,d,d,"Rdd=mpyu(Rs,Rt)"
+1,1,1,0,0,1,1,1,0,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,0,x,x,x,x,x,"Rxx+=mpy(Rs,Rt)"
+1,1,1,0,0,1,1,1,0,0,1,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,0,x,x,x,x,x,"Rxx-=mpy(Rs,Rt)"
+1,1,1,0,0,1,1,1,0,1,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,0,x,x,x,x,x,"Rxx+=mpyu(Rs,Rt)"
+1,1,1,0,0,1,1,1,0,1,1,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,0,x,x,x,x,x,"Rxx-=mpyu(Rs,Rt)"
+1,1,1,0,1,0,0,0,N,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,1,0,0,d,d,d,d,d,"Rdd=vdmpy(Rss,Rtt)[:<<N]:sat"
+1,1,1,0,1,0,1,0,N,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,1,0,0,x,x,x,x,x,"Rxx+=vdmpy(Rss,Rtt)[:<<N]:sat"
+1,1,1,0,1,0,0,1,N,-,-,s,s,s,s,s,P,P,0,t,t,t,t,t,-,0,0,d,d,d,d,d,"Rd=vdmpy(Rss,Rtt)[:<<N]:rnd:sat"
+1,1,1,0,1,0,0,0,1,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,1,d,d,d,d,d,"Rdd=vrmpybu(Rss,Rtt)"
+1,1,1,0,1,0,0,0,1,1,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,1,d,d,d,d,d,"Rdd=vrmpybsu(Rss,Rtt)"
+1,1,1,0,1,0,1,0,1,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,1,x,x,x,x,x,"Rxx+=vrmpybu(Rss,Rtt)"
+1,1,1,0,1,0,1,0,1,1,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,1,x,x,x,x,x,"Rxx+=vrmpybsu(Rss,Rtt)"
+1,1,1,0,1,0,0,0,1,0,1,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,1,d,d,d,d,d,"Rdd=vdmpybsu(Rss,Rtt):sat"
+1,1,1,0,1,0,1,0,0,0,1,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,1,x,x,x,x,x,"Rxx+=vdmpybsu(Rss,Rtt):sat"
+1,1,1,0,1,0,0,0,N,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,1,1,0,d,d,d,d,d,"Rdd=vmpyeh(Rss,Rtt)[:<<N]:sat"
+1,1,1,0,1,0,1,0,0,0,1,s,s,s,s,s,P,P,0,t,t,t,t,t,0,1,0,x,x,x,x,x,"Rxx+=vmpyeh(Rss,Rtt)"
+1,1,1,0,1,0,1,0,N,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,1,1,0,x,x,x,x,x,"Rxx+=vmpyeh(Rss,Rtt)[:<<N]:sat"
+1,1,1,0,0,1,0,1,N,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,1,0,1,d,d,d,d,d,"Rdd=vmpyh(Rs,Rt)[:<<N]:sat"
+1,1,1,0,0,1,1,1,0,0,1,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,1,x,x,x,x,x,"Rxx+=vmpyh(Rs,Rt)"
+1,1,1,0,0,1,1,1,N,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,1,0,1,x,x,x,x,x,"Rxx+=vmpyh(Rs,Rt)[:<<N]:sat"
+1,1,1,0,1,1,0,1,N,0,1,s,s,s,s,s,P,P,0,t,t,t,t,t,1,1,1,d,d,d,d,d,"Rd=vmpyh(Rs,Rt)[:<<N]:rnd:sat"
+1,1,1,0,0,1,0,1,N,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,1,1,1,d,d,d,d,d,"Rdd=vmpyhsu(Rs,Rt)[:<<N]:sat"
+1,1,1,0,0,1,1,1,N,1,1,s,s,s,s,s,P,P,0,t,t,t,t,t,1,0,1,x,x,x,x,x,"Rxx+=vmpyhsu(Rs,Rt)[:<<N]:sat"
+1,1,1,0,1,0,0,0,0,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,1,0,d,d,d,d,d,"Rdd=vrmpyh(Rss,Rtt)"
+1,1,1,0,1,0,1,0,0,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,1,0,x,x,x,x,x,"Rxx+=vrmpyh(Rss,Rtt)"
+1,1,1,0,0,1,0,1,0,1,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,1,d,d,d,d,d,"Rdd=vmpybsu(Rs,Rt)"
+1,1,1,0,0,1,0,1,1,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,1,d,d,d,d,d,"Rdd=vmpybu(Rs,Rt)"
+1,1,1,0,0,1,1,1,1,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,1,x,x,x,x,x,"Rxx+=vmpybu(Rs,Rt)"
+1,1,1,0,0,1,1,1,1,1,0,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,1,x,x,x,x,x,"Rxx+=vmpybsu(Rs,Rt)"
+1,1,1,0,0,1,0,1,1,1,0,s,s,s,s,s,P,P,0,t,t,t,t,t,1,1,1,d,d,d,d,d,"Rdd=vpmpyh(Rs,Rt)"
+1,1,1,0,0,1,1,1,1,0,1,s,s,s,s,s,P,P,0,t,t,t,t,t,1,1,1,x,x,x,x,x,"Rxx^=vpmpyh(Rs,Rt)"
+1,1,0,0,0,0,0,1,1,1,-,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,-,d,d,d,d,d,"Rdd=decbin(Rss,Rtt)"
+1,0,0,0,1,0,0,0,1,1,0,s,s,s,s,s,P,P,-,-,-,-,-,-,0,0,0,d,d,d,d,d,"Rd=sat(Rss)"
+1,0,0,0,1,1,0,0,1,1,0,s,s,s,s,s,P,P,-,-,-,-,-,-,1,0,0,d,d,d,d,d,"Rd=sath(Rs)"
+1,0,0,0,1,1,0,0,1,1,0,s,s,s,s,s,P,P,-,-,-,-,-,-,1,0,1,d,d,d,d,d,"Rd=satuh(Rs)"
+1,0,0,0,1,1,0,0,1,1,0,s,s,s,s,s,P,P,-,-,-,-,-,-,1,1,0,d,d,d,d,d,"Rd=satub(Rs)"
+1,0,0,0,1,1,0,0,1,1,0,s,s,s,s,s,P,P,-,-,-,-,-,-,1,1,1,d,d,d,d,d,"Rd=satb(Rs)"
+1,0,0,0,1,1,0,0,1,0,0,s,s,s,s,s,P,P,-,-,-,-,-,-,1,1,1,d,d,d,d,d,"Rd=swiz(Rs)"
+1,1,0,0,0,0,0,0,0,-,-,s,s,s,s,s,P,P,-,t,t,t,t,t,j,j,j,d,d,d,d,d,"Rdd=valignb(Rtt,Rss,#u3)"
+1,1,0,0,0,0,1,0,0,-,-,s,s,s,s,s,P,P,-,t,t,t,t,t,-,u,u,d,d,d,d,d,"Rdd=valignb(Rtt,Rss,Pu)"
+1,0,0,0,1,0,0,0,1,0,0,s,s,s,s,s,P,P,-,-,-,-,-,-,1,0,0,d,d,d,d,d,"Rd=vrndwh(Rss)"
+1,0,0,0,1,0,0,0,1,0,0,s,s,s,s,s,P,P,-,-,-,-,-,-,1,1,0,d,d,d,d,d,"Rd=vrndwh(Rss):sat"
+1,0,0,0,1,0,0,0,0,0,0,s,s,s,s,s,P,P,-,-,-,-,-,-,0,0,0,d,d,d,d,d,"Rd=vsathub(Rss)"
+1,0,0,0,1,0,0,0,0,0,0,s,s,s,s,s,P,P,-,-,-,-,-,-,0,1,0,d,d,d,d,d,"Rd=vsatwh(Rss)"
+1,0,0,0,1,0,0,0,0,0,0,s,s,s,s,s,P,P,-,-,-,-,-,-,1,0,0,d,d,d,d,d,"Rd=vsatwuh(Rss)"
+1,0,0,0,1,0,0,0,0,0,0,s,s,s,s,s,P,P,-,-,-,-,-,-,1,1,0,d,d,d,d,d,"Rd=vsathb(Rss)"
+1,0,0,0,1,1,0,0,1,0,-,s,s,s,s,s,P,P,-,-,-,-,-,-,0,0,-,d,d,d,d,d,"Rd=vsathb(Rs)"
+1,0,0,0,1,1,0,0,1,0,-,s,s,s,s,s,P,P,-,-,-,-,-,-,0,1,-,d,d,d,d,d,"Rd=vsathub(Rs)"
+1,0,0,0,0,0,0,0,0,0,0,s,s,s,s,s,P,P,-,-,-,-,-,-,1,0,0,d,d,d,d,d,"Rdd=vsathub(Rss)"
+1,0,0,0,0,0,0,0,0,0,0,s,s,s,s,s,P,P,-,-,-,-,-,-,1,0,1,d,d,d,d,d,"Rdd=vsatwuh(Rss)"
+1,0,0,0,0,0,0,0,0,0,0,s,s,s,s,s,P,P,-,-,-,-,-,-,1,1,0,d,d,d,d,d,"Rdd=vsatwh(Rss)"
+1,0,0,0,0,0,0,0,0,0,0,s,s,s,s,s,P,P,-,-,-,-,-,-,1,1,1,d,d,d,d,d,"Rdd=vsathb(Rss)"
+1,1,0,0,0,0,0,1,0,0,-,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,-,d,d,d,d,d,"Rdd=shuffeb(Rss,Rtt)"
+1,1,0,0,0,0,0,1,0,0,-,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,-,d,d,d,d,d,"Rdd=shuffob(Rtt,Rss)"
+1,1,0,0,0,0,0,1,0,0,-,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,-,d,d,d,d,d,"Rdd=shuffeh(Rss,Rtt)"
+1,1,0,0,0,0,0,1,1,0,-,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,0,d,d,d,d,d,"Rdd=shuffoh(Rtt,Rss)"
+1,0,0,0,0,1,0,0,0,1,-,s,s,s,s,s,P,P,-,-,-,-,-,-,1,0,-,d,d,d,d,d,"Rdd=vsplatb(Rs)"
+1,0,0,0,1,1,0,0,0,1,0,s,s,s,s,s,P,P,-,-,-,-,-,-,1,1,1,d,d,d,d,d,"Rd=vsplatb(Rs)"
+1,0,0,0,0,1,0,0,0,1,-,s,s,s,s,s,P,P,-,-,-,-,-,-,0,1,-,d,d,d,d,d,"Rdd=vsplath(Rs)"
+1,1,0,0,0,0,0,0,1,-,-,s,s,s,s,s,P,P,-,t,t,t,t,t,j,j,j,d,d,d,d,d,"Rdd=vspliceb(Rss,Rtt,#u3)"
+1,1,0,0,0,0,1,0,1,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,-,u,u,d,d,d,d,d,"Rdd=vspliceb(Rss,Rtt,Pu)"
+1,0,0,0,0,1,0,0,0,0,-,s,s,s,s,s,P,P,-,-,-,-,-,-,0,0,-,d,d,d,d,d,"Rdd=vsxtbh(Rs)"
+1,0,0,0,0,1,0,0,0,0,-,s,s,s,s,s,P,P,-,-,-,-,-,-,1,0,-,d,d,d,d,d,"Rdd=vsxthw(Rs)"
+1,0,0,0,1,0,0,0,1,0,0,s,s,s,s,s,P,P,-,-,-,-,-,-,0,0,0,d,d,d,d,d,"Rd=vtrunohb(Rss)"
+1,0,0,0,1,0,0,0,1,0,0,s,s,s,s,s,P,P,-,-,-,-,-,-,0,1,0,d,d,d,d,d,"Rd=vtrunehb(Rss)"
+1,1,0,0,0,0,0,1,1,0,-,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,0,d,d,d,d,d,"Rdd=vtrunewh(Rss,Rtt)"
+1,1,0,0,0,0,0,1,1,0,-,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,1,d,d,d,d,d,"Rdd=vtrunehb(Rss,Rtt)"
+1,1,0,0,0,0,0,1,1,0,-,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,0,d,d,d,d,d,"Rdd=vtrunowh(Rss,Rtt)"
+1,1,0,0,0,0,0,1,1,0,-,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,1,d,d,d,d,d,"Rdd=vtrunohb(Rss,Rtt)"
+1,0,0,0,0,1,0,0,0,0,-,s,s,s,s,s,P,P,-,-,-,-,-,-,0,1,-,d,d,d,d,d,"Rdd=vzxtbh(Rs)"
+1,0,0,0,0,1,0,0,0,0,-,s,s,s,s,s,P,P,-,-,-,-,-,-,1,1,-,d,d,d,d,d,"Rdd=vzxthw(Rs)"
+1,1,0,1,0,0,1,0,0,-,-,s,s,s,s,s,P,P,1,t,t,t,t,t,1,0,0,-,-,-,d,d,"Pd=boundscheck(Rss,Rtt):raw:lo"
+1,1,0,1,0,0,1,0,0,-,-,s,s,s,s,s,P,P,1,t,t,t,t,t,1,0,1,-,-,-,d,d,"Pd=boundscheck(Rss,Rtt):raw:hi"
+1,1,0,0,0,1,1,1,1,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,0,-,-,-,d,d,"Pd=cmpb.gt(Rs,Rt)"
+1,1,0,0,0,1,1,1,1,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,0,-,-,-,d,d,"Pd=cmpb.eq(Rs,Rt)"
+1,1,0,0,0,1,1,1,1,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,1,-,-,-,d,d,"Pd=cmpb.gtu(Rs,Rt)"
+1,1,0,1,1,1,0,1,-,0,0,s,s,s,s,s,P,P,-,j,j,j,j,j,j,j,j,0,0,-,d,d,"Pd=cmpb.eq(Rs,#u8)"
+1,1,0,1,1,1,0,1,-,0,1,s,s,s,s,s,P,P,-,j,j,j,j,j,j,j,j,0,0,-,d,d,"Pd=cmpb.gt(Rs,#s8)"
+1,1,0,1,1,1,0,1,-,1,0,s,s,s,s,s,P,P,-,0,j,j,j,j,j,j,j,0,0,-,d,d,"Pd=cmpb.gtu(Rs,#u7)"
+1,1,0,0,0,1,1,1,1,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,1,-,-,-,d,d,"Pd=cmph.eq(Rs,Rt)"
+1,1,0,0,0,1,1,1,1,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,0,-,-,-,d,d,"Pd=cmph.gt(Rs,Rt)"
+1,1,0,0,0,1,1,1,1,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,1,-,-,-,d,d,"Pd=cmph.gtu(Rs,Rt)"
+1,1,0,1,1,1,0,1,-,0,0,s,s,s,s,s,P,P,-,j,j,j,j,j,j,j,j,0,1,-,d,d,"Pd=cmph.eq(Rs,#s8)"
+1,1,0,1,1,1,0,1,-,0,1,s,s,s,s,s,P,P,-,j,j,j,j,j,j,j,j,0,1,-,d,d,"Pd=cmph.gt(Rs,#s8)"
+1,1,0,1,1,1,0,1,-,1,0,s,s,s,s,s,P,P,-,0,j,j,j,j,j,j,j,0,1,-,d,d,"Pd=cmph.gtu(Rs,#u7)"
+1,1,0,1,0,0,1,0,1,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,0,-,-,-,d,d,"Pd=cmp.eq(Rss,Rtt)"
+1,1,0,1,0,0,1,0,1,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,0,-,-,-,d,d,"Pd=cmp.gt(Rss,Rtt)"
+1,1,0,1,0,0,1,0,1,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,0,-,-,-,d,d,"Pd=cmp.gtu(Rss,Rtt)"
+1,0,0,0,0,1,0,1,1,0,0,s,s,s,s,s,P,P,j,j,j,j,j,j,-,-,-,-,-,-,d,d,"Pd=bitsclr(Rs,#u6)"
+1,0,0,0,0,1,0,1,1,0,1,s,s,s,s,s,P,P,j,j,j,j,j,j,-,-,-,-,-,-,d,d,"Pd=!bitsclr(Rs,#u6)"
+1,1,0,0,0,1,1,1,0,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,-,-,-,d,d,"Pd=bitsset(Rs,Rt)"
+1,1,0,0,0,1,1,1,0,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,-,-,-,d,d,"Pd=!bitsset(Rs,Rt)"
+1,1,0,0,0,1,1,1,1,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,-,-,-,d,d,"Pd=bitsclr(Rs,Rt)"
+1,1,0,0,0,1,1,1,1,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,-,-,-,d,d,"Pd=!bitsclr(Rs,Rt)"
+1,0,0,0,0,1,1,0,-,-,-,-,-,-,-,-,P,P,-,-,-,-,t,t,-,-,-,d,d,d,d,d,"Rdd=mask(Pt)"
+1,1,0,1,0,0,1,0,0,-,-,s,s,s,s,s,P,P,1,t,t,t,t,t,0,1,1,-,-,-,d,d,"Pd=tlbmatch(Rss,Rt)"
+1,0,0,0,0,1,0,1,0,1,0,s,s,s,s,s,P,P,-,-,-,-,-,-,-,-,-,-,-,-,d,d,"Pd=Rs"
+1,0,0,0,1,0,0,1,-,1,-,-,-,-,s,s,P,P,-,-,-,-,-,-,-,-,-,d,d,d,d,d,"Rd=Ps"
+1,0,0,0,0,1,0,1,0,0,0,s,s,s,s,s,P,P,0,j,j,j,j,j,-,-,-,-,-,-,d,d,"Pd=tstbit(Rs,#u5)"
+1,0,0,0,0,1,0,1,0,0,1,s,s,s,s,s,P,P,0,j,j,j,j,j,-,-,-,-,-,-,d,d,"Pd=!tstbit(Rs,#u5)"
+1,1,0,0,0,1,1,1,0,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,-,-,-,d,d,"Pd=tstbit(Rs,Rt)"
+1,1,0,0,0,1,1,1,0,0,1,s,s,s,s,s,P,P,-,t,t,t,t,t,-,-,-,-,-,-,d,d,"Pd=!tstbit(Rs,Rt)"
+1,1,0,1,0,0,1,0,0,-,-,s,s,s,s,s,P,P,0,t,t,t,t,t,0,1,1,-,-,-,d,d,"Pd=vcmph.eq(Rss,Rtt)"
+1,1,0,1,0,0,1,0,0,-,-,s,s,s,s,s,P,P,0,t,t,t,t,t,1,0,0,-,-,-,d,d,"Pd=vcmph.gt(Rss,Rtt)"
+1,1,0,1,0,0,1,0,0,-,-,s,s,s,s,s,P,P,0,t,t,t,t,t,1,0,1,-,-,-,d,d,"Pd=vcmph.gtu(Rss,Rtt)"
+1,1,0,1,1,1,0,0,0,0,0,s,s,s,s,s,P,P,-,j,j,j,j,j,j,j,j,0,1,-,d,d,"Pd=vcmph.eq(Rss,#s8)"
+1,1,0,1,1,1,0,0,0,0,1,s,s,s,s,s,P,P,-,j,j,j,j,j,j,j,j,0,1,-,d,d,"Pd=vcmph.gt(Rss,#s8)"
+1,1,0,1,1,1,0,0,0,1,0,s,s,s,s,s,P,P,-,0,j,j,j,j,j,j,j,0,1,-,d,d,"Pd=vcmph.gtu(Rss,#u7)"
+1,1,0,1,0,0,1,0,0,-,-,s,s,s,s,s,P,P,1,t,t,t,t,t,0,0,0,-,-,-,d,d,"Pd=any8(vcmpb.eq(Rss,Rtt))"
+1,1,0,1,0,0,1,0,0,-,-,s,s,s,s,s,P,P,0,t,t,t,t,t,1,1,0,-,-,-,d,d,"Pd=vcmpb.eq(Rss,Rtt)"
+1,1,0,1,0,0,1,0,0,-,-,s,s,s,s,s,P,P,0,t,t,t,t,t,1,1,1,-,-,-,d,d,"Pd=vcmpb.gtu(Rss,Rtt)"
+1,1,0,1,0,0,1,0,0,-,-,s,s,s,s,s,P,P,1,t,t,t,t,t,0,1,0,-,-,-,d,d,"Pd=vcmpb.gt(Rss,Rtt)"
+1,1,0,1,1,1,0,0,0,0,0,s,s,s,s,s,P,P,-,j,j,j,j,j,j,j,j,0,0,-,d,d,"Pd=vcmpb.eq(Rss,#u8)"
+1,1,0,1,1,1,0,0,0,0,1,s,s,s,s,s,P,P,-,j,j,j,j,j,j,j,j,0,0,-,d,d,"Pd=vcmpb.gt(Rss,#s8)"
+1,1,0,1,1,1,0,0,0,1,0,s,s,s,s,s,P,P,-,0,j,j,j,j,j,j,j,0,0,-,d,d,"Pd=vcmpb.gtu(Rss,#u7)"
+1,1,0,1,0,0,1,0,0,-,-,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,0,-,-,-,d,d,"Pd=vcmpw.eq(Rss,Rtt)"
+1,1,0,1,0,0,1,0,0,-,-,s,s,s,s,s,P,P,0,t,t,t,t,t,0,0,1,-,-,-,d,d,"Pd=vcmpw.gt(Rss,Rtt)"
+1,1,0,1,0,0,1,0,0,-,-,s,s,s,s,s,P,P,0,t,t,t,t,t,0,1,0,-,-,-,d,d,"Pd=vcmpw.gtu(Rss,Rtt)"
+1,1,0,1,1,1,0,0,0,0,0,s,s,s,s,s,P,P,-,j,j,j,j,j,j,j,j,1,0,-,d,d,"Pd=vcmpw.eq(Rss,#s8)"
+1,1,0,1,1,1,0,0,0,0,1,s,s,s,s,s,P,P,-,j,j,j,j,j,j,j,j,1,0,-,d,d,"Pd=vcmpw.gt(Rss,#s8)"
+1,1,0,1,1,1,0,0,0,1,0,s,s,s,s,s,P,P,-,0,j,j,j,j,j,j,j,1,0,-,d,d,"Pd=vcmpw.gtu(Rss,#u7)"
+1,0,0,0,1,0,0,1,-,0,0,-,-,-,s,s,P,P,-,-,-,-,t,t,-,-,-,d,d,d,d,d,"Rd=vitpack(Ps,Pt)"
+1,1,0,1,0,0,0,1,-,-,-,s,s,s,s,s,P,P,-,t,t,t,t,t,-,u,u,d,d,d,d,d,"Rdd=vmux(Pu,Rss,Rtt)"
+1,0,0,0,0,0,0,0,0,0,0,s,s,s,s,s,P,P,j,j,j,j,j,j,0,0,0,d,d,d,d,d,"Rdd=asr(Rss,#u6)"
+1,0,0,0,0,0,0,0,0,0,0,s,s,s,s,s,P,P,j,j,j,j,j,j,0,0,1,d,d,d,d,d,"Rdd=lsr(Rss,#u6)"
+1,0,0,0,0,0,0,0,0,0,0,s,s,s,s,s,P,P,j,j,j,j,j,j,0,1,0,d,d,d,d,d,"Rdd=asl(Rss,#u6)"
+1,0,0,0,0,0,0,0,0,0,0,s,s,s,s,s,P,P,j,j,j,j,j,j,0,1,1,d,d,d,d,d,"Rdd=rol(Rss,#u6)"
+1,0,0,0,1,1,0,0,0,0,0,s,s,s,s,s,P,P,0,j,j,j,j,j,0,0,0,d,d,d,d,d,"Rd=asr(Rs,#u5)"
+1,0,0,0,1,1,0,0,0,0,0,s,s,s,s,s,P,P,0,j,j,j,j,j,0,0,1,d,d,d,d,d,"Rd=lsr(Rs,#u5)"
+1,0,0,0,1,1,0,0,0,0,0,s,s,s,s,s,P,P,0,j,j,j,j,j,0,1,0,d,d,d,d,d,"Rd=asl(Rs,#u5)"
+1,0,0,0,1,1,0,0,0,0,0,s,s,s,s,s,P,P,0,j,j,j,j,j,0,1,1,d,d,d,d,d,"Rd=rol(Rs,#u5)"
+1,0,0,0,0,0,1,0,0,0,-,s,s,s,s,s,P,P,j,j,j,j,j,j,0,0,0,x,x,x,x,x,"Rxx-=asr(Rss,#u6)"
+1,0,0,0,0,0,1,0,0,0,-,s,s,s,s,s,P,P,j,j,j,j,j,j,0,0,1,x,x,x,x,x,"Rxx-=lsr(Rss,#u6)"
+1,0,0,0,0,0,1,0,0,0,-,s,s,s,s,s,P,P,j,j,j,j,j,j,0,1,0,x,x,x,x,x,"Rxx-=asl(Rss,#u6)"
+1,0,0,0,0,0,1,0,0,0,-,s,s,s,s,s,P,P,j,j,j,j,j,j,0,1,1,x,x,x,x,x,"Rxx-=rol(Rss,#u6)"
+1,0,0,0,0,0,1,0,0,0,-,s,s,s,s,s,P,P,j,j,j,j,j,j,1,0,0,x,x,x,x,x,"Rxx+=asr(Rss,#u6)"
+1,0,0,0,0,0,1,0,0,0,-,s,s,s,s,s,P,P,j,j,j,j,j,j,1,0,1,x,x,x,x,x,"Rxx+=lsr(Rss,#u6)"
+1,0,0,0,0,0,1,0,0,0,-,s,s,s,s,s,P,P,j,j,j,j,j,j,1,1,0,x,x,x,x,x,"Rxx+=asl(Rss,#u6)"
+1,0,0,0,0,0,1,0,0,0,-,s,s,s,s,s,P,P,j,j,j,j,j,j,1,1,1,x,x,x,x,x,"Rxx+=rol(Rss,#u6)"
+1,0,0,0,1,1,1,0,0,0,-,s,s,s,s,s,P,P,0,j,j,j,j,j,0,0,0,x,x,x,x,x,"Rx-=asr(Rs,#u5)"
+1,0,0,0,1,1,1,0,0,0,-,s,s,s,s,s,P,P,0,j,j,j,j,j,0,0,1,x,x,x,x,x,"Rx-=lsr(Rs,#u5)"
+1,0,0,0,1,1,1,0,0,0,-,s,s,s,s,s,P,P,0,j,j,j,j,j,0,1,0,x,x,x,x,x,"Rx-=asl(Rs,#u5)"
+1,0,0,0,1,1,1,0,0,0,-,s,s,s,s,s,P,P,0,j,j,j,j,j,0,1,1,x,x,x,x,x,"Rx-=rol(Rs,#u5)"
+1,0,0,0,1,1,1,0,0,0,-,s,s,s,s,s,P,P,0,j,j,j,j,j,1,0,0,x,x,x,x,x,"Rx+=asr(Rs,#u5)"
+1,0,0,0,1,1,1,0,0,0,-,s,s,s,s,s,P,P,0,j,j,j,j,j,1,0,1,x,x,x,x,x,"Rx+=lsr(Rs,#u5)"
+1,0,0,0,1,1,1,0,0,0,-,s,s,s,s,s,P,P,0,j,j,j,j,j,1,1,0,x,x,x,x,x,"Rx+=asl(Rs,#u5)"
+1,0,0,0,1,1,1,0,0,0,-,s,s,s,s,s,P,P,0,j,j,j,j,j,1,1,1,x,x,x,x,x,"Rx+=rol(Rs,#u5)"
+1,1,0,1,1,1,1,0,j,j,j,x,x,x,x,x,P,P,j,I,I,I,I,I,j,j,j,0,j,1,0,-,"Rx=add(#u8,asl(Rx,#U5))"
+1,1,0,1,1,1,1,0,j,j,j,x,x,x,x,x,P,P,j,I,I,I,I,I,j,j,j,0,j,1,1,-,"Rx=sub(#u8,asl(Rx,#U5))"
+1,1,0,1,1,1,1,0,j,j,j,x,x,x,x,x,P,P,j,I,I,I,I,I,j,j,j,1,j,1,0,-,"Rx=add(#u8,lsr(Rx,#U5))"
+1,1,0,1,1,1,1,0,j,j,j,x,x,x,x,x,P,P,j,I,I,I,I,I,j,j,j,1,j,1,1,-,"Rx=sub(#u8,lsr(Rx,#U5))"
+1,1,0,0,0,1,0,0,0,0,0,s,s,s,s,s,P,P,0,t,t,t,t,t,j,j,j,d,d,d,d,d,"Rd=addasl(Rt,Rs,#u3)"
+1,0,0,0,0,0,1,0,0,1,-,s,s,s,s,s,P,P,j,j,j,j,j,j,0,0,0,x,x,x,x,x,"Rxx&=asr(Rss,#u6)"
+1,0,0,0,0,0,1,0,0,1,-,s,s,s,s,s,P,P,j,j,j,j,j,j,0,0,1,x,x,x,x,x,"Rxx&=lsr(Rss,#u6)"
+1,0,0,0,0,0,1,0,0,1,-,s,s,s,s,s,P,P,j,j,j,j,j,j,0,1,0,x,x,x,x,x,"Rxx&=asl(Rss,#u6)"
+1,0,0,0,0,0,1,0,0,1,-,s,s,s,s,s,P,P,j,j,j,j,j,j,0,1,1,x,x,x,x,x,"Rxx&=rol(Rss,#u6)"
+1,0,0,0,0,0,1,0,0,1,-,s,s,s,s,s,P,P,j,j,j,j,j,j,1,0,0,x,x,x,x,x,"Rxx|=asr(Rss,#u6)"
+1,0,0,0,0,0,1,0,0,1,-,s,s,s,s,s,P,P,j,j,j,j,j,j,1,0,1,x,x,x,x,x,"Rxx|=lsr(Rss,#u6)"
+1,0,0,0,0,0,1,0,0,1,-,s,s,s,s,s,P,P,j,j,j,j,j,j,1,1,0,x,x,x,x,x,"Rxx|=asl(Rss,#u6)"
+1,0,0,0,0,0,1,0,0,1,-,s,s,s,s,s,P,P,j,j,j,j,j,j,1,1,1,x,x,x,x,x,"Rxx|=rol(Rss,#u6)"
+1,0,0,0,0,0,1,0,1,0,-,s,s,s,s,s,P,P,j,j,j,j,j,j,0,0,1,x,x,x,x,x,"Rxx^=lsr(Rss,#u6)"
+1,0,0,0,0,0,1,0,1,0,-,s,s,s,s,s,P,P,j,j,j,j,j,j,0,1,0,x,x,x,x,x,"Rxx^=asl(Rss,#u6)"
+1,0,0,0,0,0,1,0,1,0,-,s,s,s,s,s,P,P,j,j,j,j,j,j,0,1,1,x,x,x,x,x,"Rxx^=rol(Rss,#u6)"
+1,0,0,0,1,1,1,0,0,1,-,s,s,s,s,s,P,P,0,j,j,j,j,j,0,0,0,x,x,x,x,x,"Rx&=asr(Rs,#u5)"
+1,0,0,0,1,1,1,0,0,1,-,s,s,s,s,s,P,P,0,j,j,j,j,j,0,0,1,x,x,x,x,x,"Rx&=lsr(Rs,#u5)"
+1,0,0,0,1,1,1,0,0,1,-,s,s,s,s,s,P,P,0,j,j,j,j,j,0,1,0,x,x,x,x,x,"Rx&=asl(Rs,#u5)"
+1,0,0,0,1,1,1,0,0,1,-,s,s,s,s,s,P,P,0,j,j,j,j,j,0,1,1,x,x,x,x,x,"Rx&=rol(Rs,#u5)"
+1,0,0,0,1,1,1,0,0,1,-,s,s,s,s,s,P,P,0,j,j,j,j,j,1,0,0,x,x,x,x,x,"Rx|=asr(Rs,#u5)"
+1,0,0,0,1,1,1,0,0,1,-,s,s,s,s,s,P,P,0,j,j,j,j,j,1,0,1,x,x,x,x,x,"Rx|=lsr(Rs,#u5)"
+1,0,0,0,1,1,1,0,0,1,-,s,s,s,s,s,P,P,0,j,j,j,j,j,1,1,0,x,x,x,x,x,"Rx|=asl(Rs,#u5)"
+1,0,0,0,1,1,1,0,0,1,-,s,s,s,s,s,P,P,0,j,j,j,j,j,1,1,1,x,x,x,x,x,"Rx|=rol(Rs,#u5)"
+1,0,0,0,1,1,1,0,1,0,-,s,s,s,s,s,P,P,0,j,j,j,j,j,0,0,1,x,x,x,x,x,"Rx^=lsr(Rs,#u5)"
+1,0,0,0,1,1,1,0,1,0,-,s,s,s,s,s,P,P,0,j,j,j,j,j,0,1,0,x,x,x,x,x,"Rx^=asl(Rs,#u5)"
+1,0,0,0,1,1,1,0,1,0,-,s,s,s,s,s,P,P,0,j,j,j,j,j,0,1,1,x,x,x,x,x,"Rx^=rol(Rs,#u5)"
+1,1,0,1,1,1,1,0,j,j,j,x,x,x,x,x,P,P,j,I,I,I,I,I,j,j,j,0,j,0,0,-,"Rx=and(#u8,asl(Rx,#U5))"
+1,1,0,1,1,1,1,0,j,j,j,x,x,x,x,x,P,P,j,I,I,I,I,I,j,j,j,0,j,0,1,-,"Rx=or(#u8,asl(Rx,#U5))"
+1,1,0,1,1,1,1,0,j,j,j,x,x,x,x,x,P,P,j,I,I,I,I,I,j,j,j,1,j,0,0,-,"Rx=and(#u8,lsr(Rx,#U5))"
+1,1,0,1,1,1,1,0,j,j,j,x,x,x,x,x,P,P,j,I,I,I,I,I,j,j,j,1,j,0,1,-,"Rx=or(#u8,lsr(Rx,#U5))"
+1,0,0,0,0,0,0,0,1,1,0,s,s,s,s,s,P,P,j,j,j,j,j,j,1,1,1,d,d,d,d,d,"Rdd=asr(Rss,#u6):rnd"
+1,0,0,0,1,1,0,0,0,1,0,s,s,s,s,s,P,P,0,j,j,j,j,j,0,0,0,d,d,d,d,d,"Rd=asr(Rs,#u5):rnd"
+1,0,0,0,1,1,0,0,0,1,0,s,s,s,s,s,P,P,0,j,j,j,j,j,0,1,0,d,d,d,d,d,"Rd=asl(Rs,#u5):sat"
+1,1,0,0,0,0,1,1,1,0,-,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,-,d,d,d,d,d,"Rdd=asr(Rss,Rt)"
+1,1,0,0,0,0,1,1,1,0,-,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,-,d,d,d,d,d,"Rdd=lsr(Rss,Rt)"
+1,1,0,0,0,0,1,1,1,0,-,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,-,d,d,d,d,d,"Rdd=asl(Rss,Rt)"
+1,1,0,0,0,0,1,1,1,0,-,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,-,d,d,d,d,d,"Rdd=lsl(Rss,Rt)"
+1,1,0,0,0,1,1,0,0,1,-,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,-,d,d,d,d,d,"Rd=asr(Rs,Rt)"
+1,1,0,0,0,1,1,0,0,1,-,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,-,d,d,d,d,d,"Rd=lsr(Rs,Rt)"
+1,1,0,0,0,1,1,0,0,1,-,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,-,d,d,d,d,d,"Rd=asl(Rs,Rt)"
+1,1,0,0,0,1,1,0,0,1,-,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,-,d,d,d,d,d,"Rd=lsl(Rs,Rt)"
+1,1,0,0,0,1,1,0,1,0,-,j,j,j,j,j,P,P,-,t,t,t,t,t,1,1,j,d,d,d,d,d,"Rd=lsl(#s6,Rt)"
+1,1,0,0,1,0,1,1,1,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,-,x,x,x,x,x,"Rxx-=asr(Rss,Rt)"
+1,1,0,0,1,0,1,1,1,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,-,x,x,x,x,x,"Rxx-=lsr(Rss,Rt)"
+1,1,0,0,1,0,1,1,1,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,-,x,x,x,x,x,"Rxx-=asl(Rss,Rt)"
+1,1,0,0,1,0,1,1,1,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,-,x,x,x,x,x,"Rxx-=lsl(Rss,Rt)"
+1,1,0,0,1,0,1,1,1,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,-,x,x,x,x,x,"Rxx+=asr(Rss,Rt)"
+1,1,0,0,1,0,1,1,1,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,-,x,x,x,x,x,"Rxx+=lsr(Rss,Rt)"
+1,1,0,0,1,0,1,1,1,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,-,x,x,x,x,x,"Rxx+=asl(Rss,Rt)"
+1,1,0,0,1,0,1,1,1,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,-,x,x,x,x,x,"Rxx+=lsl(Rss,Rt)"
+1,1,0,0,1,1,0,0,1,0,-,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,-,x,x,x,x,x,"Rx-=asr(Rs,Rt)"
+1,1,0,0,1,1,0,0,1,0,-,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,-,x,x,x,x,x,"Rx-=lsr(Rs,Rt)"
+1,1,0,0,1,1,0,0,1,0,-,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,-,x,x,x,x,x,"Rx-=asl(Rs,Rt)"
+1,1,0,0,1,1,0,0,1,0,-,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,-,x,x,x,x,x,"Rx-=lsl(Rs,Rt)"
+1,1,0,0,1,1,0,0,1,1,-,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,-,x,x,x,x,x,"Rx+=asr(Rs,Rt)"
+1,1,0,0,1,1,0,0,1,1,-,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,-,x,x,x,x,x,"Rx+=lsr(Rs,Rt)"
+1,1,0,0,1,1,0,0,1,1,-,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,-,x,x,x,x,x,"Rx+=asl(Rs,Rt)"
+1,1,0,0,1,1,0,0,1,1,-,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,-,x,x,x,x,x,"Rx+=lsl(Rs,Rt)"
+1,1,0,0,1,0,1,1,0,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,-,x,x,x,x,x,"Rxx|=asr(Rss,Rt)"
+1,1,0,0,1,0,1,1,0,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,-,x,x,x,x,x,"Rxx|=lsr(Rss,Rt)"
+1,1,0,0,1,0,1,1,0,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,-,x,x,x,x,x,"Rxx|=asl(Rss,Rt)"
+1,1,0,0,1,0,1,1,0,0,0,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,-,x,x,x,x,x,"Rxx|=lsl(Rss,Rt)"
+1,1,0,0,1,0,1,1,0,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,-,x,x,x,x,x,"Rxx&=asr(Rss,Rt)"
+1,1,0,0,1,0,1,1,0,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,-,x,x,x,x,x,"Rxx&=lsr(Rss,Rt)"
+1,1,0,0,1,0,1,1,0,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,-,x,x,x,x,x,"Rxx&=asl(Rss,Rt)"
+1,1,0,0,1,0,1,1,0,1,0,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,-,x,x,x,x,x,"Rxx&=lsl(Rss,Rt)"
+1,1,0,0,1,0,1,1,0,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,-,x,x,x,x,x,"Rxx^=asr(Rss,Rt)"
+1,1,0,0,1,0,1,1,0,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,-,x,x,x,x,x,"Rxx^=lsr(Rss,Rt)"
+1,1,0,0,1,0,1,1,0,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,-,x,x,x,x,x,"Rxx^=asl(Rss,Rt)"
+1,1,0,0,1,0,1,1,0,1,1,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,-,x,x,x,x,x,"Rxx^=lsl(Rss,Rt)"
+1,1,0,0,1,1,0,0,0,0,-,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,-,x,x,x,x,x,"Rx|=asr(Rs,Rt)"
+1,1,0,0,1,1,0,0,0,0,-,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,-,x,x,x,x,x,"Rx|=lsr(Rs,Rt)"
+1,1,0,0,1,1,0,0,0,0,-,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,-,x,x,x,x,x,"Rx|=asl(Rs,Rt)"
+1,1,0,0,1,1,0,0,0,0,-,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,-,x,x,x,x,x,"Rx|=lsl(Rs,Rt)"
+1,1,0,0,1,1,0,0,0,1,-,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,-,x,x,x,x,x,"Rx&=asr(Rs,Rt)"
+1,1,0,0,1,1,0,0,0,1,-,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,-,x,x,x,x,x,"Rx&=lsr(Rs,Rt)"
+1,1,0,0,1,1,0,0,0,1,-,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,-,x,x,x,x,x,"Rx&=asl(Rs,Rt)"
+1,1,0,0,1,1,0,0,0,1,-,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,-,x,x,x,x,x,"Rx&=lsl(Rs,Rt)"
+1,1,0,0,0,1,1,0,0,0,-,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,-,d,d,d,d,d,"Rd=asr(Rs,Rt):sat"
+1,1,0,0,0,1,1,0,0,0,-,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,-,d,d,d,d,d,"Rd=asl(Rs,Rt):sat"
+1,0,0,0,0,0,0,0,1,0,0,s,s,s,s,s,P,P,0,0,j,j,j,j,0,0,0,d,d,d,d,d,"Rdd=vasrh(Rss,#u4)"
+1,0,0,0,0,0,0,0,1,0,0,s,s,s,s,s,P,P,0,0,j,j,j,j,0,0,1,d,d,d,d,d,"Rdd=vlsrh(Rss,#u4)"
+1,0,0,0,0,0,0,0,1,0,0,s,s,s,s,s,P,P,0,0,j,j,j,j,0,1,0,d,d,d,d,d,"Rdd=vaslh(Rss,#u4)"
+1,0,0,0,0,0,0,0,0,0,1,s,s,s,s,s,P,P,0,0,j,j,j,j,0,0,0,d,d,d,d,d,"Rdd=vasrh(Rss,#u4):raw"
+1,0,0,0,1,0,0,0,0,1,1,s,s,s,s,s,P,P,0,0,j,j,j,j,1,0,0,d,d,d,d,d,"Rd=vasrhub(Rss,#u4):raw"
+1,0,0,0,1,0,0,0,0,1,1,s,s,s,s,s,P,P,0,0,j,j,j,j,1,0,1,d,d,d,d,d,"Rd=vasrhub(Rss,#u4):sat"
+1,1,0,0,0,0,1,1,0,1,-,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,-,d,d,d,d,d,"Rdd=vasrh(Rss,Rt)"
+1,1,0,0,0,0,1,1,0,1,-,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,-,d,d,d,d,d,"Rdd=vlsrh(Rss,Rt)"
+1,1,0,0,0,0,1,1,0,1,-,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,-,d,d,d,d,d,"Rdd=vaslh(Rss,Rt)"
+1,1,0,0,0,0,1,1,0,1,-,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,-,d,d,d,d,d,"Rdd=vlslh(Rss,Rt)"
+1,0,0,0,0,0,0,0,0,1,0,s,s,s,s,s,P,P,0,j,j,j,j,j,0,0,0,d,d,d,d,d,"Rdd=vasrw(Rss,#u5)"
+1,0,0,0,0,0,0,0,0,1,0,s,s,s,s,s,P,P,0,j,j,j,j,j,0,0,1,d,d,d,d,d,"Rdd=vlsrw(Rss,#u5)"
+1,0,0,0,0,0,0,0,0,1,0,s,s,s,s,s,P,P,0,j,j,j,j,j,0,1,0,d,d,d,d,d,"Rdd=vaslw(Rss,#u5)"
+1,1,0,0,0,0,1,1,0,0,-,s,s,s,s,s,P,P,-,t,t,t,t,t,0,0,-,d,d,d,d,d,"Rdd=vasrw(Rss,Rt)"
+1,1,0,0,0,0,1,1,0,0,-,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,-,d,d,d,d,d,"Rdd=vlsrw(Rss,Rt)"
+1,1,0,0,0,0,1,1,0,0,-,s,s,s,s,s,P,P,-,t,t,t,t,t,1,0,-,d,d,d,d,d,"Rdd=vaslw(Rss,Rt)"
+1,1,0,0,0,0,1,1,0,0,-,s,s,s,s,s,P,P,-,t,t,t,t,t,1,1,-,d,d,d,d,d,"Rdd=vlslw(Rss,Rt)"
+1,0,0,0,1,0,0,0,1,1,0,s,s,s,s,s,P,P,0,j,j,j,j,j,0,1,0,d,d,d,d,d,"Rd=vasrw(Rss,#u5)"
+1,1,0,0,0,1,0,1,-,-,-,s,s,s,s,s,P,P,-,t,t,t,t,t,0,1,0,d,d,d,d,d,"Rd=vasrw(Rss,Rt)"
diff --git a/target/hexagon/generator/meta-instructions.csv b/target/hexagon/generator/meta-instructions.csv
new file mode 100644
index 0000000000..a23be4df46
--- /dev/null
+++ b/target/hexagon/generator/meta-instructions.csv
@@ -0,0 +1,1067 @@
+"Rd=add(Rs,#s16)","apply_extension(#s);Rd=Rs+#s;"
+"Rd=add(Rs,Rt)",Rd=Rs+Rt;
+"Rd=add(Rs,Rt):sat",Rd=sat32(Rs+Rt);
+"Rd=and(Rs,#s10)","apply_extension(#s);Rd=Rs&#s;"
+"Rd=and(Rs,Rt)",Rd=Rs&Rt;
+"Rd=and(Rt,~Rs)",Rd = (Rt & ~Rs);
+Rd=not(Rs),"Assembler mapped to: ""Rd=sub(#-1,Rs)"""
+"Rd=or(Rs,#s10)","apply_extension(#s);Rd=Rs|#s;"
+"Rd=or(Rs,Rt)",Rd=Rs|Rt;
+"Rd=or(Rt,~Rs)",Rd = (Rt | ~Rs);
+"Rd=xor(Rs,Rt)",Rd=Rs^Rt;
+Rd=neg(Rs),"Assembler mapped to: ""Rd=sub(#0,Rs)"""
+nop,
+"Rd=sub(#s10,Rs)","apply_extension(#s);Rd=#s-Rs;"
+"Rd=sub(Rt,Rs)",Rd=Rt-Rs;
+"Rd=sub(Rt,Rs):sat",Rd=sat32(Rt - Rs);
+Rd=sxtb(Rs),Rd = sxt8->32(Rs);
+Rd=sxth(Rs),Rd = sxt16->32(Rs);
+Rd=#s16,"apply_extension(#s);Rd=#s;"
+Rdd=#s8,"if (""#s8<0"") {Assembler mapped to: ""Rdd=combine(#-1,#s8)"";} else {Assembler mapped to:""Rdd=combine(#0,#s8)"";};"
+Rx.[HL]=#u16,Rx.h[01]=#u;
+Rd=Rs,Rd=Rs;
+Rdd=Rss,"Assembler mapped to:""Rdd=combine(Rss.H32,Rss.L32)"""
+"Rd=vaddh(Rs,Rt)[:sat]","for (i=0;i<2;i++) {Rd.h[i]=[sat16](Rs.h[i]+Rt.h[i]);};"
+"Rd=vadduh(Rs,Rt):sat","for (i=0;i<2;i++) {Rd.h[i]=usat16(Rs.uh[i]+Rt.uh[i]);};"
+"Rd=vavgh(Rs,Rt)","for (i=0;i<2;i++) {Rd.h[i]=((Rs.h[i]+Rt.h[i])>>1);};"
+"Rd=vavgh(Rs,Rt):rnd","for (i=0;i<2;i++) {Rd.h[i]=((Rs.h[i]+Rt.h[i]+1)>>1);};"
+"Rd=vnavgh(Rt,Rs)","for (i=0;i<2;i++) {Rd.h[i]=((Rt.h[i]-Rs.h[i])>>1);};"
+"Rd=vsubh(Rt,Rs)[:sat]","for (i=0;i<2;i++) {Rd.h[i]=[sat16](Rt.h[i]-Rs.h[i]);};"
+"Rd=vsubuh(Rt,Rs):sat","for (i=0;i<2;i++) {Rd.h[i]=usat16(Rt.uh[i]-Rs.uh[i]);};"
+Rd=zxtb(Rs),"Assembler mapped to: ""Rd=and(Rs,#255)"""
+Rd=zxth(Rs),Rd = zxt16->32(Rs);
+"Rd=combine(Rt.[HL],Rs.[HL])",Rd = (Rt.uh[01]<<16) | Rs.uh[01];
+"Rdd=combine(#s8,#S8)","apply_extension(#s);Rdd.w[0]=#S;Rdd.w[1]=#s;"
+"Rdd=combine(#s8,#U6)","apply_extension(#U);Rdd.w[0]=#U;Rdd.w[1]=#s;"
+"Rdd=combine(#s8,Rs)","apply_extension(#s);Rdd.w[0]=Rs;Rdd.w[1]=#s;"
+"Rdd=combine(Rs,#s8)","apply_extension(#s);Rdd.w[0]=#s;Rdd.w[1]=Rs;"
+"Rdd=combine(Rs,Rt)","Rdd.w[0]=Rt;Rdd.w[1]=Rs;"
+"Rd=mux(Pu,#s8,#S8)","apply_extension(#s);Rd = (Pu[0]) ? #s : #S;"
+"Rd=mux(Pu,#s8,Rs)","apply_extension(#s);Rd = (Pu[0]) ? #s : Rs;"
+"Rd=mux(Pu,Rs,#s8)","apply_extension(#s);Rd = (Pu[0]) ? Rs : #s;"
+"Rd=mux(Pu,Rs,Rt)", Rd = (Pu[0]) ? Rs : Rt;
+Rd=aslh(Rs),Rd=Rs<<16;
+Rd=asrh(Rs),Rd=Rs>>16;
+"Rdd=packhl(Rs,Rt)","Rdd.h[0]=Rt.h[0];Rdd.h[1]=Rs.h[0];Rdd.h[2]=Rt.h[1];Rdd.h[3]=Rs.h[1];"
+"if ([!]Pu[.new])Rd=add(Rs,#s8)","if([!]Pu[.new][0]){apply_extension(#s);Rd=Rs+#s;} else {NOP;};"
+"if ([!]Pu[.new])Rd=add(Rs,Rt)","if([!]Pu[.new][0]){Rd=Rs+Rt;} else {NOP;};"
+if ([!]Pu[.new]) Rd=aslh(Rs),"if([!]Pu[.new][0]){Rd=Rs<<16;} else {NOP;};"
+if ([!]Pu[.new]) Rd=asrh(Rs),"if([!]Pu[.new][0]){Rd=Rs>>16;} else {NOP;};"
+"if ([!]Pu[.new])Rdd=combine(Rs,Rt)","if ([!]Pu[.new][0]) {Rdd.w[0]=Rt;Rdd.w[1]=Rs;} else {NOP;};"
+"if ([!]Pu[.new])Rd=and(Rs,Rt)","if([!]Pu[.new][0]){Rd=Rs&Rt;} else {NOP;};"
+"if ([!]Pu[.new])Rd=or(Rs,Rt)","if([!]Pu[.new][0]){Rd=Rs|Rt;} else {NOP;};"
+"if ([!]Pu[.new])Rd=xor(Rs,Rt)","if([!]Pu[.new][0]){Rd=Rs^Rt;} else {NOP;};"
+"if ([!]Pu[.new])Rd=sub(Rt,Rs)","if([!]Pu[.new][0]){Rd=Rt-Rs;} else {NOP;};"
+if ([!]Pu[.new]) Rd=sxtb(Rs),"if([!]Pu[.new][0]){Rd=sxt8->32(Rs);} else {NOP;};"
+if ([!]Pu[.new]) Rd=sxth(Rs),"if([!]Pu[.new][0]){Rd=sxt16->32(Rs);} else {NOP;};"
+if ([!]Pu[.new]) Rd=#s12,"apply_extension(#s);if ([!]Pu[.new][0]) Rd=#s;else NOP;"
+if ([!]Pu[.new]) Rd=Rs,"Assembler mapped to: ""if ([!]Pu[.new])Rd=add(Rs,#0)"""
+if ([!]Pu[.new]) Rdd=Rss,"Assembler mapped to: ""if ([!]Pu[.new])Rdd=combine(Rss.H32,Rss.L32)"""
+if ([!]Pu[.new]) Rd=zxtb(Rs),"if([!]Pu[.new][0]){Rd=zxt8->32(Rs);} else {NOP;};"
+if ([!]Pu[.new]) Rd=zxth(Rs),"if([!]Pu[.new][0]){Rd=zxt16->32(Rs);} else {NOP;};"
+"Pd=[!]cmp.eq(Rs,#s10)","apply_extension(#s);Pd=Rs[!]=#s ? 0xff : 0x00;"
+"Pd=[!]cmp.eq(Rs,Rt)",Pd=Rs[!]=Rt ? 0xff : 0x00;
+"Pd=[!]cmp.gt(Rs,#s10)","apply_extension(#s);Pd=[!](Rs>#s ? 0xff : 0x00);"
+"Pd=cmp.gt(Rs,Rt)",Pd=Rs<=Rt ? 0x00 : 0xff;
+"Pd=!cmp.gt(Rs,Rt)",Pd=Rs<=Rt ? 0xff : 0x00;
+"Pd=cmp.gtu(Rs,#u9)","apply_extension(#u);Pd=Rs.uw[0]<=#u ? 0x00 : 0xff;"
+"Pd=!cmp.gtu(Rs,#u9)","apply_extension(#u);Pd=Rs.uw[0]<=#u ? 0xff : 0x00;"
+"Pd=cmp.gtu(Rs,Rt)",Pd=Rs.uw[0]<=Rt.uw[0] ? 0x00 : 0xff;
+"Pd=!cmp.gtu(Rs,Rt)",Pd=Rs.uw[0]<=Rt.uw[0] ? 0xff : 0x00;
+"Pd=cmp.ge(Rs,#s8)","Assembler mapped to: ""Pd=cmp.gt(Rs,#s8-1)"""
+"Pd=cmp.geu(Rs,#u8)","if (""#u8==0"") {Assembler mapped to:""Pd=cmp.eq(Rs,Rs)"";} else {Assembler mapped to:""Pd=cmp.gtu(Rs,#u8-1)"";};"
+"Pd=cmp.lt(Rs,Rt)","Assembler mapped to: ""Pd=cmp.gt(Rt,Rs)"""
+"Pd=cmp.ltu(Rs,Rt)","Assembler mapped to: ""Pd=cmp.gtu(Rt,Rs)"""
+"Rd=[!]cmp.eq(Rs,#s8)","apply_extension(#s);Rd=(Rs[!]=#s);"
+"Rd=[!]cmp.eq(Rs,Rt)",Rd=(Rs[!]=Rt);
+endloop0,"if (USR.LPCFG) {if (USR.LPCFG==1) {P3=0xff;};USR.LPCFG=USR.LPCFG-1;};if (LC0>1) {PC=SA0;LC0=LC0-1;};"
+endloop01,"if (USR.LPCFG) {if (USR.LPCFG==1) {P3=0xff;};USR.LPCFG=USR.LPCFG-1;};if (LC0>1) {PC=SA0;LC0=LC0-1;} else {if (LC1>1) {PC=SA1;LC1=LC1-1;};};"
+endloop1,"if (LC1>1) {PC=SA1;LC1=LC1-1;};"
+"Pd=[!]fastcorner9(Ps,Pt)","tmp.h[0]=(Ps<<8)|Pt;tmp.h[1]=(Ps<<8)|Pt;for (i = 1; i < 9; i++) {tmp &= tmp >> 1;};Pd = tmp == 0 ? 0xff : 0x00;"
+Pd=all8(Ps),"Pd = (Ps==0xff) ? 0xff : 0x00;"
+Pd=any8(Ps),"Pd = Ps ? 0xff : 0x00";
+"loop0(#r7:2,#U10)","apply_extension(#r);#r=#r & ~0x3;SA0=PC+#r;LC0=#U;USR.LPCFG=0;"
+"loop0(#r7:2,Rs)","apply_extension(#r);#r=#r & ~0x3;SA0=PC+#r;LC0=Rs;USR.LPCFG=0;"
+"loop1(#r7:2,#U10)","apply_extension(#r);#r=#r & ~0x3;SA1=PC+#r;LC1=#U;"
+"loop1(#r7:2,Rs)","apply_extension(#r);#r=#r & ~0x3;SA1=PC+#r;LC1=Rs;"
+"Rd=add(pc,#u6)",Rd=PC+apply_extension(#u);
+"p3=sp1loop0(#r7:2,#U10)","apply_extension(#r);#r=#r & ~0x3;SA0=PC+#r;LC0=#U;USR.LPCFG=1;P3=0;"
+"p3=sp1loop0(#r7:2,Rs)","apply_extension(#r);#r=#r & ~0x3;SA0=PC+#r;LC0=Rs;USR.LPCFG=1;P3=0;"
+"p3=sp2loop0(#r7:2,#U10)","apply_extension(#r);#r=#r & ~0x3;SA0=PC+#r;LC0=#U;USR.LPCFG=2;P3=0;"
+"p3=sp2loop0(#r7:2,Rs)","apply_extension(#r);#r=#r & ~0x3;SA0=PC+#r;LC0=Rs;USR.LPCFG=2;P3=0;"
+"p3=sp3loop0(#r7:2,#U10)","apply_extension(#r);#r=#r & ~0x3;SA0=PC+#r;LC0=#U;USR.LPCFG=3;P3=0;"
+"p3=sp3loop0(#r7:2,Rs)","apply_extension(#r);#r=#r & ~0x3;SA0=PC+#r;LC0=Rs;USR.LPCFG=3;P3=0;"
+Pd=Ps,"Assembler mapped to: ""Pd=or(Ps,Ps)"""
+"Pd=and(Ps,and(Pt,[!]Pu))",Pd = Ps & Pt & ([!]Pu);
+"Pd=and(Ps,or(Pt,[!]Pu))",Pd = Ps & (Pt | ([!]Pu));
+"Pd=and(Pt,[!]Ps)",Pd=Pt & ([!]Ps);
+Pd=not(Ps),Pd=~Ps;
+"Pd=or(Ps,and(Pt,[!]Pu))",Pd = Ps | (Pt & ([!]Pu));
+"Pd=or(Ps,or(Pt,[!]Pu))",Pd = Ps | Pt | ([!]Pu);
+"Pd=or(Pt,[!]Ps)",Pd=Pt | ([!]Ps);
+"Pd=xor(Ps,Pt)",Pd=Ps ^ Pt;
+Cd=Rs,Cd=Rs;
+Cdd=Rss,Cdd=Rss;
+Rd=Cs,Rd=Cs;
+Rdd=Css,Rdd=Css;
+callr Rs,"LR=NPC;PC=Rs;;"
+if ([!]Pu) callr Rs,";if ([!]Pu[0]) {LR=NPC;PC=Rs;;};"
+hintjr(Rs),;
+if ([!]Pu) jumpr Rs,"Assembler mapped to: ""if ([!]Pu)""""jumpr"""":nt """"Rs"""
+"if ([!]Pu[.new])jumpr:<hint> Rs","if([!]Pu[.new][0]){PC=Rs;};"
+jumpr Rs,PC=Rs;
+call #r22:2,"apply_extension(#r);#r=#r & ~0x3;LR=NPC;PC=PC+#r;;"
+if ([!]Pu) call #r15:2,"apply_extension(#r);#r=#r & ~0x3;;if ([!]Pu[0]) {LR=NPC;PC=PC+#r;;};"
+"p[01]=cmp.eq(Rs,#-1); if([!]p[01].new) jump:<hint>#r9:2","P[01]=(Rs==-1) ? 0xff : 0x00 if([!]P[01].new[0]) {apply_extension(#r);#r=#r & ~0x3;PC=PC+#r;};"
+"p[01]=cmp.eq(Rs,#U5); if([!]p[01].new) jump:<hint>#r9:2","P[01]=(Rs==#U) ? 0xff : 0x00 if([!]P[01].new[0]) {apply_extension(#r);#r=#r & ~0x3;PC=PC+#r;};"
+"p[01]=cmp.eq(Rs,Rt); if([!]p[01].new) jump:<hint>#r9:2","P[01]=(Rs==Rt) ? 0xff : 0x00 if([!]P[01].new[0]) {apply_extension(#r);#r=#r & ~0x3;PC=PC+#r;};"
+"p[01]=cmp.gt(Rs,#-1); if([!]p[01].new) jump:<hint>#r9:2","P[01]=(Rs>-1) ? 0xff : 0x00 if([!]P[01].new[0]) {apply_extension(#r);#r=#r & ~0x3;PC=PC+#r;};"
+"p[01]=cmp.gt(Rs,#U5); if([!]p[01].new) jump:<hint>#r9:2","P[01]=(Rs>#U) ? 0xff : 0x00 if([!]P[01].new[0]) {apply_extension(#r);#r=#r & ~0x3;PC=PC+#r;};"
+"p[01]=cmp.gt(Rs,Rt); if([!]p[01].new) jump:<hint>#r9:2","P[01]=(Rs>Rt) ? 0xff : 0x00 if([!]P[01].new[0]) {apply_extension(#r);#r=#r & ~0x3;PC=PC+#r;};"
+"p[01]=cmp.gtu(Rs,#U5); if([!]p[01].new) jump:<hint>#r9:2","P[01]=(Rs.uw[0]>#U) ? 0xff : 0x00 if([!]P[01].new[0]) {apply_extension(#r);#r=#r & ~0x3;PC=PC+#r;};"
+"p[01]=cmp.gtu(Rs,Rt); if([!]p[01].new) jump:<hint>#r9:2","P[01]=(Rs.uw[0]>Rt) ? 0xff : 0x00 if([!]P[01].new[0]) {apply_extension(#r);#r=#r & ~0x3;PC=PC+#r;};"
+"p[01]=tstbit(Rs,#0); if([!]p[01].new) jump:<hint>#r9:2","P[01]=(Rs & 1) ? 0xff : 0x00 if([!]P[01].new[0]) {apply_extension(#r);#r=#r & ~0x3;PC=PC+#r;};"
+if ([!]Pu) jump #r15:2,"Assembler mapped to: ""if ([!]Pu)""""jump"""":nt """"#r15:2"""
+"if ([!]Pu) jump:<hint>#r15:2",";if ([!]Pu[0]) {apply_extension(#r);#r=#r & ~0x3;PC=PC+#r;;};"
+jump #r22:2,"apply_extension(#r);#r=#r & ~0x3;PC=PC+#r;"
+if ([!]Pu.new) jump:<hint> #r15:2,"if([!]Pu.new[0]){apply_extension(#r);#r=#r & ~0x3;PC=PC+#r;};"
+if (Rs!=#0) jump:nt #r13:2,"if (Rs != 0) {PC=PC+#r;};"
+if (Rs!=#0) jump:t #r13:2,"if (Rs != 0) {PC=PC+#r;};"
+if (Rs<=#0) jump:nt #r13:2,"if (Rs<=0) {PC=PC+#r;};"
+if (Rs<=#0) jump:t #r13:2,"if (Rs<=0) {PC=PC+#r;};"
+if (Rs==#0) jump:nt #r13:2,"if (Rs == 0) {PC=PC+#r;};"
+if (Rs==#0) jump:t #r13:2,"if (Rs == 0) {PC=PC+#r;};"
+if (Rs>=#0) jump:nt #r13:2,"if (Rs>=0) {PC=PC+#r;};"
+if (Rs>=#0) jump:t #r13:2,"if (Rs>=0) {PC=PC+#r;};"
+Rd=#U6 ; jump #r9:2,"apply_extension(#r);#r=#r & ~0x3;Rd=#U;PC=PC+#r;"
+Rd=Rs ; jump #r9:2,"apply_extension(#r);#r=#r & ~0x3;Rd=Rs;PC=PC+#r;"
+Rdd=memd(Re=#U6),"apply_extension(#U);EA=#U;Rdd = *EA;Re=#U;"
+Rdd=memd(Rs+#s11:3),"apply_extension(#s);EA=Rs+#s;Rdd = *EA;"
+Rdd=memd(Rs+Rt<<#u2),"EA=Rs+(Rt<<#u);Rdd = *EA;"
+Rdd=memd(Rt<<#u2+#U6),"apply_extension(#U);EA=#U+(Rt<<#u);Rdd = *EA;"
+Rdd=memd(Rx++#s4:3),"EA=Rx;Rx=Rx+#s;Rdd = *EA;"
+Rdd=memd(Rx++#s4:3:circ(Mu)),"EA=Rx;Rx=Rx=circ_add(Rx,#s,MuV);Rdd = *EA;"
+Rdd=memd(Rx++I:circ(Mu)),"EA=Rx;Rx=Rx=circ_add(Rx,I<<3,MuV);Rdd = *EA;"
+Rdd=memd(Rx++Mu),"EA=Rx;Rx=Rx+MuV;Rdd = *EA;"
+Rdd=memd(Rx++Mu:brev),"EA=Rx.h[1] | brev(Rx.h[0]);Rx=Rx+MuV;Rdd = *EA;"
+Rdd=memd(gp+#u16:3),"apply_extension(#u);EA=(Constant_extended ? (0) : GP)+#u;Rdd = *EA;"
+if ([!]Pt[.new]) Rdd=memd(#u6),"if ([!]Pt[.new][0]) {apply_extension(#u);EA=#u;Rdd = *EA;} else {NOP;};"
+if ([!]Pt[.new]) Rdd=memd(Rs+#u6:3),"if ([!]Pt[.new][0]) {apply_extension(#u);EA=Rs+#u;Rdd = *EA;} else {NOP;};"
+if ([!]Pt[.new]) Rdd=memd(Rx++#s4:3),"if([!]Pt[.new][0]){EA=Rx;Rx=Rx+#s;Rdd = *EA;} else {NOP;};"
+if ([!]Pv[.new]) Rdd=memd(Rs+Rt<<#u2),"if ([!]Pv[.new][0]) {EA=Rs+(Rt<<#u);Rdd = *EA;} else {NOP;};"
+Rd=memb(Re=#U6),"apply_extension(#U);EA=#U;Rd = *EA;Re=#U;"
+Rd=memb(Rs+#s11:0),"apply_extension(#s);EA=Rs+#s;Rd = *EA;"
+Rd=memb(Rs+Rt<<#u2),"EA=Rs+(Rt<<#u);Rd = *EA;"
+Rd=memb(Rt<<#u2+#U6),"apply_extension(#U);EA=#U+(Rt<<#u);Rd = *EA;"
+Rd=memb(Rx++#s4:0),"EA=Rx;Rx=Rx+#s;Rd = *EA;"
+Rd=memb(Rx++#s4:0:circ(Mu)),"EA=Rx;Rx=Rx=circ_add(Rx,#s,MuV);Rd = *EA;"
+Rd=memb(Rx++I:circ(Mu)),"EA=Rx;Rx=Rx=circ_add(Rx,I<<0,MuV);Rd = *EA;"
+Rd=memb(Rx++Mu),"EA=Rx;Rx=Rx+MuV;Rd = *EA;"
+Rd=memb(Rx++Mu:brev),"EA=Rx.h[1] | brev(Rx.h[0]);Rx=Rx+MuV;Rd = *EA;"
+Rd=memb(gp+#u16:0),"apply_extension(#u);EA=(Constant_extended ? (0) : GP)+#u;Rd = *EA;"
+if ([!]Pt[.new]) Rd=memb(#u6),"if ([!]Pt[.new][0]) {apply_extension(#u);EA=#u;Rd = *EA;} else {NOP;};"
+if ([!]Pt[.new]) Rd=memb(Rs+#u6:0),"if ([!]Pt[.new][0]) {apply_extension(#u);EA=Rs+#u;Rd = *EA;} else {NOP;};"
+if ([!]Pt[.new]) Rd=memb(Rx++#s4:0),"if([!]Pt[.new][0]){EA=Rx;Rx=Rx+#s;Rd = *EA;} else {NOP;};"
+if ([!]Pv[.new]) Rd=memb(Rs+Rt<<#u2),"if ([!]Pv[.new][0]) {EA=Rs+(Rt<<#u);Rd = *EA;} else {NOP;};"
+Ryy=memb_fifo(Re=#U6),"apply_extension(#U);EA=#U;{tmpV = *EA;Ryy = (((size8u_t)Ryy)>>8)|(tmpV<<56);};;Re=#U;"
+Ryy=memb_fifo(Rs),"Assembler mapped to:""Ryy=memb_fifo""""(Rs+#0)"""
+Ryy=memb_fifo(Rs+#s11:0),"apply_extension(#s);EA=Rs+#s;{tmpV = *EA;Ryy = (((size8u_t)Ryy)>>8)|(tmpV<<56);};;"
+Ryy=memb_fifo(Rt<<#u2+#U6),"apply_extension(#U);EA=#U+(Rt<<#u);{tmpV = *EA;Ryy = (((size8u_t)Ryy)>>8)|(tmpV<<56);};;"
+Ryy=memb_fifo(Rx++#s4:0),"EA=Rx;Rx=Rx+#s;{tmpV = *EA;Ryy = (((size8u_t)Ryy)>>8)|(tmpV<<56);};;"
+Ryy=memb_fifo(Rx++#s4:0:circ(Mu)),"EA=Rx;Rx=Rx=circ_add(Rx,#s,MuV);{tmpV = *EA;Ryy = (((size8u_t)Ryy)>>8)|(tmpV<<56);};;"
+Ryy=memb_fifo(Rx++I:circ(Mu)),"EA=Rx;Rx=Rx=circ_add(Rx,I<<0,MuV);{tmpV = *EA;Ryy = (((size8u_t)Ryy)>>8)|(tmpV<<56);};;"
+Ryy=memb_fifo(Rx++Mu),"EA=Rx;Rx=Rx+MuV;{tmpV = *EA;Ryy = (((size8u_t)Ryy)>>8)|(tmpV<<56);};;"
+Ryy=memb_fifo(Rx++Mu:brev),"EA=Rx.h[1] | brev(Rx.h[0]);Rx=Rx+MuV;{tmpV = *EA;Ryy = (((size8u_t)Ryy)>>8)|(tmpV<<56);};;"
+Ryy=memh_fifo(Re=#U6),"apply_extension(#U);EA=#U;{tmpV = *EA;Ryy = (((size8u_t)Ryy)>>16)|(tmpV<<48);};;Re=#U;"
+Ryy=memh_fifo(Rs),"Assembler mapped to:""Ryy=memh_fifo""""(Rs+#0)"""
+Ryy=memh_fifo(Rs+#s11:1),"apply_extension(#s);EA=Rs+#s;{tmpV = *EA;Ryy = (((size8u_t)Ryy)>>16)|(tmpV<<48);};;"
+Ryy=memh_fifo(Rt<<#u2+#U6),"apply_extension(#U);EA=#U+(Rt<<#u);{tmpV = *EA;Ryy = (((size8u_t)Ryy)>>16)|(tmpV<<48);};;"
+Ryy=memh_fifo(Rx++#s4:1),"EA=Rx;Rx=Rx+#s;{tmpV = *EA;Ryy = (((size8u_t)Ryy)>>16)|(tmpV<<48);};;"
+Ryy=memh_fifo(Rx++#s4:1:circ(Mu)),"EA=Rx;Rx=Rx=circ_add(Rx,#s,MuV);{tmpV = *EA;Ryy = (((size8u_t)Ryy)>>16)|(tmpV<<48);};;"
+Ryy=memh_fifo(Rx++I:circ(Mu)),"EA=Rx;Rx=Rx=circ_add(Rx,I<<1,MuV);{tmpV = *EA;Ryy = (((size8u_t)Ryy)>>16)|(tmpV<<48);};;"
+Ryy=memh_fifo(Rx++Mu),"EA=Rx;Rx=Rx+MuV;{tmpV = *EA;Ryy = (((size8u_t)Ryy)>>16)|(tmpV<<48);};;"
+Ryy=memh_fifo(Rx++Mu:brev),"EA=Rx.h[1] | brev(Rx.h[0]);Rx=Rx+MuV;{tmpV = *EA;Ryy = (((size8u_t)Ryy)>>16)|(tmpV<<48);};;"
+Rd=memh(Re=#U6),"apply_extension(#U);EA=#U;Rd = *EA;Re=#U;"
+Rd=memh(Rs+#s11:1),"apply_extension(#s);EA=Rs+#s;Rd = *EA;"
+Rd=memh(Rs+Rt<<#u2),"EA=Rs+(Rt<<#u);Rd = *EA;"
+Rd=memh(Rt<<#u2+#U6),"apply_extension(#U);EA=#U+(Rt<<#u);Rd = *EA;"
+Rd=memh(Rx++#s4:1),"EA=Rx;Rx=Rx+#s;Rd = *EA;"
+Rd=memh(Rx++#s4:1:circ(Mu)),"EA=Rx;Rx=Rx=circ_add(Rx,#s,MuV);Rd = *EA;"
+Rd=memh(Rx++I:circ(Mu)),"EA=Rx;Rx=Rx=circ_add(Rx,I<<1,MuV);Rd = *EA;"
+Rd=memh(Rx++Mu),"EA=Rx;Rx=Rx+MuV;Rd = *EA;"
+Rd=memh(Rx++Mu:brev),"EA=Rx.h[1] | brev(Rx.h[0]);Rx=Rx+MuV;Rd = *EA;"
+Rd=memh(gp+#u16:1),"apply_extension(#u);EA=(Constant_extended ? (0) : GP)+#u;Rd = *EA;"
+"if ([!]Pt[.new])Rd=memh(#u6)","if ([!]Pt[.new][0]) {apply_extension(#u);EA=#u;Rd = *EA;} else {NOP;};"
+"if ([!]Pt[.new])Rd=memh(Rs+#u6:1)","if ([!]Pt[.new][0]) {apply_extension(#u);EA=Rs+#u;Rd = *EA;} else {NOP;};"
+"if ([!]Pt[.new])Rd=memh(Rx++#s4:1)","if([!]Pt[.new][0]){EA=Rx;Rx=Rx+#s;Rd = *EA;} else {NOP;};"
+"if ([!]Pv[.new])Rd=memh(Rs+Rt<<#u2)","if ([!]Pv[.new][0]) {EA=Rs+(Rt<<#u);Rd = *EA;} else {NOP;};"
+Rd=memub(Re=#U6),"apply_extension(#U);EA=#U;Rd = *EA;Re=#U;"
+Rd=memub(Rs+#s11:0),"apply_extension(#s);EA=Rs+#s;Rd = *EA;"
+Rd=memub(Rs+Rt<<#u2),"EA=Rs+(Rt<<#u);Rd = *EA;"
+Rd=memub(Rt<<#u2+#U6),"apply_extension(#U);EA=#U+(Rt<<#u);Rd = *EA;"
+Rd=memub(Rx++#s4:0),"EA=Rx;Rx=Rx+#s;Rd = *EA;"
+Rd=memub(Rx++#s4:0:circ(Mu)),"EA=Rx;Rx=Rx=circ_add(Rx,#s,MuV);Rd = *EA;"
+Rd=memub(Rx++I:circ(Mu)),"EA=Rx;Rx=Rx=circ_add(Rx,I<<0,MuV);Rd = *EA;"
+Rd=memub(Rx++Mu),"EA=Rx;Rx=Rx+MuV;Rd = *EA;"
+Rd=memub(Rx++Mu:brev),"EA=Rx.h[1] | brev(Rx.h[0]);Rx=Rx+MuV;Rd = *EA;"
+Rd=memub(gp+#u16:0),"apply_extension(#u);EA=(Constant_extended ? (0) : GP)+#u;Rd = *EA;"
+"if ([!]Pt[.new])Rd=memub(#u6)","if ([!]Pt[.new][0]) {apply_extension(#u);EA=#u;Rd = *EA;} else {NOP;};"
+"if ([!]Pt[.new])Rd=memub(Rs+#u6:0)","if ([!]Pt[.new][0]) {apply_extension(#u);EA=Rs+#u;Rd = *EA;} else {NOP;};"
+"if ([!]Pt[.new])Rd=memub(Rx++#s4:0)","if([!]Pt[.new][0]){EA=Rx;Rx=Rx+#s;Rd = *EA;} else {NOP;};"
+"if ([!]Pv[.new])Rd=memub(Rs+Rt<<#u2)","if ([!]Pv[.new][0]) {EA=Rs+(Rt<<#u);Rd = *EA;} else {NOP;};"
+Rd=memuh(Re=#U6),"apply_extension(#U);EA=#U;Rd = *EA;Re=#U;"
+Rd=memuh(Rs+#s11:1),"apply_extension(#s);EA=Rs+#s;Rd = *EA;"
+Rd=memuh(Rs+Rt<<#u2),"EA=Rs+(Rt<<#u);Rd = *EA;"
+Rd=memuh(Rt<<#u2+#U6),"apply_extension(#U);EA=#U+(Rt<<#u);Rd = *EA;"
+Rd=memuh(Rx++#s4:1),"EA=Rx;Rx=Rx+#s;Rd = *EA;"
+Rd=memuh(Rx++#s4:1:circ(Mu)),"EA=Rx;Rx=Rx=circ_add(Rx,#s,MuV);Rd = *EA;"
+Rd=memuh(Rx++I:circ(Mu)),"EA=Rx;Rx=Rx=circ_add(Rx,I<<1,MuV);Rd = *EA;"
+Rd=memuh(Rx++Mu),"EA=Rx;Rx=Rx+MuV;Rd = *EA;"
+Rd=memuh(Rx++Mu:brev),"EA=Rx.h[1] | brev(Rx.h[0]);Rx=Rx+MuV;Rd = *EA;"
+Rd=memuh(gp+#u16:1),"apply_extension(#u);EA=(Constant_extended ? (0) : GP)+#u;Rd = *EA;"
+"if ([!]Pt[.new])Rd=memuh(#u6)","if ([!]Pt[.new][0]) {apply_extension(#u);EA=#u;Rd = *EA;} else {NOP;};"
+"if ([!]Pt[.new])Rd=memuh(Rs+#u6:1)","if ([!]Pt[.new][0]) {apply_extension(#u);EA=Rs+#u;Rd = *EA;} else {NOP;};"
+"if ([!]Pt[.new])Rd=memuh(Rx++#s4:1)","if([!]Pt[.new][0]){EA=Rx;Rx=Rx+#s;Rd = *EA;} else {NOP;};"
+"if ([!]Pv[.new])Rd=memuh(Rs+Rt<<#u2)","if ([!]Pv[.new][0]) {EA=Rs+(Rt<<#u);Rd = *EA;} else {NOP;};"
+Rd=memw(Re=#U6),"apply_extension(#U);EA=#U;Rd = *EA;Re=#U;"
+Rd=memw(Rs+#s11:2),"apply_extension(#s);EA=Rs+#s;Rd = *EA;"
+Rd=memw(Rs+Rt<<#u2),"EA=Rs+(Rt<<#u);Rd = *EA;"
+Rd=memw(Rt<<#u2+#U6),"apply_extension(#U);EA=#U+(Rt<<#u);Rd = *EA;"
+Rd=memw(Rx++#s4:2),"EA=Rx;Rx=Rx+#s;Rd = *EA;"
+Rd=memw(Rx++#s4:2:circ(Mu)),"EA=Rx;Rx=Rx=circ_add(Rx,#s,MuV);Rd = *EA;"
+Rd=memw(Rx++I:circ(Mu)),"EA=Rx;Rx=Rx=circ_add(Rx,I<<2,MuV);Rd = *EA;"
+Rd=memw(Rx++Mu),"EA=Rx;Rx=Rx+MuV;Rd = *EA;"
+Rd=memw(Rx++Mu:brev),"EA=Rx.h[1] | brev(Rx.h[0]);Rx=Rx+MuV;Rd = *EA;"
+Rd=memw(gp+#u16:2),"apply_extension(#u);EA=(Constant_extended ? (0) : GP)+#u;Rd = *EA;"
+"if ([!]Pt[.new])Rd=memw(#u6)","if ([!]Pt[.new][0]) {apply_extension(#u);EA=#u;Rd = *EA;} else {NOP;};"
+"if ([!]Pt[.new])Rd=memw(Rs+#u6:2)","if ([!]Pt[.new][0]) {apply_extension(#u);EA=Rs+#u;Rd = *EA;} else {NOP;};"
+"if ([!]Pt[.new])Rd=memw(Rx++#s4:2)","if([!]Pt[.new][0]){EA=Rx;Rx=Rx+#s;Rd = *EA;} else {NOP;};"
+"if ([!]Pv[.new])Rd=memw(Rs+Rt<<#u2)","if ([!]Pv[.new][0]) {EA=Rs+(Rt<<#u);Rd = *EA;} else {NOP;};"
+deallocframe,"EA=FP;tmp = *EA;tmp = frame_unscramble(tmp);LR=tmp.w[1];FP=tmp.w[0];SP=EA+8;"
+dealloc_return,"EA=FP;tmp = *EA;tmp = frame_unscramble(tmp);LR=tmp.w[1];FP=tmp.w[0];SP=EA+8;PC=tmp.w[1];"
+if ([!]Ps) dealloc_return,";;if ([!]Ps[0]) {EA=FP;tmp = *EA;tmp = frame_unscramble(tmp);LR=tmp.w[1];FP=tmp.w[0];SP=EA+8;PC=tmp.w[1];} else {NOP;};"
+"if ([!]Ps.new)dealloc_return:nt",";if ([!]Ps.new[0]) {EA=FP;tmp = *EA;tmp = frame_unscramble(tmp);LR=tmp.w[1];FP=tmp.w[0];SP=EA+8;PC=tmp.w[1];} else {NOP;};"
+"if ([!]Ps.new)dealloc_return:t",";if ([!]Ps.new[0]) {EA=FP;tmp = *EA;tmp = frame_unscramble(tmp);LR=tmp.w[1];FP=tmp.w[0];SP=EA+8;PC=tmp.w[1];} else {NOP;};"
+Rd=membh(Re=#U6),"apply_extension(#U);EA=#U;{tmpV = *EA;for (i=0;i<2;i++) {Rd.h[i]=tmpV.b[i];};};;Re=#U;"
+Rd=membh(Rs),"Assembler mapped to: ""Rd=membh""""(Rs+#0)"""
+Rd=membh(Rs+#s11:1),"apply_extension(#s);EA=Rs+#s;{tmpV = *EA;for (i=0;i<2;i++) {Rd.h[i]=tmpV.b[i];};};;"
+Rd=membh(Rt<<#u2+#U6),"apply_extension(#U);EA=#U+(Rt<<#u);{tmpV = *EA;for (i=0;i<2;i++) {Rd.h[i]=tmpV.b[i];};};;"
+Rd=membh(Rx++#s4:1),"EA=Rx;Rx=Rx+#s;{tmpV = *EA;for (i=0;i<2;i++) {Rd.h[i]=tmpV.b[i];};};;"
+Rd=membh(Rx++#s4:1:circ(Mu)),"EA=Rx;Rx=Rx=circ_add(Rx,#s,MuV);{tmpV = *EA;for (i=0;i<2;i++) {Rd.h[i]=tmpV.b[i];};};;"
+Rd=membh(Rx++I:circ(Mu)),"EA=Rx;Rx=Rx=circ_add(Rx,I<<1,MuV);{tmpV = *EA;for (i=0;i<2;i++) {Rd.h[i]=tmpV.b[i];};};;"
+Rd=membh(Rx++Mu),"EA=Rx;Rx=Rx+MuV;{tmpV = *EA;for (i=0;i<2;i++) {Rd.h[i]=tmpV.b[i];};};;"
+Rd=membh(Rx++Mu:brev),"EA=Rx.h[1] | brev(Rx.h[0]);Rx=Rx+MuV;{tmpV = *EA;for (i=0;i<2;i++) {Rd.h[i]=tmpV.b[i];};};;"
+Rd=memubh(Re=#U6),"apply_extension(#U);EA=#U;{tmpV = *EA;for (i=0;i<2;i++) {Rd.h[i]=tmpV.ub[i];};};;Re=#U;"
+Rd=memubh(Rs+#s11:1),"apply_extension(#s);EA=Rs+#s;{tmpV = *EA;for (i=0;i<2;i++) {Rd.h[i]=tmpV.ub[i];};};;"
+Rd=memubh(Rt<<#u2+#U6),"apply_extension(#U);EA=#U+(Rt<<#u);{tmpV = *EA;for (i=0;i<2;i++) {Rd.h[i]=tmpV.ub[i];};};;"
+Rd=memubh(Rx++#s4:1),"EA=Rx;Rx=Rx+#s;{tmpV = *EA;for (i=0;i<2;i++) {Rd.h[i]=tmpV.ub[i];};};;"
+Rd=memubh(Rx++#s4:1:circ(Mu)),"EA=Rx;Rx=Rx=circ_add(Rx,#s,MuV);{tmpV = *EA;for (i=0;i<2;i++) {Rd.h[i]=tmpV.ub[i];};};;"
+Rd=memubh(Rx++I:circ(Mu)),"EA=Rx;Rx=Rx=circ_add(Rx,I<<1,MuV);{tmpV = *EA;for (i=0;i<2;i++) {Rd.h[i]=tmpV.ub[i];};};;"
+Rd=memubh(Rx++Mu),"EA=Rx;Rx=Rx+MuV;{tmpV = *EA;for (i=0;i<2;i++) {Rd.h[i]=tmpV.ub[i];};};;"
+Rd=memubh(Rx++Mu:brev),"EA=Rx.h[1] | brev(Rx.h[0]);Rx=Rx+MuV;{tmpV = *EA;for (i=0;i<2;i++) {Rd.h[i]=tmpV.ub[i];};};;"
+Rdd=membh(Re=#U6),"apply_extension(#U);EA=#U;{tmpV = *EA;for (i=0;i<4;i++) {Rdd.h[i]=tmpV.b[i];};};;Re=#U;"
+Rdd=membh(Rs),"Assembler mapped to: ""Rdd=membh""""(Rs+#0)"""
+Rdd=membh(Rs+#s11:2),"apply_extension(#s);EA=Rs+#s;{tmpV = *EA;for (i=0;i<4;i++) {Rdd.h[i]=tmpV.b[i];};};;"
+Rdd=membh(Rt<<#u2+#U6),"apply_extension(#U);EA=#U+(Rt<<#u);{tmpV = *EA;for (i=0;i<4;i++) {Rdd.h[i]=tmpV.b[i];};};;"
+Rdd=membh(Rx++#s4:2),"EA=Rx;Rx=Rx+#s;{tmpV = *EA;for (i=0;i<4;i++) {Rdd.h[i]=tmpV.b[i];};};;"
+Rdd=membh(Rx++#s4:2:circ(Mu)),"EA=Rx;Rx=Rx=circ_add(Rx,#s,MuV);{tmpV = *EA;for (i=0;i<4;i++) {Rdd.h[i]=tmpV.b[i];};};;"
+Rdd=membh(Rx++I:circ(Mu)),"EA=Rx;Rx=Rx=circ_add(Rx,I<<2,MuV);{tmpV = *EA;for (i=0;i<4;i++) {Rdd.h[i]=tmpV.b[i];};};;"
+Rdd=membh(Rx++Mu),"EA=Rx;Rx=Rx+MuV;{tmpV = *EA;for (i=0;i<4;i++) {Rdd.h[i]=tmpV.b[i];};};;"
+Rdd=membh(Rx++Mu:brev),"EA=Rx.h[1] | brev(Rx.h[0]);Rx=Rx+MuV;{tmpV = *EA;for (i=0;i<4;i++) {Rdd.h[i]=tmpV.b[i];};};;"
+Rdd=memubh(Re=#U6),"apply_extension(#U);EA=#U;{tmpV = *EA;for (i=0;i<4;i++) {Rdd.h[i]=tmpV.ub[i];};};;Re=#U;"
+Rdd=memubh(Rs+#s11:2),"apply_extension(#s);EA=Rs+#s;{tmpV = *EA;for (i=0;i<4;i++) {Rdd.h[i]=tmpV.ub[i];};};;"
+Rdd=memubh(Rt<<#u2+#U6),"apply_extension(#U);EA=#U+(Rt<<#u);{tmpV = *EA;for (i=0;i<4;i++) {Rdd.h[i]=tmpV.ub[i];};};;"
+Rdd=memubh(Rx++#s4:2),"EA=Rx;Rx=Rx+#s;{tmpV = *EA;for (i=0;i<4;i++) {Rdd.h[i]=tmpV.ub[i];};};;"
+Rdd=memubh(Rx++#s4:2:circ(Mu)),"EA=Rx;Rx=Rx=circ_add(Rx,#s,MuV);{tmpV = *EA;for (i=0;i<4;i++) {Rdd.h[i]=tmpV.ub[i];};};;"
+Rdd=memubh(Rx++I:circ(Mu)),"EA=Rx;Rx=Rx=circ_add(Rx,I<<2,MuV);{tmpV = *EA;for (i=0;i<4;i++) {Rdd.h[i]=tmpV.ub[i];};};;"
+Rdd=memubh(Rx++Mu),"EA=Rx;Rx=Rx+MuV;{tmpV = *EA;for (i=0;i<4;i++) {Rdd.h[i]=tmpV.ub[i];};};;"
+Rdd=memubh(Rx++Mu:brev),"EA=Rx.h[1] | brev(Rx.h[0]);Rx=Rx+MuV;{tmpV = *EA;for (i=0;i<4;i++) {Rdd.h[i]=tmpV.ub[i];};};;"
+memb(Rs+#u6:0)=clrbit(#U5),"apply_extension(#u);EA=Rs+#u;tmp = *EA;tmp &= (~(1<<#U));*EA = tmp;"
+memb(Rs+#u6:0)=setbit(#U5),"apply_extension(#u);EA=Rs+#u;tmp = *EA;tmp |= (1<<#U);*EA = tmp;"
+memb(Rs+#u6:0)[+-]=#U5,"apply_extension(#u);EA=Rs[+-]#u;tmp = *EA;tmp [+-]= #U;*EA = tmp;"
+memb(Rs+#u6:0)[+-]=Rt,"apply_extension(#u);EA=Rs+#u;tmp = *EA;tmp [+-]= Rt;*EA = tmp;"
+memb(Rs+#u6:0)[|&]=Rt,"apply_extension(#u);EA=Rs+#u;tmp = *EA;tmp [|&]= Rt;*EA = tmp;"
+memh(Rs+#u6:1)=clrbit(#U5),"apply_extension(#u);EA=Rs+#u;tmp = *EA;tmp &= (~(1<<#U));*EA = tmp;"
+memh(Rs+#u6:1)=setbit(#U5),"apply_extension(#u);EA=Rs+#u;tmp = *EA;tmp |= (1<<#U);*EA = tmp;"
+memh(Rs+#u6:1)[+-]=#U5,"apply_extension(#u);EA=Rs[+-]#u;tmp = *EA;tmp [+-]= #U;*EA = tmp;"
+memh(Rs+#u6:1)[+-]=Rt,"apply_extension(#u);EA=Rs+#u;tmp = *EA;tmp [+-]= Rt;*EA = tmp;"
+memh(Rs+#u6:1)[|&]=Rt,"apply_extension(#u);EA=Rs+#u;tmp = *EA;tmp [|&]= Rt;*EA = tmp;"
+memw(Rs+#u6:2)=clrbit(#U5),"apply_extension(#u);EA=Rs+#u;tmp = *EA;tmp &= (~(1<<#U));*EA = tmp;"
+memw(Rs+#u6:2)=setbit(#U5),"apply_extension(#u);EA=Rs+#u;tmp = *EA;tmp |= (1<<#U);*EA = tmp;"
+memw(Rs+#u6:2)[+-]=#U5,"apply_extension(#u);EA=Rs[+-]#u;tmp = *EA;tmp [+-]= #U;*EA = tmp;"
+memw(Rs+#u6:2)[+-]=Rt,"apply_extension(#u);EA=Rs+#u;tmp = *EA;tmp [+-]= Rt;*EA = tmp;"
+memw(Rs+#u6:2)[|&]=Rt,"apply_extension(#u);EA=Rs+#u;tmp = *EA;tmp [|&]= Rt;*EA = tmp;"
+"if ([!]cmp.eq(Ns.new,#-1))jump:<hint> #r9:2",";if ((Ns.new[!]=(-1))) {apply_extension(#r);#r=#r & ~0x3;PC=PC+#r;};"
+"if ([!]cmp.eq(Ns.new,#U5))jump:<hint> #r9:2",";if ((Ns.new[!]=(#U))) {apply_extension(#r);#r=#r & ~0x3;PC=PC+#r;};"
+"if ([!]cmp.eq(Ns.new,Rt))jump:<hint> #r9:2",";if ((Ns.new[!]=Rt)) {apply_extension(#r);#r=#r & ~0x3;PC=PC+#r;};"
+"if ([!]cmp.gt(Ns.new,#-1))jump:<hint> #r9:2",";if ([!](Ns.new>(-1))) {apply_extension(#r);#r=#r & ~0x3;PC=PC+#r;};"
+"if ([!]cmp.gt(Ns.new,#U5))jump:<hint> #r9:2",";if ([!](Ns.new>(#U))) {apply_extension(#r);#r=#r & ~0x3;PC=PC+#r;};"
+"if ([!]cmp.gt(Ns.new,Rt))jump:<hint> #r9:2",";if ([!](Ns.new>Rt)) {apply_extension(#r);#r=#r & ~0x3;PC=PC+#r;};"
+"if ([!]cmp.gt(Rt,Ns.new))jump:<hint> #r9:2",";if ([!](Rt>Ns.new)) {apply_extension(#r);#r=#r & ~0x3;PC=PC+#r;};"
+"if ([!]cmp.gtu(Ns.new,#U5))jump:<hint> #r9:2",";if ([!](Ns.new.uw[0]>(#U))) {apply_extension(#r);#r=#r & ~0x3;PC=PC+#r;};"
+"if ([!]cmp.gtu(Ns.new,Rt))jump:<hint> #r9:2",";if ([!](Ns.new.uw[0]>Rt.uw[0])) {apply_extension(#r);#r=#r & ~0x3;PC=PC+#r;};"
+"if ([!]cmp.gtu(Rt,Ns.new))jump:<hint> #r9:2",";if ([!](Rt.uw[0]>Ns.new.uw[0])) {apply_extension(#r);#r=#r & ~0x3;PC=PC+#r;};"
+"if ([!]tstbit(Ns.new,#0))jump:<hint> #r9:2",";if ([!]((Ns.new) & 1)) {apply_extension(#r);#r=#r & ~0x3;PC=PC+#r;};"
+memb(Re=#U6)=Nt.new,"apply_extension(#U);EA=#U;*EA = Nt.new&0xff;Re=#U;"
+memb(Rs+#s11:0)=Nt.new,"apply_extension(#s);EA=Rs+#s;*EA = Nt.new&0xff;"
+memb(Rs+Ru<<#u2)=Nt.new,"EA=Rs+(Ru<<#u);*EA = Nt.new&0xff;"
+memb(Ru<<#u2+#U6)=Nt.new,"apply_extension(#U);EA=#U+(Ru<<#u);*EA = Nt.new&0xff;"
+memb(Rx++#s4:0)=Nt.new,"EA=Rx;Rx=Rx+#s;*EA = Nt.new&0xff;"
+memb(Rx++#s4:0:circ(Mu))=Nt.new,"EA=Rx;Rx=Rx=circ_add(Rx,#s,MuV);*EA = Nt.new&0xff;"
+memb(Rx++I:circ(Mu))=Nt.new,"EA=Rx;Rx=Rx=circ_add(Rx,I<<0,MuV);*EA = Nt.new&0xff;"
+memb(Rx++Mu)=Nt.new,"EA=Rx;Rx=Rx+MuV;*EA = Nt.new&0xff;"
+memb(Rx++Mu:brev)=Nt.new,"EA=Rx.h[1] | brev(Rx.h[0]);Rx=Rx+MuV;*EA = Nt.new&0xff;"
+memb(gp+#u16:0)=Nt.new,"apply_extension(#u);EA=(Constant_extended ? (0) : GP)+#u;*EA = Nt.new&0xff;"
+"if ([!]Pv[.new])memb(#u6)=Nt.new","if ([!]Pv[.new][0]) {apply_extension(#u);EA=#u;*EA = Nt[.new]&0xff;} else {NOP;};"
+"if ([!]Pv[.new])memb(Rs+#u6:0)=Nt.new","apply_extension(#u);if ([!]Pv[.new][0]) {EA=Rs+#u;*EA = Nt[.new]&0xff;} else {NOP;};"
+"if ([!]Pv[.new])memb(Rs+Ru<<#u2)=Nt.new","if ([!]Pv[.new][0]) {EA=Rs+(Ru<<#u);*EA = Nt[.new]&0xff;} else {NOP;};"
+"if ([!]Pv[.new])memb(Rx++#s4:0)=Nt.new","if ([!]Pv[.new][0]){EA=Rx;Rx=Rx+#s;*EA = Nt[.new]&0xff;} else {NOP;};"
+memh(Re=#U6)=Nt.new,"apply_extension(#U);EA=#U;*EA = Nt.new.h[0];Re=#U;"
+memh(Rs+#s11:1)=Nt.new,"apply_extension(#s);EA=Rs+#s;*EA = Nt.new.h[0];"
+memh(Rs+Ru<<#u2)=Nt.new,"EA=Rs+(Ru<<#u);*EA = Nt.new.h[0];"
+memh(Ru<<#u2+#U6)=Nt.new,"apply_extension(#U);EA=#U+(Ru<<#u);*EA = Nt.new.h[0];"
+memh(Rx++#s4:1)=Nt.new,"EA=Rx;Rx=Rx+#s;*EA = Nt.new.h[0];"
+memh(Rx++#s4:1:circ(Mu))=Nt.new,"EA=Rx;Rx=Rx=circ_add(Rx,#s,MuV);*EA = Nt.new.h[0];"
+memh(Rx++I:circ(Mu))=Nt.new,"EA=Rx;Rx=Rx=circ_add(Rx,I<<1,MuV);*EA = Nt.new.h[0];"
+memh(Rx++Mu)=Nt.new,"EA=Rx;Rx=Rx+MuV;*EA = Nt.new.h[0];"
+memh(Rx++Mu:brev)=Nt.new,"EA=Rx.h[1] | brev(Rx.h[0]);Rx=Rx+MuV;*EA = Nt.new.h[0];"
+memh(gp+#u16:1)=Nt.new,"apply_extension(#u);EA=(Constant_extended ? (0) : GP)+#u;*EA = Nt.new.h[0];"
+"if ([!]Pv[.new])memh(#u6)=Nt.new","if ([!]Pv[.new][0]) {apply_extension(#u);EA=#u;*EA = Nt[.new].h[0];} else {NOP;};"
+"if ([!]Pv[.new])memh(Rs+#u6:1)=Nt.new","apply_extension(#u);if ([!]Pv[.new][0]) {EA=Rs+#u;*EA = Nt[.new].h[0];} else {NOP;};"
+"if ([!]Pv[.new])memh(Rs+Ru<<#u2)=Nt.new","if ([!]Pv[.new][0]) {EA=Rs+(Ru<<#u);*EA = Nt[.new].h[0];} else {NOP;};"
+"if ([!]Pv[.new])memh(Rx++#s4:1)=Nt.new","if ([!]Pv[.new][0]){EA=Rx;Rx=Rx+#s;*EA = Nt[.new].h[0];} else {NOP;};"
+memw(Re=#U6)=Nt.new,"apply_extension(#U);EA=#U;*EA = Nt.new;Re=#U;"
+memw(Rs+#s11:2)=Nt.new,"apply_extension(#s);EA=Rs+#s;*EA = Nt.new;"
+memw(Rs+Ru<<#u2)=Nt.new,"EA=Rs+(Ru<<#u);*EA = Nt.new;"
+memw(Ru<<#u2+#U6)=Nt.new,"apply_extension(#U);EA=#U+(Ru<<#u);*EA = Nt.new;"
+memw(Rx++#s4:2)=Nt.new,"EA=Rx;Rx=Rx+#s;*EA = Nt.new;"
+memw(Rx++#s4:2:circ(Mu))=Nt.new,"EA=Rx;Rx=Rx=circ_add(Rx,#s,MuV);*EA = Nt.new;"
+memw(Rx++I:circ(Mu))=Nt.new,"EA=Rx;Rx=Rx=circ_add(Rx,I<<2,MuV);*EA = Nt.new;"
+memw(Rx++Mu)=Nt.new,"EA=Rx;Rx=Rx+MuV;*EA = Nt.new;"
+memw(Rx++Mu:brev)=Nt.new,"EA=Rx.h[1] | brev(Rx.h[0]);Rx=Rx+MuV;*EA = Nt.new;"
+memw(gp+#u16:2)=Nt.new,"apply_extension(#u);EA=(Constant_extended ? (0) : GP)+#u;*EA = Nt.new;"
+"if ([!]Pv[.new])memw(#u6)=Nt.new","if ([!]Pv[.new][0]) {apply_extension(#u);EA=#u;*EA = Nt[.new];} else {NOP;};"
+"if ([!]Pv[.new])memw(Rs+#u6:2)=Nt.new","apply_extension(#u);if ([!]Pv[.new][0]) {EA=Rs+#u;*EA = Nt[.new];} else {NOP;};"
+"if ([!]Pv[.new])memw(Rs+Ru<<#u2)=Nt.new","if ([!]Pv[.new][0]) {EA=Rs+(Ru<<#u);*EA = Nt[.new];} else {NOP;};"
+"if ([!]Pv[.new])memw(Rx++#s4:2)=Nt.new","if ([!]Pv[.new][0]){EA=Rx;Rx=Rx+#s;*EA = Nt[.new];} else {NOP;};"
+memd(Re=#U6)=Rtt,"apply_extension(#U);EA=#U;*EA = Rtt;Re=#U;"
+memd(Rs+#s11:3)=Rtt,"apply_extension(#s);EA=Rs+#s;*EA = Rtt;"
+memd(Rs+Ru<<#u2)=Rtt,"EA=Rs+(Ru<<#u);*EA = Rtt;"
+memd(Ru<<#u2+#U6)=Rtt,"apply_extension(#U);EA=#U+(Ru<<#u);*EA = Rtt;"
+memd(Rx++#s4:3)=Rtt,"EA=Rx;Rx=Rx+#s;*EA = Rtt;"
+memd(Rx++#s4:3:circ(Mu))=Rtt,"EA=Rx;Rx=Rx=circ_add(Rx,#s,MuV);*EA = Rtt;"
+memd(Rx++I:circ(Mu))=Rtt,"EA=Rx;Rx=Rx=circ_add(Rx,I<<3,MuV);*EA = Rtt;"
+memd(Rx++Mu)=Rtt,"EA=Rx;Rx=Rx+MuV;*EA = Rtt;"
+memd(Rx++Mu:brev)=Rtt,"EA=Rx.h[1] | brev(Rx.h[0]);Rx=Rx+MuV;*EA = Rtt;"
+memd(gp+#u16:3)=Rtt,"apply_extension(#u);EA=(Constant_extended ? (0) : GP)+#u;*EA = Rtt;"
+"if ([!]Pv[.new])memd(#u6)=Rtt","if ([!]Pv[.new][0]) {apply_extension(#u);EA=#u;*EA = Rtt;} else {NOP;};"
+"if ([!]Pv[.new])memd(Rs+#u6:3)=Rtt","apply_extension(#u);if ([!]Pv[.new][0]) {EA=Rs+#u;*EA = Rtt;} else {NOP;};"
+"if ([!]Pv[.new])memd(Rs+Ru<<#u2)=Rtt","if ([!]Pv[.new][0]) {EA=Rs+(Ru<<#u);*EA = Rtt;} else {NOP;};"
+"if ([!]Pv[.new])memd(Rx++#s4:3)=Rtt","if ([!]Pv[.new][0]){EA=Rx;Rx=Rx+#s;*EA = Rtt;} else {NOP;};"
+memb(Re=#U6)=Rt,"apply_extension(#U);EA=#U;*EA = Rt&0xff;Re=#U;"
+memb(Rs+#s11:0)=Rt,"apply_extension(#s);EA=Rs+#s;*EA = Rt&0xff;"
+memb(Rs+#u6:0)=#S8,"EA=Rs+#u;apply_extension(#S);*EA = #S;"
+memb(Rs+Ru<<#u2)=Rt,"EA=Rs+(Ru<<#u);*EA = Rt&0xff;"
+memb(Ru<<#u2+#U6)=Rt,"apply_extension(#U);EA=#U+(Ru<<#u);*EA = Rt&0xff;"
+memb(Rx++#s4:0)=Rt,"EA=Rx;Rx=Rx+#s;*EA = Rt&0xff;"
+memb(Rx++#s4:0:circ(Mu))=Rt,"EA=Rx;Rx=Rx=circ_add(Rx,#s,MuV);*EA = Rt&0xff;"
+memb(Rx++I:circ(Mu))=Rt,"EA=Rx;Rx=Rx=circ_add(Rx,I<<0,MuV);*EA = Rt&0xff;"
+memb(Rx++Mu)=Rt,"EA=Rx;Rx=Rx+MuV;*EA = Rt&0xff;"
+memb(Rx++Mu:brev)=Rt,"EA=Rx.h[1] | brev(Rx.h[0]);Rx=Rx+MuV;*EA = Rt&0xff;"
+memb(gp+#u16:0)=Rt,"apply_extension(#u);EA=(Constant_extended ? (0) : GP)+#u;*EA = Rt&0xff;"
+"if ([!]Pv[.new])memb(#u6)=Rt","if ([!]Pv[.new][0]) {apply_extension(#u);EA=#u;*EA = Rt&0xff;} else {NOP;};"
+"if ([!]Pv[.new])memb(Rs+#u6:0)=#S6","if ([!]Pv[.new][0]){EA=Rs+#u;apply_extension(#S);*EA = #S;} else {NOP;};"
+"if ([!]Pv[.new])memb(Rs+#u6:0)=Rt","apply_extension(#u);if ([!]Pv[.new][0]) {EA=Rs+#u;*EA = Rt&0xff;} else {NOP;};"
+"if ([!]Pv[.new])memb(Rs+Ru<<#u2)=Rt","if ([!]Pv[.new][0]) {EA=Rs+(Ru<<#u);*EA = Rt&0xff;} else {NOP;};"
+"if ([!]Pv[.new])memb(Rx++#s4:0)=Rt","if ([!]Pv[.new][0]){EA=Rx;Rx=Rx+#s;*EA = Rt&0xff;} else {NOP;};"
+memh(Re=#U6)=Rt.H,"apply_extension(#U);EA=#U;*EA = Rt.h[1];Re=#U;"
+memh(Re=#U6)=Rt,"apply_extension(#U);EA=#U;*EA = Rt.h[0];Re=#U;"
+memh(Rs+#s11:1)=Rt.H,"apply_extension(#s);EA=Rs+#s;*EA = Rt.h[1];"
+memh(Rs+#s11:1)=Rt,"apply_extension(#s);EA=Rs+#s;*EA = Rt.h[0];"
+memh(Rs+#u6:1)=#S8,"EA=Rs+#u;apply_extension(#S);*EA = #S;"
+memh(Rs+Ru<<#u2)=Rt.H,"EA=Rs+(Ru<<#u);*EA = Rt.h[1];"
+memh(Rs+Ru<<#u2)=Rt,"EA=Rs+(Ru<<#u);*EA = Rt.h[0];"
+memh(Ru<<#u2+#U6)=Rt.H,"apply_extension(#U);EA=#U+(Ru<<#u);*EA = Rt.h[1];"
+memh(Ru<<#u2+#U6)=Rt,"apply_extension(#U);EA=#U+(Ru<<#u);*EA = Rt.h[0];"
+memh(Rx++#s4:1)=Rt.H,"EA=Rx;Rx=Rx+#s;*EA = Rt.h[1];"
+memh(Rx++#s4:1)=Rt,"EA=Rx;Rx=Rx+#s;*EA = Rt.h[0];"
+memh(Rx++#s4:1:circ(Mu))=Rt.H,"EA=Rx;Rx=Rx=circ_add(Rx,#s,MuV);*EA = Rt.h[1];"
+memh(Rx++#s4:1:circ(Mu))=Rt,"EA=Rx;Rx=Rx=circ_add(Rx,#s,MuV);*EA = Rt.h[0];"
+memh(Rx++I:circ(Mu))=Rt.H,"EA=Rx;Rx=Rx=circ_add(Rx,I<<1,MuV);*EA = Rt.h[1];"
+memh(Rx++I:circ(Mu))=Rt,"EA=Rx;Rx=Rx=circ_add(Rx,I<<1,MuV);*EA = Rt.h[0];"
+memh(Rx++Mu)=Rt.H,"EA=Rx;Rx=Rx+MuV;*EA = Rt.h[1];"
+memh(Rx++Mu)=Rt,"EA=Rx;Rx=Rx+MuV;*EA = Rt.h[0];"
+memh(Rx++Mu:brev)=Rt.H,"EA=Rx.h[1] | brev(Rx.h[0]);Rx=Rx+MuV;*EA = Rt.h[1];"
+memh(Rx++Mu:brev)=Rt,"EA=Rx.h[1] | brev(Rx.h[0]);Rx=Rx+MuV;*EA = Rt.h[0];"
+memh(gp+#u16:1)=Rt.H,"apply_extension(#u);EA=(Constant_extended ? (0) : GP)+#u;*EA = Rt.h[1];"
+memh(gp+#u16:1)=Rt,"apply_extension(#u);EA=(Constant_extended ? (0) : GP)+#u;*EA = Rt.h[0];"
+"if ([!]Pv[.new])memh(#u6)=Rt.H","if ([!]Pv[.new][0]) {apply_extension(#u);EA=#u;*EA = Rt.h[1];} else {NOP;};"
+"if ([!]Pv[.new])memh(#u6)=Rt","if ([!]Pv[.new][0]) {apply_extension(#u);EA=#u;*EA = Rt.h[0];} else {NOP;};"
+"if ([!]Pv[.new])memh(Rs+#u6:1)=#S6","if ([!]Pv[.new][0]){EA=Rs+#u;apply_extension(#S);*EA = #S;} else {NOP;};"
+"if ([!]Pv[.new])memh(Rs+#u6:1)=Rt.H","apply_extension(#u);if ([!]Pv[.new][0]) {EA=Rs+#u;*EA = Rt.h[1];} else {NOP;};"
+"if ([!]Pv[.new])memh(Rs+#u6:1)=Rt","apply_extension(#u);if ([!]Pv[.new][0]) {EA=Rs+#u;*EA = Rt.h[0];} else {NOP;};"
+"if ([!]Pv[.new])memh(Rs+Ru<<#u2)=Rt.H","if ([!]Pv[.new][0]) {EA=Rs+(Ru<<#u);*EA = Rt.h[1];} else {NOP;};"
+"if ([!]Pv[.new])memh(Rs+Ru<<#u2)=Rt","if ([!]Pv[.new][0]) {EA=Rs+(Ru<<#u);*EA = Rt.h[0];} else {NOP;};"
+"if ([!]Pv[.new])memh(Rx++#s4:1)=Rt.H","if ([!]Pv[.new][0]){EA=Rx;Rx=Rx+#s;*EA = Rt.h[1];} else {NOP;};"
+"if ([!]Pv[.new])memh(Rx++#s4:1)=Rt","if ([!]Pv[.new][0]){EA=Rx;Rx=Rx+#s;*EA = Rt.h[0];} else {NOP;};"
+memw(Re=#U6)=Rt,"apply_extension(#U);EA=#U;*EA = Rt;Re=#U;"
+memw(Rs+#s11:2)=Rt,"apply_extension(#s);EA=Rs+#s;*EA = Rt;"
+memw(Rs+#u6:2)=#S8,"EA=Rs+#u;apply_extension(#S);*EA = #S;"
+memw(Rs+Ru<<#u2)=Rt,"EA=Rs+(Ru<<#u);*EA = Rt;"
+memw(Ru<<#u2+#U6)=Rt,"apply_extension(#U);EA=#U+(Ru<<#u);*EA = Rt;"
+memw(Rx++#s4:2)=Rt,"EA=Rx;Rx=Rx+#s;*EA = Rt;"
+memw(Rx++#s4:2:circ(Mu))=Rt,"EA=Rx;Rx=Rx=circ_add(Rx,#s,MuV);*EA = Rt;"
+memw(Rx++I:circ(Mu))=Rt,"EA=Rx;Rx=Rx=circ_add(Rx,I<<2,MuV);*EA = Rt;"
+memw(Rx++Mu)=Rt,"EA=Rx;Rx=Rx+MuV;*EA = Rt;"
+memw(Rx++Mu:brev)=Rt,"EA=Rx.h[1] | brev(Rx.h[0]);Rx=Rx+MuV;*EA = Rt;"
+memw(gp+#u16:2)=Rt,"apply_extension(#u);EA=(Constant_extended ? (0) : GP)+#u;*EA = Rt;"
+"if ([!]Pv[.new])memw(#u6)=Rt","if ([!]Pv[.new][0]) {apply_extension(#u);EA=#u;*EA = Rt;} else {NOP;};"
+"if ([!]Pv[.new])memw(Rs+#u6:2)=#S6","if ([!]Pv[.new][0]){EA=Rs+#u;apply_extension(#S);*EA = #S;} else {NOP;};"
+"if ([!]Pv[.new])memw(Rs+#u6:2)=Rt","apply_extension(#u);if ([!]Pv[.new][0]) {EA=Rs+#u;*EA = Rt;} else {NOP;};"
+"if ([!]Pv[.new])memw(Rs+Ru<<#u2)=Rt","if ([!]Pv[.new][0]) {EA=Rs+(Ru<<#u);*EA = Rt;} else {NOP;};"
+"if ([!]Pv[.new])memw(Rx++#s4:2)=Rt","if ([!]Pv[.new][0]){EA=Rx;Rx=Rx+#s;*EA = Rt;} else {NOP;};"
+allocframe(#u11:3),"EA=SP-8;*EA=frame_scramble((zxt32->64(LR) << 32) | zxt32->64(FP));FP=EA;frame_check_limit(EA-#u);SP=EA-#u;"
+Gd=Rs,Gd=Rs;
+Gdd=Rss,Gdd=Rss;
+Rd=Gs,Rd=Gs;
+Rdd=Gss,Rdd=Gss;
+ciad(Rs),IAD &= ~Rs;
+"crswap(Rx,sgp)","Assembler mapped to: ""crswap(Rx,sgp0)"""
+"crswap(Rx,sgp0)","tmp = Rx;Rx = SGP0;SGP0 = tmp;"
+"crswap(Rx,sgp1)","tmp = Rx;Rx = SGP1;SGP1 = tmp;"
+"crswap(Rxx,sgp1:0)","tmp = Rxx;Rxx=SGP;SGP = tmp;"
+cswi(Rs),IPEND &= ~Rs;
+dckill,dcache_inv_all();
+Rd=dctagr(Rs),dcache_tag_read(Rs);
+dccleanidx(Rs),dcache_clean_idx(Rs);
+dccleaninvidx(Rs),"dcache_clean_idx(Rs);dcache_inv_idx(Rs);"
+dcinvidx(Rs),dcache_inv_idx(Rs);
+"dctagw(Rs,Rt)","dcache_tag_write(Rs,Rt);"
+Rd=getimask(Rs),Rd=IMASK[Rs&0x7];
+k0lock,"if (can_aquire_k0_lock) {SYSCFG.K0LOCK = 1;} else {sleep_until_available;};"
+tlblock,"if (can_aquire_tlb_lock) {SYSCFG.TLBLOCK = 1;} else {sleep_until_available;};"
+k0unlock,SYSCFG.K0LOCK = 0;
+tlbunlock,SYSCFG.TLBLOCK = 0;
+Rd=iassignr(Rs),Rd=IASSIGNR(Rs);
+iassignw(Rs),IASSIGNW(Rs);
+Rd=icdatar(Rs),icache_data_read(Rs);
+Rd=ictagr(Rs),icache_tag_read(Rs);
+icinvidx(Rs),icache_inv_idx(Rs);
+ickill,icache_inv_all();
+"ictagw(Rs,Rt)","icache_tag_write(Rs,Rt);"
+l2cleanidx(Rs),l2cache_clean_idx(Rs);
+l2cleaninvidx(Rs),l2cache_clean_invalidate_idx(Rs);
+l2invidx(Rs),l2cache_inv_idx(Rs);
+l2gclean,l2cache_global_clean();
+l2gclean(Rtt),l2cache_global_clean_range(Rtt);
+l2gcleaninv,l2cache_global_clean_inv();
+l2gcleaninv(Rtt),l2cache_global_clean_inv_range(Rtt);
+l2gunlock,l2cache_global_unlock();
+l2kill,l2cache_inv_all();
+Pd=l2locka(Rs),"EA=Rs;Pd=l2locka(EA);"
+l2unlocka(Rs),"EA=Rs;l2unlocka(EA);"
+Rd=l2tagr(Rs),l2cache_tag_read(Rs);
+"l2tagw(Rs,Rt)","l2cache_tag_write(Rs,Rt);"
+"Rd=memw_phys(Rs,Rt)",Rd = *((Rs&0x7ff) | (Rt<<11));
+nmi(Rs),Raise NMI on threads;
+resume(Rs),"for (i = 0; i < THREADS_MAX; i++) {if (Rs.i) {modectl[(i+16)] = 0;};};"
+rte,"SSR.SSR_EX = 0;PC=ELR;"
+rteunlock,"SSR.SSR_EX = 0;SYSCFG.TLBLOCK = 0;PC=ELR;"
+"setimask(Pt,Rs)",IMASK[Pt&0x7]=Rs;
+siad(Rs),IAD |= Rs;
+start(Rs),"for (i = 0; i < THREADS_MAX; i++) {if (Rs.i && (modectl[i] == 0)) {modectl[i] = 1;reset_thread(i);};};"
+stop(Rs),if (!in_debug_mode) modectl[TNUM] = 0;
+swi(Rs),IPEND |= Rs;
+"Rd=ctlbw(Rss,Rt)","if (CHECK_TLB_OVERLAP((1LL<<63) | Rss)) {Rd=GET_OVERLAPPING_IDX((1LL<<63) |Rss);} else {TLB[Rt] = Rss;Rd=0x80000000;};"
+Rd=tlboc(Rss),"if (CHECK_TLB_OVERLAP((1LL<<63) | Rss)) {Rd=GET_OVERLAPPING_IDX((1LL<<63) |Rss);} else {Rd=0x80000000;};"
+Rd=tlbp(Rs),Rd=search_TLB(Rs);
+Rdd=tlbr(Rs),Rdd = TLB[Rs];
+tlbinvasid(Rs),"for (i = 0; i < NUM_TLB_ENTRIES; i++) {if ((TLB[i].PTE_G == 0) &&(TLB[i].PTE_ASID == Rs[26:20])) {TLB[i] = TLB[i] & ~(1ULL << 63);};};"
+"tlbw(Rss,Rt)",TLB[Rt] = Rss;
+Rd=Ss,Rd=Ss;
+Rdd=Sss,Rdd=Sss;
+Sd=Rs,Sd=Rs;
+Sdd=Rss,Sdd=Rss;
+wait(Rs),if (!in_debug_mode) modectl[(TNUM+16)] = 1;
+Rd=memw_locked(Rs),"EA=Rs;Rd = *EA;"
+Rdd=memd_locked(Rs),"EA=Rs;Rdd = *EA;"
+"memd_locked(Rs,Pd)=Rtt","EA=Rs;if (lock_valid) {*EA = Rtt;Pd = 0xff;lock_valid = 0;} else {Pd = 0;};"
+"memw_locked(Rs,Pd)=Rt","EA=Rs;if (lock_valid) {*EA = Rt;Pd = 0xff;lock_valid = 0;} else {Pd = 0;};"
+dczeroa(Rs),"EA=Rs;dcache_zero_addr(EA);"
+barrier,memory_barrier;
+brkpt,Enter debug mode;
+dcfetch(Rs),"Assembler mapped to: ""dcfetch(Rs+#0)"""
+dcfetch(Rs+#u11:3),"EA=Rs+#u;dcache_fetch(EA);"
+dccleana(Rs),"EA=Rs;dcache_clean_addr(EA);"
+dccleaninva(Rs),"EA=Rs;dcache_cleaninv_addr(EA);"
+dcinva(Rs),"EA=Rs;dcache_cleaninv_addr(EA);"
+icinva(Rs),"EA=Rs;icache_inv_addr(EA);"
+isync,instruction_sync;
+"l2fetch(Rs,Rt)","l2fetch(Rs,INFO);"
+"l2fetch(Rs,Rtt)","l2fetch(Rs,INFO);"
+pause(#u8),Pause for #u cycles;
+syncht,memory_synch;
+trace(Rs),Send value to ETM trace;
+trap0(#u8),"SSR.CAUSE = #u;TRAP ""0"";"
+trap1(#u8),"SSR.CAUSE = #u;TRAP ""1"";"
+Rdd=abs(Rss),Rdd = ABS(Rss);
+Rd=abs(Rs)[:sat],Rd = [sat32](ABS(sxt32->64(Rs)));
+"Rd=add(Rs,add(Ru,#s6))",Rd = Rs + Ru + apply_extension(#s);
+"Rd=add(Rs,sub(#u6,Ru))",Rd = Rs - Ru + apply_extension(#u);
+"Rx+=add(Rs,#s8)","apply_extension(#s);Rx=Rx + Rs + #s;"
+"Rx+=add(Rs,Rt)",Rx=Rx + Rs + Rt;
+"Rx-=add(Rs,#s8)","apply_extension(#s);Rx=Rx - (Rs + #s);"
+"Rx-=add(Rs,Rt)",Rx=Rx - (Rs + Rt);
+"Rd=add(Rs,Rt):sat:deprecated",Rd=sat32(Rs+Rt);
+"Rdd=add(Rs,Rtt)","if (""Rs & 1"") {Assembler mapped to:""Rdd=add(Rss,Rtt):raw:hi"";} else {Assembler mapped to:""Rdd=add(Rss,Rtt):raw:lo"";};"
+"Rdd=add(Rss,Rtt)",Rdd=Rss+Rtt;
+"Rdd=add(Rss,Rtt):raw:hi",Rdd=Rtt+sxt32->64(Rss.w[1]);
+"Rdd=add(Rss,Rtt):raw:lo",Rdd=Rtt+sxt32->64(Rss.w[0]);
+"Rdd=add(Rss,Rtt):sat",Rdd=sat64(Rss+Rtt);
+"Rd=add(Rt.L,Rs.[HL])[:sat]",Rd=[sat16](Rt.h[0]+Rs.h[01]);
+"Rd=add(Rt.[HL],Rs.[HL])[:sat]:<<16",Rd=([sat16](Rt.h[01]+Rs.h[01]))<<16;
+"Rdd=add(Rss,Rtt,Px):carry","Rdd = Rss + Rtt + Px[0];Px = carry_from_add(Rss,Rtt,Px[0]) ? 0xff :0x00;"
+"Rdd=sub(Rss,Rtt,Px):carry","Rdd = Rss + ~Rtt + Px[0];Px = carry_from_add(Rss,~Rtt,Px[0]) ? 0xff: 0x00;"
+"Rdd=and(Rss,Rtt)",Rdd=Rss&Rtt;
+"Rdd=and(Rtt,~Rss)",Rdd = (Rtt & ~Rss);
+Rdd=not(Rss),Rdd=~Rss;
+"Rdd=or(Rss,Rtt)",Rdd=Rss|Rtt;
+"Rdd=or(Rtt,~Rss)",Rdd = (Rtt | ~Rss);
+"Rdd=xor(Rss,Rtt)",Rdd=Rss^Rtt;
+"Rxx^=xor(Rss,Rtt)",Rxx^=Rss^Rtt;
+"Rx=or(Ru,and(Rx,#s10))",Rx = Ru | (Rx & apply_extension(#s));
+"Rx[&|]=and(Rs,Rt)",Rx [|&]= (Rs [|&] Rt);
+"Rx^=and(Rs,Rt)",Rx ^= (Rs ^ Rt);
+"Rx[&|]=and(Rs,~Rt)",Rx [|&]= (Rs [|&] ~Rt);
+"Rx^=and(Rs,~Rt)",Rx ^= (Rs ^ ~Rt);
+"Rx[&|]=or(Rs,Rt)",Rx [|&]= (Rs [|&] Rt);
+"Rx^=or(Rs,Rt)",Rx ^= (Rs ^ Rt);
+"Rx[&|]=xor(Rs,Rt)",Rx[|&]=Rs[|&]Rt;
+"Rx^=xor(Rs,Rt)",Rx^=Rs^Rt;
+"Rx|=and(Rs,#s10)",Rx = Rx | (Rs & apply_extension(#s));
+"Rx|=or(Rs,#s10)",Rx = Rx | (Rs | apply_extension(#s));
+"Rd=max(Rs,Rt)","Rd = max(Rs,Rt);"
+"Rd=maxu(Rs,Rt)","Rd = max(Rs.uw[0],Rt.uw[0]);"
+"Rdd=max(Rss,Rtt)","Rdd = max(Rss,Rtt);"
+"Rdd=maxu(Rss,Rtt)","Rdd = max(Rss.u64,Rtt.u64);"
+"Rd=min(Rt,Rs)","Rd = min(Rt,Rs);"
+"Rd=minu(Rt,Rs)","Rd = min(Rt.uw[0],Rs.uw[0]);"
+"Rdd=min(Rtt,Rss)","Rdd = min(Rtt,Rss);"
+"Rdd=minu(Rtt,Rss)","Rdd = min(Rtt.u64,Rss.u64);"
+"Rd=modwrap(Rs,Rt)","if (Rs < 0) {Rd = Rs + Rt.uw[0];} else if (Rs.uw[0] >= Rt.uw[0]) {Rd = Rs - Rt.uw[0];} else {Rd = Rs;};"
+Rd=neg(Rs):sat,Rd = sat32(-Rs.s64);
+Rdd=neg(Rss),Rdd = -Rss;
+"Rd=cround(Rs,#u5)","Rd = (#u==0)?Rs:convround(Rs,2**(#u-1))>>#u;"
+"Rd=cround(Rs,Rt)","Rd = (zxt5->32(Rt)==0)?Rs:convround(Rs,2**(zxt5->32(Rt)-1))>>zxt5->32(Rt);"
+"Rd=round(Rs,#u5)[:sat]","Rd = ([sat32]((#u==0)?(Rs):round(Rs,2**(#u-1))))>>#u;"
+"Rd=round(Rs,Rt)[:sat]","Rd = ([sat32]((zxt5->32(Rt)==0)?(Rs):round(Rs,2**(zxt5->32(Rt)-1))))>>zxt5->32(Rt);"
+Rd=round(Rss):sat,"tmp=sat64(Rss+0x080000000ULL);Rd = tmp.w[1];"
+"Rd=sub(Rt,Rs):sat:deprecated",Rd=sat32(Rt - Rs);
+"Rdd=sub(Rtt,Rss)",Rdd=Rtt-Rss;
+"Rx+=sub(Rt,Rs)",Rx=Rx + (Rt - Rs);
+"Rd=sub(Rt.L,Rs.[HL])[:sat]",Rd=[sat16](Rt.h[0]-Rs.h[01]);
+"Rd=sub(Rt.[HL],Rs.[HL])[:sat]:<<16",Rd=([sat16](Rt.h[01]-Rs.h[01]))<<16;
+Rdd=sxtw(Rs),Rdd = sxt32->64(Rs);
+Rdd=vabsh(Rss),"for (i=0;i<4;i++) {Rdd.h[i]=ABS(Rss.h[i]);};"
+Rdd=vabsh(Rss):sat,"for (i=0;i<4;i++) {Rdd.h[i]=sat16(ABS(Rss.h[i]));};"
+Rdd=vabsw(Rss),"for (i=0;i<2;i++) {Rdd.w[i]=ABS(Rss.w[i]);};"
+Rdd=vabsw(Rss):sat,"for (i=0;i<2;i++) {Rdd.w[i]=sat32(ABS(Rss.w[i]));};"
+"Rdd=vabsdiffb(Rtt,Rss)","for (i=0;i<8;i++) {Rdd.b[i]=ABS(Rtt.b[i] - Rss.b[i]);};"
+"Rdd=vabsdiffub(Rtt,Rss)","for (i=0;i<8;i++) {Rdd.b[i]=ABS(Rtt.ub[i] - Rss.ub[i]);};"
+"Rdd=vabsdiffh(Rtt,Rss)","for (i=0;i<4;i++) {Rdd.h[i]=ABS(Rtt.h[i] - Rss.h[i]);};"
+"Rdd=vabsdiffw(Rtt,Rss)","for (i=0;i<2;i++) {Rdd.w[i]=ABS(Rtt.w[i] - Rss.w[i]);};"
+"Rxx,Pe=vacsh(Rss,Rtt)","for (i = 0; i < 4; i++) {xv = (int) Rxx.h[i];sv = (int) Rss.h[i];tv = (int) Rtt.h[i];xv = xv + tv;sv = sv - tv;Pe.i*2 = (xv > sv);Pe.i*2+1 = (xv > sv);Rxx.h[i]=sat16(max(xv,sv));};"
+"Rdd=vaddh(Rss,Rtt)[:sat]","for (i=0;i<4;i++) {Rdd.h[i]=[sat16](Rss.h[i]+Rtt.h[i]);};"
+"Rdd=vadduh(Rss,Rtt):sat","for (i=0;i<4;i++) {Rdd.h[i]=usat16(Rss.uh[i]+Rtt.uh[i]);};"
+"Rd=vaddhub(Rss,Rtt):sat","for (i=0;i<4;i++) {Rd.b[i]=usat8(Rss.h[i]+Rtt.h[i]);};"
+"Rdd=vraddub(Rss,Rtt)","Rdd = 0;for (i=0;i<4;i++) {Rdd.w[0]=(Rdd.w[0] +(Rss.ub[i]+Rtt.ub[i]));};for (i=4;i<8;i++) {Rdd.w[1]=(Rdd.w[1] +(Rss.ub[i]+Rtt.ub[i]));};"
+"Rxx+=vraddub(Rss,Rtt)","for (i = 0; i < 4; i++) {Rxx.w[0]=(Rxx.w[0] +(Rss.ub[i]+Rtt.ub[i]));};for (i = 4; i < 8; i++) {Rxx.w[1]=(Rxx.w[1] +(Rss.ub[i]+Rtt.ub[i]));};"
+"Rd=vraddh(Rss,Rtt)","Rd = 0;for (i=0;i<4;i++) {Rd += (Rss.h[i]+Rtt.h[i]);};"
+"Rd=vradduh(Rss,Rtt)","Rd = 0;for (i=0;i<4;i++) {Rd += (Rss.uh[i]+Rtt.uh[i]);};"
+"Rdd=vaddb(Rss,Rtt)","Assembler mapped to: ""Rdd=vaddub(Rss,Rtt)"""
+"Rdd=vaddub(Rss,Rtt)[:sat]","for (i = 0; i < 8; i++) {Rdd.b[i]=[usat8](Rss.ub[i]+Rtt.ub[i]);};"
+"Rdd=vaddw(Rss,Rtt)[:sat]","for (i=0;i<2;i++) {Rdd.w[i]=[sat32](Rss.w[i]+Rtt.w[i]);};"
+"Rdd=vavgh(Rss,Rtt)","for (i=0;i<4;i++) {Rdd.h[i]=(Rss.h[i]+Rtt.h[i])>>1;};"
+"Rdd=vavgh(Rss,Rtt):crnd","for (i=0;i<4;i++) {Rdd.h[i]=convround(Rss.h[i]+Rtt.h[i])>>1;};"
+"Rdd=vavgh(Rss,Rtt):rnd","for (i=0;i<4;i++) {Rdd.h[i]=(Rss.h[i]+Rtt.h[i]+1)>>1;};"
+"Rdd=vavguh(Rss,Rtt)","for (i=0;i<4;i++) {Rdd.h[i]=(Rss.uh[i]+Rtt.uh[i])>>1;};"
+"Rdd=vavguh(Rss,Rtt):rnd","for (i=0;i<4;i++) {Rdd.h[i]=(Rss.uh[i]+Rtt.uh[i]+1)>>1;};"
+"Rdd=vnavgh(Rtt,Rss)","for (i=0;i<4;i++) {Rdd.h[i]=(Rtt.h[i]-Rss.h[i])>>1;};"
+"Rdd=vnavgh(Rtt,Rss):crnd:sat","for (i=0;i<4;i++) {Rdd.h[i]=sat16(convround(Rtt.h[i]-Rss.h[i])>>1);};"
+"Rdd=vnavgh(Rtt,Rss):rnd:sat","for (i=0;i<4;i++) {Rdd.h[i]=sat16((Rtt.h[i]-Rss.h[i]+1)>>1);};"
+"Rdd=vavgub(Rss,Rtt)","for (i = 0; i < 8; i++) {Rdd.b[i]=((Rss.ub[i] + Rtt.ub[i])>>1);};"
+"Rdd=vavgub(Rss,Rtt):rnd","for (i = 0; i < 8; i++) {Rdd.b[i]=((Rss.ub[i]+Rtt.ub[i]+1)>>1);};"
+"Rdd=vavguw(Rss,Rtt)[:rnd]","for (i=0;i<2;i++) {Rdd.w[i]=(zxt32->33(Rss.uw[i])+zxt32->33(Rtt.uw[i])+1)>>1;};"
+"Rdd=vavgw(Rss,Rtt):crnd","for (i=0;i<2;i++) {Rdd.w[i]=(convround(sxt32->33(Rss.w[i])+sxt32->33(Rtt.w[i]))>>1);};"
+"Rdd=vavgw(Rss,Rtt)[:rnd]","for (i=0;i<2;i++) {Rdd.w[i]=(sxt32->33(Rss.w[i])+sxt32->33(Rtt.w[i])+1)>>1;};"
+"Rdd=vnavgw(Rtt,Rss)","for (i=0;i<2;i++) {Rdd.w[i]=(sxt32->33(Rtt.w[i])-sxt32->33(Rss.w[i]))>>1;};"
+"Rdd=vnavgw(Rtt,Rss):crnd:sat","for (i=0;i<2;i++) {Rdd.w[i]=sat32(convround(sxt32->33(Rtt.w[i])-sxt32->33(Rss.w[i]))>>1);};"
+"Rdd=vnavgw(Rtt,Rss):rnd:sat","for (i=0;i<2;i++) {Rdd.w[i]=sat32((sxt32->33(Rtt.w[i])-sxt32->33(Rss.w[i])+1)>>1);};"
+"Rdd=vcnegh(Rss,Rt)","for (i = 0; i < 4; i++) {if (Rt.i) {Rdd.h[i]=sat16(-Rss.h[i]);} else {Rdd.h[i]=Rss.h[i];};};"
+"Rxx+=vrcnegh(Rss,Rt)","for (i = 0; i < 4; i++) {if (Rt.i) {Rxx += -Rss.h[i];} else {Rxx += Rss.h[i];};};"
+"Rdd=vmaxb(Rtt,Rss)","for (i = 0; i < 8; i++) {Rdd.b[i]=max(Rtt.b[i],Rss.b[i]);};"
+"Rdd=vmaxub(Rtt,Rss)","for (i = 0; i < 8; i++) {Rdd.b[i]=max(Rtt.ub[i],Rss.ub[i]);};"
+"Rdd=vmaxh(Rtt,Rss)","for (i = 0; i < 4; i++) {Rdd.h[i]=max(Rtt.h[i],Rss.h[i]);};"
+"Rdd=vmaxuh(Rtt,Rss)","for (i = 0; i < 4; i++) {Rdd.h[i]=max(Rtt.uh[i],Rss.uh[i]);};"
+"Rxx=vrmaxh(Rss,Ru)","max = Rxx.h[0];addr = Rxx.w[1];for (i = 0; i < 4; i++) {if (max < Rss.h[i]) {max = Rss.h[i];addr = Ru | i<<1;};};Rxx.w[0]=max;Rxx.w[1]=addr;"
+"Rxx=vrmaxuh(Rss,Ru)","max = Rxx.uh[0];addr = Rxx.w[1];for (i = 0; i < 4; i++) {if (max < Rss.uh[i]) {max = Rss.uh[i];addr = Ru | i<<1;};};Rxx.w[0]=max;Rxx.w[1]=addr;"
+"Rxx=vrmaxuw(Rss,Ru)","max = Rxx.uw[0];addr = Rxx.w[1];for (i = 0; i < 2; i++) {if (max < Rss.uw[i]) {max = Rss.uw[i];addr = Ru | i<<2;};};Rxx.w[0]=max;Rxx.w[1]=addr;"
+"Rxx=vrmaxw(Rss,Ru)","max = Rxx.w[0];addr = Rxx.w[1];for (i = 0; i < 2; i++) {if (max < Rss.w[i]) {max = Rss.w[i];addr = Ru | i<<2;};};Rxx.w[0]=max;Rxx.w[1]=addr;"
+"Rdd=vmaxuw(Rtt,Rss)","for (i = 0; i < 2; i++) {Rdd.w[i]=max(Rtt.uw[i],Rss.uw[i]);};"
+"Rdd=vmaxw(Rtt,Rss)","for (i = 0; i < 2; i++) {Rdd.w[i]=max(Rtt.w[i],Rss.w[i]);};"
+"Rdd,Pe=vminub(Rtt,Rss)","for (i = 0; i < 8; i++) {Pe.i = (Rtt.ub[i] > Rss.ub[i]);Rdd.b[i]=min(Rtt.ub[i],Rss.ub[i]);};"
+"Rdd=vminb(Rtt,Rss)","for (i = 0; i < 8; i++) {Rdd.b[i]=min(Rtt.b[i],Rss.b[i]);};"
+"Rdd=vminub(Rtt,Rss)","for (i = 0; i < 8; i++) {Rdd.b[i]=min(Rtt.ub[i],Rss.ub[i]);};"
+"Rdd=vminh(Rtt,Rss)","for (i = 0; i < 4; i++) {Rdd.h[i]=min(Rtt.h[i],Rss.h[i]);};"
+"Rdd=vminuh(Rtt,Rss)","for (i = 0; i < 4; i++) {Rdd.h[i]=min(Rtt.uh[i],Rss.uh[i]);};"
+"Rxx=vrminh(Rss,Ru)","min = Rxx.h[0];addr = Rxx.w[1];for (i = 0; i < 4; i++) {if (min > Rss.h[i]) {min = Rss.h[i];addr = Ru | i<<1;};};Rxx.w[0]=min;Rxx.w[1]=addr;"
+"Rxx=vrminuh(Rss,Ru)","min = Rxx.uh[0];addr = Rxx.w[1];for (i = 0; i < 4; i++) {if (min > Rss.uh[i]) {min = Rss.uh[i];addr = Ru | i<<1;};};Rxx.w[0]=min;Rxx.w[1]=addr;"
+"Rxx=vrminuw(Rss,Ru)","min = Rxx.uw[0];addr = Rxx.w[1];for (i = 0; i < 2; i++) {if (min > Rss.uw[i]) {min = Rss.uw[i];addr = Ru | i<<2;};};Rxx.w[0]=min;Rxx.w[1]=addr;"
+"Rxx=vrminw(Rss,Ru)","min = Rxx.w[0];addr = Rxx.w[1];for (i = 0; i < 2; i++) {if (min > Rss.w[i]) {min = Rss.w[i];addr = Ru | i<<2;};};Rxx.w[0]=min;Rxx.w[1]=addr;"
+"Rdd=vminuw(Rtt,Rss)","for (i = 0; i < 2; i++) {Rdd.w[i]=min(Rtt.uw[i],Rss.uw[i]);};"
+"Rdd=vminw(Rtt,Rss)","for (i = 0; i < 2; i++) {Rdd.w[i]=min(Rtt.w[i],Rss.w[i]);};"
+"Rdd=vrsadub(Rss,Rtt)","Rdd = 0;for (i = 0; i < 4; i++) {Rdd.w[0]=(Rdd.w[0] + ABS((Rss.ub[i] -Rtt.ub[i])));};for (i = 4; i < 8; i++) {Rdd.w[1]=(Rdd.w[1] + ABS((Rss.ub[i] -Rtt.ub[i])));};"
+"Rxx+=vrsadub(Rss,Rtt)","for (i = 0; i < 4; i++) {Rxx.w[0]=(Rxx.w[0] + ABS((Rss.ub[i] -Rtt.ub[i])));};for (i = 4; i < 8; i++) {Rxx.w[1]=(Rxx.w[1] + ABS((Rss.ub[i] -Rtt.ub[i])));};"
+"Rdd=vsubh(Rtt,Rss)[:sat]","for (i=0;i<4;i++) {Rdd.h[i]=[sat16](Rtt.h[i]-Rss.h[i]);};"
+"Rdd=vsubuh(Rtt,Rss):sat","for (i=0;i<4;i++) {Rdd.h[i]=usat16(Rtt.uh[i]-Rss.uh[i]);};"
+"Rdd=vsubb(Rss,Rtt)","Assembler mapped to: ""Rdd=vsubub(Rss,Rtt)"""
+"Rdd=vsubub(Rtt,Rss)[:sat]","for (i = 0; i < 8; i++) {Rdd.b[i]=[usat8](Rtt.ub[i]-Rss.ub[i]);};"
+"Rdd=vsubw(Rtt,Rss)[:sat]","for (i=0;i<2;i++) {Rdd.w[i]=[sat32](Rtt.w[i]-Rss.w[i]);};"
+"Rd=add(clb(Rs),#s6)","Rd =(max(count_leading_ones(Rs),count_leading_ones(~Rs)))+#s;"
+"Rd=add(clb(Rss),#s6)","Rd =(max(count_leading_ones(Rss),count_leading_ones(~Rss)))+#s;"
+Rd=cl0(Rs),Rd = count_leading_ones(~Rs);
+Rd=cl0(Rss),Rd = count_leading_ones(~Rss);
+Rd=cl1(Rs),Rd = count_leading_ones(Rs);
+Rd=cl1(Rss),Rd = count_leading_ones(Rss);
+Rd=clb(Rs),"Rd =max(count_leading_ones(Rs),count_leading_ones(~Rs));"
+Rd=clb(Rss),"Rd =max(count_leading_ones(Rss),count_leading_ones(~Rss));"
+Rd=normamt(Rs),"if (Rs == 0) {Rd = 0;} else {Rd =(max(count_leading_ones(Rs),count_leading_ones(~Rs)))-1;};"
+Rd=normamt(Rss),"if (Rss == 0) {Rd = 0;} else {Rd =(max(count_leading_ones(Rss),count_leading_ones(~Rss)))-1;};"
+Rd=popcount(Rss),Rd = count_ones(Rss);
+Rd=ct0(Rs),Rd = count_leading_ones(~reverse_bits(Rs));
+Rd=ct0(Rss),"Rd =count_leading_ones(~reverse_bits(Rss));"
+Rd=ct1(Rs),Rd = count_leading_ones(reverse_bits(Rs));
+Rd=ct1(Rss),Rd = count_leading_ones(reverse_bits(Rss));
+"","width=#u;offset=#U;Rd = sxtwidth->32((Rs >> offset));"
+"Rd=extract(Rs,#u5,#U5)","width=#u;offset=#U;Rd = sxt width->32 ((Rs >> offset));"
+"Rd=extract(Rs,Rtt)","width=zxt6->32((Rtt.w[1]));offset=sxt7->32((Rtt.w[0]));Rd = sxtwidth->64((offset>0)?(zxt32->64(zxt32->64(Rs))>>>offset):(zxt32->64(zxt32->64(Rs))<<offset));"
+"Rd=extractu(Rs,#u5,#U5)","width=#u;offset=#U;Rd = zxtwidth->32((Rs >> offset));"
+"Rd=extractu(Rs,Rtt)","width=zxt6->32((Rtt.w[1]));offset=sxt7->32((Rtt.w[0]));Rd = zxtwidth->64((offset>0)?(zxt32->64(zxt32->64(Rs))>>>offset):(zxt32->64(zxt32->64(Rs))<<offset));"
+"Rdd=extract(Rss,#u6,#U6)","width=#u;offset=#U;Rdd = sxtwidth->64((Rss >> offset));"
+"Rdd=extract(Rss,Rtt)","width=zxt6->32((Rtt.w[1]));offset=sxt7->32((Rtt.w[0]));Rdd = sxtwidth->64((offset>0)?(Rss>>>offset):(Rss<<offset));"
+"Rdd=extractu(Rss,#u6,#U6)","width=#u;offset=#U;Rdd = zxtwidth->64((Rss >> offset));"
+"Rdd=extractu(Rss,Rtt)","width=zxt6->32((Rtt.w[1]));offset=sxt7->32((Rtt.w[0]));Rdd = zxtwidth->64((offset>0)?(Rss>>>offset):(Rss<<offset));"
+"Rx=insert(Rs,#u5,#U5)","width=#u;offset=#U;Rx &= ~(((1<<width)-1)<<offset);Rx |= ((Rs & ((1<<width)-1)) << offset);"
+"Rx=insert(Rs,Rtt)","width=zxt6->32((Rtt.w[1]));offset=sxt7->32((Rtt.w[0]));mask = ((1<<width)-1);if (offset < 0) {Rx = 0;} else {Rx &= ~(mask<<offset);Rx |= ((Rs & mask) << offset);};"
+"Rxx=insert(Rss,#u6,#U6)","width=#u;offset=#U;Rxx &= ~(((1<<width)-1)<<offset);Rxx |= ((Rss & ((1<<width)-1)) << offset);"
+"Rxx=insert(Rss,Rtt)","width=zxt6->32((Rtt.w[1]));offset=sxt7->32((Rtt.w[0]));mask = ((1<<width)-1);if (offset < 0) {Rxx = 0;} else {Rxx &= ~(mask<<offset);Rxx |= ((Rss & mask) << offset);};"
+Rdd=deinterleave(Rss),"Rdd = deinterleave(ODD,EVEN);"
+Rdd=interleave(Rss),"Rdd = interleave(Rss.w[1],Rss.w[0]);"
+"Rdd=lfs(Rss,Rtt)","Rdd = (Rss.u64 >> 1) | ((1&count_ones(Rss &Rtt)).u64<<63) ;"
+"Rd=parity(Rs,Rt)",Rd = 1&count_ones(Rs & Rt);
+"Rd=parity(Rss,Rtt)",Rd = 1&count_ones(Rss & Rtt);
+Rd=brev(Rs),Rd = reverse_bits(Rs);
+Rdd=brev(Rss),Rdd = reverse_bits(Rss);
+"Rd=clrbit(Rs,#u5)",Rd = (Rs & (~(1<<#u)));
+"Rd=clrbit(Rs,Rt)","Rd = (Rs & (~((sxt7->32(Rt)>0)?(zxt32->64(1)<<sxt7->32(Rt)):(zxt32->64(1)>>>sxt7->32(Rt)))));"
+"Rd=setbit(Rs,#u5)",Rd = (Rs | (1<<#u));
+"Rd=setbit(Rs,Rt)","Rd = (Rs | ((sxt7->32(Rt)>0)?(zxt32->64(1)<<sxt7->32(Rt)):(zxt32->64(1)>>>sxt7->32(Rt))));"
+"Rd=togglebit(Rs,#u5)",Rd = (Rs ^ (1<<#u));
+"Rd=togglebit(Rs,Rt)","Rd = (Rs ^ (sxt7->32(Rt)>0)?(zxt32->64(1)<<sxt7->32(Rt)):(zxt32->64(1)>>>sxt7->32(Rt)));"
+"Rdd=bitsplit(Rs,#u5)","Rdd.w[1]=(Rs>>#u);Rdd.w[0]=zxt#u->32(Rs);"
+"Rdd=bitsplit(Rs,Rt)","shamt = zxt5->32(Rt);Rdd.w[1]=(Rs>>shamt);Rdd.w[0]=zxtshamt->32(Rs);"
+"Rx=tableidxb(Rs,#u4,#S6):raw","width=#u;offset=#S;field = Rs[(width+offset-1):offset];Rx[(width-1+0):0]=field;"
+"Rx=tableidxb(Rs,#u4,#U5)","Assembler mapped to:""Rx=tableidxb(Rs,#u4,#U5):raw"""
+"Rx=tableidxd(Rs,#u4,#S6):raw","width=#u;offset=#S+3;field = Rs[(width+offset-1):offset];Rx[(width-1+3):3]=field;"
+"Rx=tableidxd(Rs,#u4,#U5)","Assembler mapped to:""Rx=tableidxd(Rs,#u4,#U5-3):raw"""
+"Rx=tableidxh(Rs,#u4,#S6):raw","width=#u;offset=#S+1;field = Rs[(width+offset-1):offset];Rx[(width-1+1):1]=field;"
+"Rx=tableidxh(Rs,#u4,#U5)","Assembler mapped to:""Rx=tableidxh(Rs,#u4,#U5-1):raw"""
+"Rx=tableidxw(Rs,#u4,#S6):raw","width=#u;offset=#S+2;field = Rs[(width+offset-1):offset];Rx[(width-1+2):2]=field;"
+"Rx=tableidxw(Rs,#u4,#U5)","Assembler mapped to:""Rx=tableidxw(Rs,#u4,#U5-2):raw"""
+"Rdd=vxaddsubh(Rss,Rtt):rnd:>>1:sat","Rdd.h[0]=sat16((Rss.h[0]+Rtt.h[1]+1)>>1);Rdd.h[1]=sat16((Rss.h[1]-Rtt.h[0]+1)>>1);Rdd.h[2]=sat16((Rss.h[2]+Rtt.h[3]+1)>>1);Rdd.h[3]=sat16((Rss.h[3]-Rtt.h[2]+1)>>1);"
+"Rdd=vxaddsubh(Rss,Rtt):sat","Rdd.h[0]=sat16(Rss.h[0]+Rtt.h[1]);Rdd.h[1]=sat16(Rss.h[1]-Rtt.h[0]);Rdd.h[2]=sat16(Rss.h[2]+Rtt.h[3]);Rdd.h[3]=sat16(Rss.h[3]-Rtt.h[2]);"
+"Rdd=vxsubaddh(Rss,Rtt):rnd:>>1:sat","Rdd.h[0]=sat16((Rss.h[0]-Rtt.h[1]+1)>>1);Rdd.h[1]=sat16((Rss.h[1]+Rtt.h[0]+1)>>1);Rdd.h[2]=sat16((Rss.h[2]-Rtt.h[3]+1)>>1);Rdd.h[3]=sat16((Rss.h[3]+Rtt.h[2]+1)>>1);"
+"Rdd=vxsubaddh(Rss,Rtt):sat","Rdd.h[0]=sat16(Rss.h[0]-Rtt.h[1]);Rdd.h[1]=sat16(Rss.h[1]+Rtt.h[0]);Rdd.h[2]=sat16(Rss.h[2]-Rtt.h[3]);Rdd.h[3]=sat16(Rss.h[3]+Rtt.h[2]);"
+"Rdd=cmpy(Rs,Rt)[:<<N]:sat","Rdd.w[1]=sat32((Rs.h[1] * Rt.h[0])[<<N] +(Rs.h[0] * Rt.h[1])[<<N]);Rdd.w[0]=sat32((Rs.h[0] * Rt.h[0])[<<N] -(Rs.h[1] * Rt.h[1])[<<N]);"
+"Rdd=cmpy(Rs,Rt*)[:<<N]:sat","Rdd.w[1]=sat32((Rs.h[1] * Rt.h[0])[<<N] -(Rs.h[0] * Rt.h[1])[<<N]);Rdd.w[0]=sat32((Rs.h[0] * Rt.h[0])[<<N] +(Rs.h[1] * Rt.h[1])[<<N]);"
+"Rxx+=cmpy(Rs,Rt)[:<<N]:sat","Rxx.w[1]=sat32(Rxx.w[1] + (Rs.h[1] *Rt.h[0])[<<N] + (Rs.h[0] * Rt.h[1])[<<N]);Rxx.w[0]=sat32(Rxx.w[0] + (Rs.h[0] *Rt.h[0])[<<N] - (Rs.h[1] * Rt.h[1])[<<N]);"
+"Rxx+=cmpy(Rs,Rt*)[:<<N]:sat","Rxx.w[1]=sat32(Rxx.w[1] + (Rs.h[1] *Rt.h[0])[<<N] - (Rs.h[0] * Rt.h[1])[<<N]);Rxx.w[0]=sat32(Rxx.w[0] + (Rs.h[0] *Rt.h[0])[<<N] + (Rs.h[1] * Rt.h[1])[<<N]);"
+"Rxx-=cmpy(Rs,Rt)[:<<N]:sat","Rxx.w[1]=sat32(Rxx.w[1] - ((Rs.h[1] *Rt.h[0])[<<N] + (Rs.h[0] * Rt.h[1])[<<N]));Rxx.w[0]=sat32(Rxx.w[0] - ((Rs.h[0] *Rt.h[0])[<<N] - (Rs.h[1] * Rt.h[1])[<<N]));"
+"Rxx-=cmpy(Rs,Rt*)[:<<N]:sat","Rxx.w[1]=sat32(Rxx.w[1] - ((Rs.h[1] *Rt.h[0])[<<N] - (Rs.h[0] * Rt.h[1])[<<N]));Rxx.w[0]=sat32(Rxx.w[0] - ((Rs.h[0] *Rt.h[0])[<<N] + (Rs.h[1] * Rt.h[1])[<<N]));"
+"Rdd=cmpyi(Rs,Rt)","Rdd = (Rs.h[1] * Rt.h[0]) + (Rs.h[0] *Rt.h[1]);"
+"Rdd=cmpyr(Rs,Rt)","Rdd = (Rs.h[0] * Rt.h[0]) - (Rs.h[1] *Rt.h[1]);"
+"Rxx+=cmpyi(Rs,Rt)","Rxx = Rxx + (Rs.h[1] * Rt.h[0]) + (Rs.h[0]* Rt.h[1]);"
+"Rxx+=cmpyr(Rs,Rt)","Rxx = Rxx + (Rs.h[0] * Rt.h[0]) - (Rs.h[1]* Rt.h[1]);"
+"Rd=cmpy(Rs,Rt)[:<<N]:rnd:sat","Rd.h[1]=(sat32((Rs.h[1] * Rt.h[0])[<<N] +(Rs.h[0] * Rt.h[1])[<<N] + 0x8000)).h[1];Rd.h[0]=(sat32((Rs.h[0] * Rt.h[0])[<<N] -(Rs.h[1] * Rt.h[1])[<<N] + 0x8000)).h[1];"
+"Rd=cmpy(Rs,Rt*)[:<<N]:rnd:sat","Rd.h[1]=(sat32((Rs.h[1] * Rt.h[0])[<<N] -(Rs.h[0] * Rt.h[1])[<<N] + 0x8000)).h[1];Rd.h[0]=(sat32((Rs.h[0] * Rt.h[0])[<<N] +(Rs.h[1] * Rt.h[1])[<<N] + 0x8000)).h[1];"
+"Rd=cmpyiwh(Rss,Rt):<<1:rnd:sat","Rd = sat32(( (Rss.w[0] * Rt.h[1]) +(Rss.w[1] * Rt.h[0]) + 0x4000)>>15);"
+"Rd=cmpyiwh(Rss,Rt*):<<1:rnd:sat","Rd = sat32(( (Rss.w[1] * Rt.h[0]) -(Rss.w[0] * Rt.h[1]) + 0x4000)>>15);"
+"Rd=cmpyrwh(Rss,Rt):<<1:rnd:sat","Rd = sat32(( (Rss.w[0] * Rt.h[0]) -(Rss.w[1] * Rt.h[1]) + 0x4000)>>15);"
+"Rd=cmpyrwh(Rss,Rt*):<<1:rnd:sat","Rd = sat32(( (Rss.w[0] * Rt.h[0]) +(Rss.w[1] * Rt.h[1]) + 0x4000)>>15);"
+"Rdd=vcmpyi(Rss,Rtt)[:<<N]:sat","Rdd.w[0]=sat32((Rss.h[1] * Rtt.h[0]) +(Rss.h[0] * Rtt.h[1])[<<N]);Rdd.w[1]=sat32((Rss.h[3] * Rtt.h[2]) +(Rss.h[2] * Rtt.h[3])[<<N]);"
+"Rdd=vcmpyr(Rss,Rtt)[:<<N]:sat","Rdd.w[0]=sat32((Rss.h[0] * Rtt.h[0]) -(Rss.h[1] * Rtt.h[1])[<<N]);Rdd.w[1]=sat32((Rss.h[2] * Rtt.h[2]) -(Rss.h[3] * Rtt.h[3])[<<N]);"
+"Rxx+=vcmpyi(Rss,Rtt):sat","Rxx.w[0]=sat32(Rxx.w[0] + (Rss.h[1] *Rtt.h[0]) + (Rss.h[0] * Rtt.h[1])<<0);Rxx.w[1]=sat32(Rxx.w[1] + (Rss.h[3] *Rtt.h[2]) + (Rss.h[2] * Rtt.h[3])<<0);"
+Rdd=vconj(Rss):sat,"Rdd.h[1]=sat16(-Rss.h[1]);Rdd.h[0]=Rss.h[0];Rdd.h[3]=sat16(-Rss.h[3]);Rdd.h[2]=Rss.h[2];"
+"Rdd=vcrotate(Rss,Rt)","tmp = Rt[1:0];if (tmp == 0) {Rdd.h[0]=Rss.h[0];Rdd.h[1]=Rss.h[1];} else if (tmp == 1) {Rdd.h[0]=Rss.h[1];Rdd.h[1]=sat16(-Rss.h[0]);} else if (tmp == 2) {Rdd.h[0]=sat16(-Rss.h[1]);Rdd.h[1]=Rss.h[0];} else {Rdd.h[0]=sat16(-Rss.h[0]);Rdd.h[1]=sat16(-Rss.h[1]);};tmp = Rt[3:2];if (tmp == 0) {Rdd.h[2]=Rss.h[2];Rdd.h[3]=Rss.h[3];} else if (tmp == 1) {Rdd.h[2]=Rss.h[3];Rdd.h[3]=sat16(-Rss.h[2]);} else if (tmp == 2) {Rdd.h[2]=sat16(-Rss.h[3]);Rdd.h[3]=Rss.h[2];} else {Rdd.h[2]=sat16(-Rss.h[2]);Rdd.h[3]=sat16(-Rss.h[3]);};"
+"Rdd=vrcmpyr(Rss,Rtt*)","Rdd = (Rss.h[0] * Rtt.h[0]) + (Rss.h[1] *Rtt.h[1]) + (Rss.h[2] * Rtt.h[2]) +(Rss.h[3] * Rtt.h[3]);"
+"Rxx+=vrcmpyi(Rss,Rtt)","Rxx = Rxx + (Rss.h[1] * Rtt.h[0]) +(Rss.h[0] * Rtt.h[1]) + (Rss.h[3] *Rtt.h[2]) + (Rss.h[2] * Rtt.h[3]);"
+"Rxx+=vrcmpyi(Rss,Rtt*)","Rxx = Rxx + (Rss.h[1] * Rtt.h[0]) -(Rss.h[0] * Rtt.h[1]) + (Rss.h[3] *Rtt.h[2]) - (Rss.h[2] * Rtt.h[3]);"
+"Rxx+=vrcmpyr(Rss,Rtt)","Rxx = Rxx + (Rss.h[0] * Rtt.h[0]) -(Rss.h[1] * Rtt.h[1]) + (Rss.h[2] *Rtt.h[2]) - (Rss.h[3] * Rtt.h[3]);"
+"Rxx+=vrcmpyr(Rss,Rtt*)","Rxx = Rxx + (Rss.h[0] * Rtt.h[0]) +(Rss.h[1] * Rtt.h[1]) + (Rss.h[2] *Rtt.h[2]) + (Rss.h[3] * Rtt.h[3]);"
+"Rdd=vrcmpys(Rss,Rt):<<1:sat","if (""Rt & 1"") {Assembler mapped to:""Rdd=vrcmpys(Rss,Rtt):<<1:sat:raw:hi"";} else {Assembler mapped to:""Rdd=vrcmpys(Rss,Rtt):<<1:sat:raw:lo"";};"
+"Rdd=vrcmpys(Rss,Rtt):<<1:sat:raw:hi","Rdd.w[1]=sat32((Rss.h[1] *Rtt.w[1].h[0])<<1 + (Rss.h[3] *Rtt.w[1].h[1])<<1);Rdd.w[0]=sat32((Rss.h[0] *Rtt.w[1].h[0])<<1 + (Rss.h[2] *Rtt.w[1].h[1])<<1);"
+"Rdd=vrcmpys(Rss,Rtt):<<1:sat:raw:lo","Rdd.w[1]=sat32((Rss.h[1] *Rtt.w[0].h[0])<<1 + (Rss.h[3] *Rtt.w[0].h[1])<<1);Rdd.w[0]=sat32((Rss.h[0] *Rtt.w[0].h[0])<<1 + (Rss.h[2] *Rtt.w[0].h[1])<<1);"
+"Rxx+=vrcmpys(Rss,Rt):<<1:sat","if (""Rt & 1"") {Assembler mapped to:""Rxx+=vrcmpys(Rss,Rtt):<<1:sat:raw:hi"";} else {Assembler mapped to:""Rxx+=vrcmpys(Rss,Rtt):<<1:sat:raw:lo"";};"
+"Rxx+=vrcmpys(Rss,Rtt):<<1:sat:raw:hi","Rxx.w[1]=sat32(Rxx.w[1] + (Rss.h[1] *Rtt.w[1].h[0])<<1 + (Rss.h[3] *Rtt.w[1].h[1])<<1);Rxx.w[0]=sat32(Rxx.w[0] + (Rss.h[0] *Rtt.w[1].h[0])<<1 + (Rss.h[2] *Rtt.w[1].h[1])<<1);"
+"Rxx+=vrcmpys(Rss,Rtt):<<1:sat:raw:lo","Rxx.w[1]=sat32(Rxx.w[1] + (Rss.h[1] *Rtt.w[0].h[0])<<1 + (Rss.h[3] *Rtt.w[0].h[1])<<1);Rxx.w[0]=sat32(Rxx.w[0] + (Rss.h[0] *Rtt.w[0].h[0])<<1 + (Rss.h[2] *Rtt.w[0].h[1])<<1);"
+"Rd=vrcmpys(Rss,Rt):<<1:rnd:sat","if (""Rt & 1"") {Assembler mapped to:""Rd=vrcmpys(Rss,Rtt):<<1:rnd:sat:raw:hi"";} else {Assembler mapped to:""Rd=vrcmpys(Rss,Rtt):<<1:rnd:sat:raw:lo"";};"
+"Rd=vrcmpys(Rss,Rtt):<<1:rnd:sat:raw:hi","Rd.h[1]=sat32((Rss.h[1] * Rtt.w[1].h[0])<<1+ (Rss.h[3] * Rtt.w[1].h[1])<<1 +0x8000).h[1];Rd.h[0]=sat32((Rss.h[0] * Rtt.w[1].h[0])<<1+ (Rss.h[2] * Rtt.w[1].h[1])<<1 +0x8000).h[1];"
+"Rd=vrcmpys(Rss,Rtt):<<1:rnd:sat:raw:lo","Rd.h[1]=sat32((Rss.h[1] * Rtt.w[0].h[0])<<1+ (Rss.h[3] * Rtt.w[0].h[1])<<1 +0x8000).h[1];Rd.h[0]=sat32((Rss.h[0] * Rtt.w[0].h[0])<<1+ (Rss.h[2] * Rtt.w[0].h[1])<<1 +0x8000).h[1];"
+"Rdd=vrcrotate(Rss,Rt,#u2)","sumr = 0;sumi = 0;control = Rt.ub[#u];for (i = 0; i < 8; i += 2) {tmpr = Rss.b[i];tmpi = Rss.b[i+1];switch (control & 3) {case 0: sumr += tmpr;sumi += tmpi;break;case 1: sumr += tmpi;sumi -= tmpr;break;case 2: sumr -= tmpi;sumi += tmpr;break;case 3: sumr -= tmpr;sumi -= tmpi;break;};control = control >> 2;};Rdd.w[0]=sumr;Rdd.w[1]=sumi;"
+"Rxx+=vrcrotate(Rss,Rt,#u2)","sumr = 0;sumi = 0;control = Rt.ub[#u];for (i = 0; i < 8; i += 2) {tmpr = Rss.b[i];tmpi = Rss.b[i+1];switch (control & 3) {case 0: sumr += tmpr;sumi += tmpi;break;case 1: sumr += tmpi;sumi -= tmpr;break;case 2: sumr -= tmpi;sumi += tmpr;break;case 3: sumr -= tmpr;sumi -= tmpi;break;};control = control >> 2;};Rxx.w[0]=Rxx.w[0] + sumr;Rxx.w[1]=Rxx.w[1] + sumi;"
+"Rd=sfadd(Rs,Rt)",Rd=Rs+Rt;
+"Pd=dfclass(Rss,#u5)","Pd = 0;class = fpclassify(Rss);if (#u.0 && (class == FP_ZERO)) Pd = 0xff;if (#u.1 && (class == FP_NORMAL)) Pd =0xff;if (#u.2 && (class == FP_SUBNORMAL)) Pd =0xff;if (#u.3 && (class == FP_INFINITE)) Pd =0xff;if (#u.4 && (class == FP_NAN)) Pd = 0xff;cancel_flags();"
+"Pd=sfclass(Rs,#u5)","Pd = 0;class = fpclassify(Rs);if (#u.0 && (class == FP_ZERO)) Pd = 0xff;if (#u.1 && (class == FP_NORMAL)) Pd =0xff;if (#u.2 && (class == FP_SUBNORMAL)) Pd =0xff;if (#u.3 && (class == FP_INFINITE)) Pd =0xff;if (#u.4 && (class == FP_NAN)) Pd = 0xff;cancel_flags();"
+"Pd=dfcmp.eq(Rss,Rtt)",Pd=Rss==Rtt ? 0xff : 0x00;
+"Pd=dfcmp.ge(Rss,Rtt)",Pd=Rss>=Rtt ? 0xff : 0x00;
+"Pd=dfcmp.gt(Rss,Rtt)",Pd=Rss>Rtt ? 0xff : 0x00;
+"Pd=dfcmp.uo(Rss,Rtt)","Pd=isunordered(Rss,Rtt) ? 0xff : 0x00;"
+"Pd=sfcmp.eq(Rs,Rt)",Pd=Rs==Rt ? 0xff : 0x00;
+"Pd=sfcmp.ge(Rs,Rt)",Pd=Rs>=Rt ? 0xff : 0x00;
+"Pd=sfcmp.gt(Rs,Rt)",Pd=Rs>Rt ? 0xff : 0x00;
+"Pd=sfcmp.uo(Rs,Rt)","Pd=isunordered(Rs,Rt) ? 0xff : 0x00;"
+Rd=convert_df2sf(Rss),Rd = conv_df_to_sf(Rss);
+Rdd=convert_sf2df(Rs),Rdd = conv_sf_to_df(Rs);
+Rd=convert_d2sf(Rss),Rd = conv_8s_to_sf(Rss.s64);
+Rd=convert_ud2sf(Rss),Rd = conv_8u_to_sf(Rss.u64);
+Rd=convert_uw2sf(Rs),Rd = conv_4u_to_sf(Rs.uw[0]);
+Rd=convert_w2sf(Rs),Rd = conv_4s_to_sf(Rs.s32);
+Rdd=convert_d2df(Rss),Rdd = conv_8s_to_df(Rss.s64);
+Rdd=convert_ud2df(Rss),Rdd = conv_8u_to_df(Rss.u64);
+Rdd=convert_uw2df(Rs),Rdd = conv_4u_to_df(Rs.uw[0]);
+Rdd=convert_w2df(Rs),Rdd = conv_4s_to_df(Rs.s32);
+Rd=convert_df2uw(Rss),Rd = conv_df_to_4u(Rss).uw[0];
+Rd=convert_df2uw(Rss):chop,"round_to_zero();Rd = conv_df_to_4u(Rss).uw[0];"
+Rd=convert_df2w(Rss),Rd = conv_df_to_4s(Rss).s32;
+Rd=convert_df2w(Rss):chop,"round_to_zero();Rd = conv_df_to_4s(Rss).s32;"
+Rd=convert_sf2uw(Rs),Rd = conv_sf_to_4u(Rs).uw[0];
+Rd=convert_sf2uw(Rs):chop,"round_to_zero();Rd = conv_sf_to_4u(Rs).uw[0];"
+Rd=convert_sf2w(Rs),Rd = conv_sf_to_4s(Rs).s32;
+Rd=convert_sf2w(Rs):chop,"round_to_zero();Rd = conv_sf_to_4s(Rs).s32;"
+Rdd=convert_df2d(Rss),Rdd = conv_df_to_8s(Rss).s64;
+Rdd=convert_df2d(Rss):chop,"round_to_zero();Rdd = conv_df_to_8s(Rss).s64;"
+Rdd=convert_df2ud(Rss),Rdd = conv_df_to_8u(Rss).u64;
+Rdd=convert_df2ud(Rss):chop,"round_to_zero();Rdd = conv_df_to_8u(Rss).u64;"
+Rdd=convert_sf2d(Rs),Rdd = conv_sf_to_8s(Rs).s64;
+Rdd=convert_sf2d(Rs):chop,"round_to_zero();Rdd = conv_sf_to_8s(Rs).s64;"
+Rdd=convert_sf2ud(Rs),Rdd = conv_sf_to_8u(Rs).u64;
+Rdd=convert_sf2ud(Rs):chop,"round_to_zero();Rdd = conv_sf_to_8u(Rs).u64;"
+"Rd=sffixupd(Rs,Rt)","(Rs,Rt,Rd,adjust)=recip_common(Rs,Rt);Rd = Rt;"
+"Rd=sffixupn(Rs,Rt)","(Rs,Rt,Rd,adjust)=recip_common(Rs,Rt);Rd = Rs;"
+Rd=sffixupr(Rs),"(Rs,Rd,adjust)=invsqrt_common(Rs);Rd = Rs;"
+"Rx+=sfmpy(Rs,Rt)","Rx=fmaf(Rs,Rt,Rx);"
+"Rx-=sfmpy(Rs,Rt)","Rx=fmaf(-Rs,Rt,Rx);"
+"Rx+=sfmpy(Rs,Rt,Pu):scale","if (isnan(Rx) || isnan(Rs) || isnan(Rt)) Rx= NaN;;tmp=fmaf(Rs,Rt,Rx) * 2**(Pu);if ((tmp != Rx) || ((Rs != 0.0) && (Rt !=0.0))) Rx = tmp;"
+"Rd,Pe=sfinvsqrta(Rs)","if ((Rs,Rd,adjust)=invsqrt_common(Rs)) {Pe = adjust;idx = (Rs >> 17) & 0x7f;mant = (invsqrt_lut[idx] << 15);exp = 127 - ((exponent(Rs) - 127) >> 1)- 1;Rd = -1**Rs.31 * 1.MANT * 2**(exp-BIAS);};"
+"Rx+=sfmpy(Rs,Rt):lib","round_to_nearest();infminusinf = ((isinf(Rx)) &&(isinf(Rs*Rt)) && (Rs ^ Rx ^ Rt.31 != 0));infinp = (isinf(Rx)) || (isinf(Rt)) ||(isinf(Rs));if (isnan(Rx) || isnan(Rs) || isnan(Rt)) Rx= NaN;;if ((Rs != 0.0) && (Rt != 0.0)) {Rx=fmaf(Rs,Rt,Rx);} else {if (isinf(Rs) || isinf(Rt)) Rx = NaN;};cancel_flags();if (isinf(Rx) && !infinp) Rx = Rx - 1;if (infminusinf) Rx = 0;"
+"Rx-=sfmpy(Rs,Rt):lib","round_to_nearest();infinp = (isinf(Rx)) || (isinf(Rt)) ||(isinf(Rs));infminusinf = ((isinf(Rx)) &&(isinf(Rs*Rt)) && (Rs ^ Rx ^ Rt.31 == 0));if (isnan(Rx) || isnan(Rs) || isnan(Rt)) Rx= NaN;;if ((Rs != 0.0) && (Rt != 0.0)) {Rx=fmaf(-Rs,Rt,Rx);} else {if (isinf(Rs) || isinf(Rt)) Rx = NaN;};cancel_flags();if (isinf(Rx) && !infinp) Rx = Rx - 1;if (infminusinf) Rx = 0;"
+Rd=sfmake(#u10):neg,"Rd = (127 - 6) << 23;Rd += (#u << 17);Rd |= (1 << 31);"
+Rd=sfmake(#u10):pos,"Rd = (127 - 6) << 23;Rd += #u << 17;"
+Rdd=dfmake(#u10):neg,"Rdd = (1023ULL - 6) << 52;Rdd += (#u) << 46;Rdd |= ((1ULL) << 63);"
+Rdd=dfmake(#u10):pos,"Rdd = (1023ULL - 6) << 52;Rdd += (#u) << 46;"
+"Rd=sfmax(Rs,Rt)","Rd = fmaxf(Rs,Rt);"
+"Rd=sfmin(Rs,Rt)","Rd = fmin(Rs,Rt);"
+"Rd=sfmpy(Rs,Rt)",Rd=Rs*Rt;
+"Rd,Pe=sfrecipa(Rs,Rt)","if ((Rs,Rt,Rd,adjust)=recip_common(Rs,Rt)){Pe = adjust;idx = (Rt >> 16) & 0x7f;mant = (recip_lut[idx] << 15) | 1;exp = 127 - (exponent(Rt) - 127) - 1;Rd = -1**Rt.31 * 1.MANT * 2**(exp-BIAS);};"
+"Rd=sfsub(Rs,Rt)",Rd=Rs-Rt;
+"Rd=+mpyi(Rs,#u8)","apply_extension(#u);Rd=Rs*#u;"
+"Rd=-mpyi(Rs,#u8)",Rd=Rs*-#u;
+"Rd=add(#u6,mpyi(Rs,#U6))","apply_extension(#u);Rd = #u + Rs*#U;"
+"Rd=add(#u6,mpyi(Rs,Rt))","apply_extension(#u);Rd = #u + Rs*Rt;"
+"Rd=add(Ru,mpyi(#u6:2,Rs))",Rd = Ru + Rs*#u;
+"Rd=add(Ru,mpyi(Rs,#u6))","apply_extension(#u);Rd = Ru + Rs*#u;"
+"Rd=mpyi(Rs,#m9)","if (""((#m9<0) && (#m9>-256))"") {Assembler mapped to: ""Rd=-mpyi(Rs,#m9*(-1))"";} else {Assembler mapped to:""Rd=+mpyi(Rs,#m9)"";};"
+"Rd=mpyi(Rs,Rt)",Rd=Rs*Rt;
+"Rd=mpyui(Rs,Rt)","Assembler mapped to: ""Rd=mpyi(Rs,Rt)"""
+"Rx+=mpyi(Rs,#u8)","apply_extension(#u);Rx=Rx + (Rs*#u);"
+"Rx+=mpyi(Rs,Rt)",Rx=Rx + Rs*Rt;
+"Rx-=mpyi(Rs,#u8)","apply_extension(#u);Rx=Rx - (Rs*#u);"
+"Ry=add(Ru,mpyi(Ry,Rs))",Ry = Ru + Rs*Ry;
+"Rdd=vmpyweh(Rss,Rtt)[:<<1]:rnd:sat","Rdd.w[1]=sat32(((Rss.w[1] *Rtt.h[2])[<<N]+0x8000)>>16);Rdd.w[0]=sat32(((Rss.w[0] *Rtt.h[0])[<<N]+0x8000)>>16);"
+"Rdd=vmpyweh(Rss,Rtt)[:<<1]:sat","Rdd.w[1]=sat32(((Rss.w[1] *Rtt.h[2])[<<N])>>16);Rdd.w[0]=sat32(((Rss.w[0] *Rtt.h[0])[<<N])>>16);"
+"Rdd=vmpywoh(Rss,Rtt)[:<<1]:rnd:sat","Rdd.w[1]=sat32(((Rss.w[1] *Rtt.h[3])[<<N]+0x8000)>>16);Rdd.w[0]=sat32(((Rss.w[0] *Rtt.h[1])[<<N]+0x8000)>>16);"
+"Rdd=vmpywoh(Rss,Rtt)[:<<1]:sat","Rdd.w[1]=sat32(((Rss.w[1] *Rtt.h[3])[<<N])>>16);Rdd.w[0]=sat32(((Rss.w[0] *Rtt.h[1])[<<N])>>16);"
+"Rxx+=vmpyweh(Rss,Rtt)[:<<1]:rnd:sat","Rxx.w[1]=sat32(Rxx.w[1] + (((Rss.w[1] *Rtt.h[2])[<<N]+0x8000)>>16));Rxx.w[0]=sat32(Rxx.w[0] + (((Rss.w[0] *Rtt.h[0])[<<N]+0x8000)>>16));"
+"Rxx+=vmpyweh(Rss,Rtt)[:<<1]:sat","Rxx.w[1]=sat32(Rxx.w[1] + (((Rss.w[1] *Rtt.h[2])[<<N])>>16));Rxx.w[0]=sat32(Rxx.w[0] + (((Rss.w[0] *Rtt.h[0])[<<N])>>16));"
+"Rxx+=vmpywoh(Rss,Rtt)[:<<1]:rnd:sat","Rxx.w[1]=sat32(Rxx.w[1] + (((Rss.w[1] *Rtt.h[3])[<<N]+0x8000)>>16));Rxx.w[0]=sat32(Rxx.w[0] + (((Rss.w[0] *Rtt.h[1])[<<N]+0x8000)>>16 ));"
+"Rxx+=vmpywoh(Rss,Rtt)[:<<1]:sat","Rxx.w[1]=sat32(Rxx.w[1] + (((Rss.w[1] *Rtt.h[3])[<<N])>>16));Rxx.w[0]=sat32(Rxx.w[0] + (((Rss.w[0] *Rtt.h[1])[<<N])>>16 ));"
+"Rdd=vmpyweuh(Rss,Rtt)[:<<1]:rnd:sat","Rdd.w[1]=sat32(((Rss.w[1] *Rtt.uh[2])[<<N]+0x8000)>>16);Rdd.w[0]=sat32(((Rss.w[0] *Rtt.uh[0])[<<N]+0x8000)>>16);"
+"Rdd=vmpyweuh(Rss,Rtt)[:<<1]:sat","Rdd.w[1]=sat32(((Rss.w[1] *Rtt.uh[2])[<<N])>>16);Rdd.w[0]=sat32(((Rss.w[0] *Rtt.uh[0])[<<N])>>16);"
+"Rdd=vmpywouh(Rss,Rtt)[:<<1]:rnd:sat","Rdd.w[1]=sat32(((Rss.w[1] *Rtt.uh[3])[<<N]+0x8000)>>16);Rdd.w[0]=sat32(((Rss.w[0] *Rtt.uh[1])[<<N]+0x8000)>>16);"
+"Rdd=vmpywouh(Rss,Rtt)[:<<1]:sat","Rdd.w[1]=sat32(((Rss.w[1] *Rtt.uh[3])[<<N])>>16);Rdd.w[0]=sat32(((Rss.w[0] *Rtt.uh[1])[<<N])>>16);"
+"Rxx+=vmpyweuh(Rss,Rtt)[:<<1]:rnd:sat","Rxx.w[1]=sat32(Rxx.w[1] + (((Rss.w[1] *Rtt.uh[2])[<<N]+0x8000)>>16));Rxx.w[0]=sat32(Rxx.w[0] + (((Rss.w[0] *Rtt.uh[0])[<<N]+0x8000)>>16));"
+"Rxx+=vmpyweuh(Rss,Rtt)[:<<1]:sat","Rxx.w[1]=sat32(Rxx.w[1] + (((Rss.w[1] *Rtt.uh[2])[<<N])>>16));Rxx.w[0]=sat32(Rxx.w[0] + (((Rss.w[0] *Rtt.uh[0])[<<N])>>16));"
+"Rxx+=vmpywouh(Rss,Rtt)[:<<1]:rnd:sat","Rxx.w[1]=sat32(Rxx.w[1] + (((Rss.w[1] *Rtt.uh[3])[<<N]+0x8000)>>16));Rxx.w[0]=sat32(Rxx.w[0] + (((Rss.w[0] *Rtt.uh[1])[<<N]+0x8000)>>16 ));"
+"Rxx+=vmpywouh(Rss,Rtt)[:<<1]:sat","Rxx.w[1]=sat32(Rxx.w[1] + (((Rss.w[1] *Rtt.uh[3])[<<N])>>16));Rxx.w[0]=sat32(Rxx.w[0] + (((Rss.w[0] *Rtt.uh[1])[<<N])>>16 ));"
+"Rd=mpy(Rs.[HL],Rt.[HL])[:<<N][:rnd][:sat]","Rd=[sat32]([round]((Rs.h[01] *Rt.h[01])[<<N]));"
+"Rdd=mpy(Rs.[HL],Rt.[HL])[:<<N][:rnd]",Rdd=[round]((Rs.h[01] * Rt.h[01])[<<N]);
+"Rx+=mpy(Rs.[HL],Rt.[HL])[:<<N][:sat]",Rx=[sat32](Rx+ (Rs.h[01] * Rt.h[01])[<<N]);
+"Rx-=mpy(Rs.[HL],Rt.[HL])[:<<N][:sat]",Rx=[sat32](Rx- (Rs.h[01] * Rt.h[01])[<<N]);
+"Rxx+=mpy(Rs.[HL],Rt.[HL])[:<<N]",Rxx=Rxx+ (Rs.h[01] * Rt.h[01])[<<N];
+"Rxx-=mpy(Rs.[HL],Rt.[HL])[:<<N]",Rxx=Rxx- (Rs.h[01] * Rt.h[01])[<<N];
+"Rd=mpyu(Rs.[HL],Rt.[HL])[:<<N]",Rd=(Rs.uh[01] * Rt.uh[01])[<<N];
+"Rdd=mpyu(Rs.[HL],Rt.[HL])[:<<N]",Rdd=(Rs.uh[01] * Rt.uh[01])[<<N];
+"Rx+=mpyu(Rs.[HL],Rt.[HL])[:<<N]",Rx=Rx+ (Rs.uh[01] * Rt.uh[01])[<<N];
+"Rx-=mpyu(Rs.[HL],Rt.[HL])[:<<N]",Rx=Rx- (Rs.uh[01] * Rt.uh[01])[<<N];
+"Rxx+=mpyu(Rs.[HL],Rt.[HL])[:<<N]",Rxx=Rxx+ (Rs.uh[01] * Rt.uh[01])[<<N];
+"Rxx-=mpyu(Rs.[HL],Rt.[HL])[:<<N]",Rxx=Rxx- (Rs.uh[01] * Rt.uh[01])[<<N];
+"Rdd=pmpyw(Rs,Rt)","x = Rs.uw[0];y = Rt.uw[0];prod = 0;for(i=0; i < 32; i++) {if((y >> i) & 1) prod ^= (x << i);};Rdd = prod;"
+"Rxx^=pmpyw(Rs,Rt)","x = Rs.uw[0];y = Rt.uw[0];prod = 0;for(i=0; i < 32; i++) {if((y >> i) & 1) prod ^= (x << i);};Rxx ^= prod;"
+"Rd=mpy(Rs,Rt.H):<<1:rnd:sat",Rd = sat32(((Rs * Rt.h[1])<<1+0x8000)>>16);
+"Rd=mpy(Rs,Rt.H):<<1:sat",Rd = sat32(((Rs * Rt.h[1])<<1)>>16);
+"Rd=mpy(Rs,Rt.L):<<1:rnd:sat",Rd = sat32(((Rs * Rt.h[0])<<1+0x8000)>>16);
+"Rd=mpy(Rs,Rt.L):<<1:sat",Rd = sat32(((Rs * Rt.h[0])<<1)>>16);
+"Rd=mpy(Rs,Rt):<<1",Rd=(Rs * Rt)>>31;
+"Rd=mpy(Rs,Rt)",Rd=(Rs * Rt)>>32;
+"Rd=mpy(Rs,Rt):<<1:sat",Rd=sat32((Rs * Rt)>>31);
+"Rd=mpy(Rs,Rt):rnd",Rd=((Rs * Rt)+0x80000000)>>32;
+"Rd=mpysu(Rs,Rt)",Rd=(Rs * Rt.uw[0])>>32;
+"Rd=mpyu(Rs,Rt)",Rd=(Rs.uw[0] * Rt.uw[0])>>32;
+"Rx+=mpy(Rs,Rt):<<1:sat",Rx=sat32((Rx) + ((Rs * Rt)>>31));
+"Rx-=mpy(Rs,Rt):<<1:sat",Rx=sat32((Rx) - ((Rs * Rt)>>31));
+"Rdd=mpy(Rs,Rt)",Rdd=(Rs * Rt);
+"Rdd=mpyu(Rs,Rt)",Rdd=(Rs.uw[0] * Rt.uw[0]);
+"Rxx[+-]=mpy(Rs,Rt)",Rxx= Rxx[+-](Rs * Rt);
+"Rxx[+-]=mpyu(Rs,Rt)",Rxx= Rxx[+-](Rs.uw[0] * Rt.uw[0]);
+"Rdd=vdmpy(Rss,Rtt):<<1:sat","Rdd.w[0]=sat32((Rss.h[0] * Rtt.h[0])<<1 +(Rss.h[1] * Rtt.h[1])<<1);Rdd.w[1]=sat32((Rss.h[2] * Rtt.h[2])<<1 +(Rss.h[3] * Rtt.h[3])<<1);"
+"Rdd=vdmpy(Rss,Rtt):sat","Rdd.w[0]=sat32((Rss.h[0] * Rtt.h[0])<<0 +(Rss.h[1] * Rtt.h[1])<<0);Rdd.w[1]=sat32((Rss.h[2] * Rtt.h[2])<<0 +(Rss.h[3] * Rtt.h[3])<<0);"
+"Rxx+=vdmpy(Rss,Rtt):<<1:sat","Rxx.w[0]=sat32(Rxx.w[0] + (Rss.h[0] *Rtt.h[0])<<1 + (Rss.h[1] * Rtt.h[1])<<1);Rxx.w[1]=sat32(Rxx.w[1] + (Rss.h[2] *Rtt.h[2])<<1 + (Rss.h[3] * Rtt.h[3])<<1);"
+"Rxx+=vdmpy(Rss,Rtt):sat","Rxx.w[0]=sat32(Rxx.w[0] + (Rss.h[0] *Rtt.h[0])<<0 + (Rss.h[1] * Rtt.h[1])<<0);Rxx.w[1]=sat32(Rxx.w[1] + (Rss.h[2] *Rtt.h[2])<<0 + (Rss.h[3] * Rtt.h[3])<<0);"
+"Rdd=vrmpybsu(Rss,Rtt)","Rdd.w[0]=((Rss.b[0] * Rtt.ub[0]) +(Rss.b[1] * Rtt.ub[1]) + (Rss.b[2] *Rtt.ub[2]) + (Rss.b[3] * Rtt.ub[3]));Rdd.w[1]=((Rss.b[4] * Rtt.ub[4]) +(Rss.b[5] * Rtt.ub[5]) + (Rss.b[6] *Rtt.ub[6]) + (Rss.b[7] * Rtt.ub[7]));"
+"Rdd=vrmpybu(Rss,Rtt)","Rdd.w[0]=((Rss.ub[0] * Rtt.ub[0]) +(Rss.ub[1] * Rtt.ub[1]) + (Rss.ub[2] *Rtt.ub[2]) + (Rss.ub[3] * Rtt.ub[3]));Rdd.w[1]=((Rss.ub[4] * Rtt.ub[4]) +(Rss.ub[5] * Rtt.ub[5]) + (Rss.ub[6] *Rtt.ub[6]) + (Rss.ub[7] * Rtt.ub[7]));"
+"Rxx+=vrmpybsu(Rss,Rtt)","Rxx.w[0]=(Rxx.w[0] + (Rss.b[0] * Rtt.ub[0])+ (Rss.b[1] * Rtt.ub[1]) + (Rss.b[2] *Rtt.ub[2]) + (Rss.b[3] * Rtt.ub[3]));Rxx.w[1]=(Rxx.w[1] + (Rss.b[4] * Rtt.ub[4])+ (Rss.b[5] * Rtt.ub[5]) + (Rss.b[6] *Rtt.ub[6]) + (Rss.b[7] * Rtt.ub[7]));"
+"Rxx+=vrmpybu(Rss,Rtt)","Rxx.w[0]=(Rxx.w[0] + (Rss.ub[0] *Rtt.ub[0]) + (Rss.ub[1] * Rtt.ub[1]) +(Rss.ub[2] * Rtt.ub[2]) + (Rss.ub[3] *Rtt.ub[3]));Rxx.w[1]=(Rxx.w[1] + (Rss.ub[4] *Rtt.ub[4]) + (Rss.ub[5] * Rtt.ub[5]) +(Rss.ub[6] * Rtt.ub[6]) + (Rss.ub[7] *Rtt.ub[7]));"
+"Rdd=vmpyhsu(Rs,Rt)[:<<1]:sat","Rdd.w[0]=sat32((Rs.h[0] * Rt.uh[0])[<<N]);Rdd.w[1]=sat32((Rs.h[1] * Rt.uh[1])[<<N]);"
+"Rxx+=vmpyhsu(Rs,Rt)[:<<1]:sat","Rxx.w[0]=sat32(Rxx.w[0] + (Rs.h[0] *Rt.uh[0])[<<N]);Rxx.w[1]=sat32(Rxx.w[1] + (Rs.h[1] *Rt.uh[1])[<<N]);"
+"Rdd=vpmpyh(Rs,Rt)","x0 = Rs.uh[0];x1 = Rs.uh[1];y0 = Rt.uh[0];y1 = Rt.uh[1];prod0 = prod1 = 0;for(i=0; i < 16; i++) {if((y0 >> i) & 1) prod0 ^= (x0 << i);if((y1 >> i) & 1) prod1 ^= (x1 << i);};Rdd.h[0]=prod0.uh[0];Rdd.h[1]=prod1.uh[0];Rdd.h[2]=prod0.uh[1];Rdd.h[3]=prod1.uh[1];"
+"Rxx^=vpmpyh(Rs,Rt)","x0 = Rs.uh[0];x1 = Rs.uh[1];y0 = Rt.uh[0];y1 = Rt.uh[1];prod0 = prod1 = 0;for(i=0; i < 16; i++) {if((y0 >> i) & 1) prod0 ^= (x0 << i);if((y1 >> i) & 1) prod1 ^= (x1 << i);};Rxx.h[0]=Rxx.uh[0] ^ prod0.uh[0];Rxx.h[1]=Rxx.uh[1] ^ prod1.uh[0];Rxx.h[2]=Rxx.uh[2] ^ prod0.uh[1];Rxx.h[3]=Rxx.uh[3] ^ prod1.uh[1];"
+"Rdd=decbin(Rss,Rtt)","state = Rtt.w[1][5:0];valMPS = Rtt.w[1][8:8];bitpos = Rtt.w[0][4:0];range = Rss.w[0];offset = Rss.w[1];range <<= bitpos;offset <<= bitpos;rLPS = rLPS_table_64x4[state][ (range>>29)&3];rLPS = rLPS << 23;rMPS= (range&0xff800000) - rLPS;if (offset < rMPS) {Rdd = AC_next_state_MPS_64[state];Rdd[8:8]=valMPS;Rdd[31:23]=(rMPS>>23);Rdd.w[1]=offset;P0=valMPS;} else {Rdd = AC_next_state_LPS_64[state];Rdd[8:8]=((!state)?(1-valMPS):(valMPS));Rdd[31:23]=(rLPS>>23);Rdd.w[1]=(offset-rMPS);P0=(valMPS^1);};"
+Rd=sat(Rss),Rd = sat32(Rss);
+Rd=satb(Rs),Rd = sat8(Rs);
+Rd=sath(Rs),Rd = sat16(Rs);
+Rd=satub(Rs),Rd = usat8(Rs);
+Rd=satuh(Rs),Rd = usat16(Rs);
+Rd=swiz(Rs),"Rd.b[0]=Rs.b[3];Rd.b[1]=Rs.b[2];Rd.b[2]=Rs.b[1];Rd.b[3]=Rs.b[0];"
+"Rdd=valignb(Rtt,Rss,#u3)",Rdd = (Rss >>> #u*8)|(Rtt << ((8-#u)*8));
+"Rdd=valignb(Rtt,Rss,Pu)","Rdd = Rss >>> (Pu&0x7)*8|(Rtt << (8-(Pu&0x7))*8);"
+Rd=vrndwh(Rss),"for (i=0;i<2;i++) {Rd.h[i]=(Rss.w[i]+0x08000).h[1];};"
+Rd=vrndwh(Rss):sat,"for (i=0;i<2;i++) {Rd.h[i]=sat32(Rss.w[i]+0x08000).h[1];};"
+Rd=vsathb(Rs),"Rd.b[0]=sat8(Rs.h[0]);Rd.b[1]=sat8(Rs.h[1]);Rd.b[2]=0;Rd.b[3]=0;"
+Rd=vsathb(Rss),"for (i=0;i<4;i++) {Rd.b[i]=sat8(Rss.h[i]);};"
+Rd=vsathub(Rs),"Rd.b[0]=usat8(Rs.h[0]);Rd.b[1]=usat8(Rs.h[1]);Rd.b[2]=0;Rd.b[3]=0;"
+Rd=vsathub(Rss),"for (i=0;i<4;i++) {Rd.b[i]=usat8(Rss.h[i]);};"
+Rd=vsatwh(Rss),"for (i=0;i<2;i++) {Rd.h[i]=sat16(Rss.w[i]);};"
+Rd=vsatwuh(Rss),"for (i=0;i<2;i++) {Rd.h[i]=usat16(Rss.w[i]);};"
+Rdd=vsathb(Rss),"for (i=0;i<4;i++) {Rdd.h[i]=sat8(Rss.h[i]);};"
+Rdd=vsathub(Rss),"for (i=0;i<4;i++) {Rdd.h[i]=usat8(Rss.h[i]);};"
+Rdd=vsatwh(Rss),"for (i=0;i<2;i++) {Rdd.w[i]=sat16(Rss.w[i]);};"
+Rdd=vsatwuh(Rss),"for (i=0;i<2;i++) {Rdd.w[i]=usat16(Rss.w[i]);};"
+"Rdd=shuffeb(Rss,Rtt)","for (i=0;i<4;i++) {Rdd.b[i*2]=Rtt.b[i*2];Rdd.b[i*2+1]=Rss.b[i*2];};"
+"Rdd=shuffeh(Rss,Rtt)","for (i=0;i<2;i++) {Rdd.h[i*2]=Rtt.h[i*2];Rdd.h[i*2+1]=Rss.h[i*2];};"
+"Rdd=shuffob(Rtt,Rss)","for (i=0;i<4;i++) {Rdd.b[i*2]=Rss.b[i*2+1];Rdd.b[i*2+1]=Rtt.b[i*2+1];};"
+"Rdd=shuffoh(Rtt,Rss)","for (i=0;i<2;i++) {Rdd.h[i*2]=Rss.h[i*2+1];Rdd.h[i*2+1]=Rtt.h[i*2+1];};"
+Rd=vsplatb(Rs),"for (i=0;i<4;i++) {Rd.b[i]=Rs.b[0];};"
+Rdd=vsplatb(Rs),"for (i=0;i<8;i++) {Rdd.b[i]=Rs.b[0];};"
+Rdd=vsplath(Rs),"for (i=0;i<4;i++) {Rdd.h[i]=Rs.h[0];};"
+"Rdd=vspliceb(Rss,Rtt,#u3)",Rdd = Rtt << #u*8 | zxt#u*8->64(Rss);
+"Rdd=vspliceb(Rss,Rtt,Pu)",Rdd = Rtt << (Pu&7)*8 | zxt(Pu&7)*8->64(Rss);
+Rdd=vsxtbh(Rs),"for (i=0;i<4;i++) {Rdd.h[i]=Rs.b[i];};"
+Rdd=vsxthw(Rs),"for (i=0;i<2;i++) {Rdd.w[i]=Rs.h[i];};"
+Rd=vtrunehb(Rss),"for (i=0;i<4;i++) {Rd.b[i]=Rss.b[i*2];};"
+Rd=vtrunohb(Rss),"for (i=0;i<4;i++) {Rd.b[i]=Rss.b[i*2+1];};"
+"Rdd=vtrunehb(Rss,Rtt)","for (i=0;i<4;i++) {Rdd.b[i]=Rtt.b[i*2];Rdd.b[i+4]=Rss.b[i*2];};"
+"Rdd=vtrunewh(Rss,Rtt)","Rdd.h[0]=Rtt.h[0];Rdd.h[1]=Rtt.h[2];Rdd.h[2]=Rss.h[0];Rdd.h[3]=Rss.h[2];"
+"Rdd=vtrunohb(Rss,Rtt)","for (i=0;i<4;i++) {Rdd.b[i]=Rtt.b[i*2+1];Rdd.b[i+4]=Rss.b[i*2+1];};"
+"Rdd=vtrunowh(Rss,Rtt)","Rdd.h[0]=Rtt.h[1];Rdd.h[1]=Rtt.h[3];Rdd.h[2]=Rss.h[1];Rdd.h[3]=Rss.h[3];"
+Rdd=vzxtbh(Rs),"for (i=0;i<4;i++) {Rdd.h[i]=Rs.ub[i];};"
+Rdd=vzxthw(Rs),"for (i=0;i<2;i++) {Rdd.w[i]=Rs.uh[i];};"
+"Pd=boundscheck(Rs,Rtt)","if (""Rs & 1"") {Assembler mapped to:""Pd=boundscheck(Rss,Rtt):raw:hi"";} else {Assembler mapped to:""Pd=boundscheck(Rss,Rtt):raw:lo"";};"
+"Pd=boundscheck(Rss,Rtt):raw:hi","src = Rss.uw[1];Pd = (src.uw[0] >= Rtt.uw[0]) && (src.uw[0]< Rtt.uw[1]) ? 0xff : 0x00;"
+"Pd=boundscheck(Rss,Rtt):raw:lo","src = Rss.uw[0];Pd = (src.uw[0] >= Rtt.uw[0]) && (src.uw[0]< Rtt.uw[1]) ? 0xff : 0x00;"
+"Pd=cmpb.eq(Rs,#u8)",Pd=Rs.ub[0] == #u ? 0xff : 0x00;
+"Pd=cmpb.eq(Rs,Rt)",Pd=Rs.b[0] == Rt.b[0] ? 0xff : 0x00;
+"Pd=cmpb.gt(Rs,#s8)",Pd=Rs.b[0] > #s ? 0xff : 0x00;
+"Pd=cmpb.gt(Rs,Rt)",Pd=Rs.b[0] > Rt.b[0] ? 0xff : 0x00;
+"Pd=cmpb.gtu(Rs,#u7)","apply_extension(#u);Pd=Rs.ub[0] > #u.uw[0] ? 0xff : 0x00;"
+"Pd=cmpb.gtu(Rs,Rt)",Pd=Rs.ub[0] > Rt.ub[0] ? 0xff : 0x00;
+"Pd=cmph.eq(Rs,#s8)","apply_extension(#s);Pd=Rs.h[0] == #s ? 0xff : 0x00;"
+"Pd=cmph.eq(Rs,Rt)",Pd=Rs.h[0] == Rt.h[0] ? 0xff : 0x00;
+"Pd=cmph.gt(Rs,#s8)","apply_extension(#s);Pd=Rs.h[0] > #s ? 0xff : 0x00;"
+"Pd=cmph.gt(Rs,Rt)",Pd=Rs.h[0] > Rt.h[0] ? 0xff : 0x00;
+"Pd=cmph.gtu(Rs,#u7)","apply_extension(#u);Pd=Rs.uh[0] > #u.uw[0] ? 0xff : 0x00;"
+"Pd=cmph.gtu(Rs,Rt)",Pd=Rs.uh[0] > Rt.uh[0] ? 0xff : 0x00;
+"Pd=cmp.eq(Rss,Rtt)",Pd=Rss==Rtt ? 0xff : 0x00;
+"Pd=cmp.gt(Rss,Rtt)",Pd=Rss>Rtt ? 0xff : 0x00;
+"Pd=cmp.gtu(Rss,Rtt)",Pd=Rss.u64>Rtt.u64 ? 0xff : 0x00;
+"Pd=[!]bitsclr(Rs,#u6)",Pd=(Rs&#u)[!]=0 ? 0xff : 0x00;
+"Pd=[!]bitsclr(Rs,Rt)",Pd=(Rs&Rt)[!]=0 ? 0xff : 0x00;
+"Pd=[!]bitsset(Rs,Rt)",Pd=(Rs&Rt)[!]=Rt ? 0xff : 0x00;
+Rdd=mask(Pt),"for (i = 0; i < 8; i++) {Rdd.b[i]=(Pt.i?(0xff):(0x00));};"
+"Pd=tlbmatch(Rss,Rt)","MASK = 0x07ffffff;TLBLO = Rss.uw[0];TLBHI = Rss.uw[1];SIZE =min(6,count_leading_ones(~reverse_bits(TLBLO)));MASK &= (0xffffffff << 2*SIZE);Pd = TLBHI.31 && ((TLBHI & MASK) == (Rt &MASK)) ? 0xff : 0x00;"
+Pd=Rs,Pd = Rs.ub[0];
+Rd=Ps,Rd = zxt8->32(Ps);
+"Pd=tstbit(Rs,#u5)",Pd = (Rs & (1<<#u)) == 0 ? 0x00 : 0xff;
+"Pd=!tstbit(Rs,#u5)",Pd = (Rs & (1<<#u)) == 0 ? 0xff : 0x00;
+"Pd=tstbit(Rs,Rt)","Pd = (zxt32->64(Rs) & (sxt7->32(Rt)>0)?(zxt32->64(1)<<sxt7->32(Rt)):(zxt32->64(1)>>>sxt7->32(Rt))) == 0 ? 0x00 : 0xff;"
+"Pd=!tstbit(Rs,Rt)","Pd = (zxt32->64(Rs) & (sxt7->32(Rt)>0)?(zxt32->64(1)<<sxt7->32(Rt)):(zxt32->64(1)>>>sxt7->32(Rt))) == 0 ? 0xff : 0x00;"
+"Pd=vcmph.eq(Rss,#s8)","for (i = 0; i < 4; i++) {Pd.i*2 = (Rss.h[i] == #s);Pd.i*2+1 = (Rss.h[i] == #s);};"
+"Pd=vcmph.eq(Rss,Rtt)","for (i = 0; i < 4; i++) {Pd.i*2 = (Rss.h[i] == Rtt.h[i]);Pd.i*2+1 = (Rss.h[i] == Rtt.h[i]);};"
+"Pd=vcmph.gt(Rss,#s8)","for (i = 0; i < 4; i++) {Pd.i*2 = (Rss.h[i] > #s);Pd.i*2+1 = (Rss.h[i] > #s);};"
+"Pd=vcmph.gt(Rss,Rtt)","for (i = 0; i < 4; i++) {Pd.i*2 = (Rss.h[i] > Rtt.h[i]);Pd.i*2+1 = (Rss.h[i] > Rtt.h[i]);};"
+"Pd=vcmph.gtu(Rss,#u7)","for (i = 0; i < 4; i++) {Pd.i*2 = (Rss.uh[i] > #u);Pd.i*2+1 = (Rss.uh[i] > #u);};"
+"Pd=vcmph.gtu(Rss,Rtt)","for (i = 0; i < 4; i++) {Pd.i*2 = (Rss.uh[i] > Rtt.uh[i]);Pd.i*2+1 = (Rss.uh[i] > Rtt.uh[i]);};"
+"Pd=any8(vcmpb.eq(Rss,Rtt))","Pd = 0;for (i = 0; i < 8; i++) {if (Rss.b[i] == Rtt.b[i]) Pd = 0xff;};"
+"Pd=vcmpb.eq(Rss,#u8)","for (i = 0; i < 8; i++) {Pd.i = (Rss.ub[i] == #u);};"
+"Pd=vcmpb.eq(Rss,Rtt)","for (i = 0; i < 8; i++) {Pd.i = (Rss.b[i] == Rtt.b[i]);};"
+"Pd=vcmpb.gt(Rss,#s8)","for (i = 0; i < 8; i++) {Pd.i = (Rss.b[i] > #s);};"
+"Pd=vcmpb.gt(Rss,Rtt)","for (i = 0; i < 8; i++) {Pd.i = (Rss.b[i] > Rtt.b[i]);};"
+"Pd=vcmpb.gtu(Rss,#u7)","for (i = 0; i < 8; i++) {Pd.i = (Rss.ub[i] > #u);};"
+"Pd=vcmpb.gtu(Rss,Rtt)","for (i = 0; i < 8; i++) {Pd.i = (Rss.ub[i] > Rtt.ub[i]);};"
+"Pd=vcmpw.eq(Rss,#s8)","Pd[3:0] = (Rss.w[0]==#s);Pd[7:4] = (Rss.w[1]==#s);"
+"Pd=vcmpw.eq(Rss,Rtt)","Pd[3:0] = (Rss.w[0]==Rtt.w[0]);Pd[7:4] = (Rss.w[1]==Rtt.w[1]);"
+"Pd=vcmpw.gt(Rss,#s8)","Pd[3:0] = (Rss.w[0]>#s);Pd[7:4] = (Rss.w[1]>#s);"
+"Pd=vcmpw.gt(Rss,Rtt)","Pd[3:0] = (Rss.w[0]>Rtt.w[0]);Pd[7:4] = (Rss.w[1]>Rtt.w[1]);"
+"Pd=vcmpw.gtu(Rss,#u7)","Pd[3:0] = (Rss.uw[0]>#u);Pd[7:4] = (Rss.uw[1]>#u);"
+"Pd=vcmpw.gtu(Rss,Rtt)","Pd[3:0] = (Rss.uw[0]>Rtt.uw[0]);Pd[7:4] = (Rss.uw[1]>Rtt.uw[1]);"
+"Rd=vitpack(Ps,Pt)",Rd = (Ps&0x55) | (Pt&0xAA);
+"Rdd=vmux(Pu,Rss,Rtt)","for (i = 0; i < 8; i++) {Rdd.b[i]=(Pu.i?(Rss.b[i]):(Rtt.b[i]));};"
+"Rd=asl(Rs,#u5)",Rd = Rs << #u;
+"Rd=asr(Rs,#u5)",Rd = Rs >> #u;
+"Rd=lsr(Rs,#u5)",Rd = Rs >>> #u;
+"Rd=rol(Rs,#u5)",Rd = Rs <<R #u;
+"Rdd=asl(Rss,#u6)",Rdd = Rss << #u;
+"Rdd=asr(Rss,#u6)",Rdd = Rss >> #u;
+"Rdd=lsr(Rss,#u6)",Rdd = Rss >>> #u;
+"Rdd=rol(Rss,#u6)",Rdd = Rss <<R #u;
+"Rx=add(#u8,asl(Rx,#U5))",Rx=apply_extension(#u)+(Rx<<#U);
+"Rx=add(#u8,lsr(Rx,#U5))","Rx=apply_extension(#u)+(((unsignedint)Rx)>>#U);"
+"Rx=sub(#u8,asl(Rx,#U5))",Rx=apply_extension(#u)-(Rx<<#U);
+"Rx=sub(#u8,lsr(Rx,#U5))","Rx=apply_extension(#u)-(((unsignedint)Rx)>>#U);"
+"Rx[+-]=asl(Rs,#u5)",Rx = Rx [+-] (Rs << #u);
+"Rx[+-]=asr(Rs,#u5)",Rx = Rx [+-] (Rs >> #u);
+"Rx[+-]=lsr(Rs,#u5)",Rx = Rx [+-] (Rs >>> #u);
+"Rx[+-]=rol(Rs,#u5)",Rx = Rx [+-] (Rs <<R #u);
+"Rxx[+-]=asl(Rss,#u6)",Rxx = Rxx [+-] (Rss << #u);
+"Rxx[+-]=asr(Rss,#u6)",Rxx = Rxx [+-] (Rss >> #u);
+"Rxx[+-]=lsr(Rss,#u6)",Rxx = Rxx [+-] (Rss >>> #u);
+"Rxx[+-]=rol(Rss,#u6)",Rxx = Rxx [+-] (Rss <<R #u);
+"Rd=addasl(Rt,Rs,#u3)",Rd = Rt + (Rs << #u);
+"Rx=and(#u8,asl(Rx,#U5))",Rx=apply_extension(#u)&(Rx<<#U);
+"Rx=and(#u8,lsr(Rx,#U5))","Rx=apply_extension(#u)&(((unsignedint)Rx)>>#U);"
+"Rx=or(#u8,asl(Rx,#U5))",Rx=apply_extension(#u)|(Rx<<#U);
+"Rx=or(#u8,lsr(Rx,#U5))","Rx=apply_extension(#u)|(((unsignedint)Rx)>>#U);"
+"Rx[&|]=asl(Rs,#u5)",Rx = Rx [|&] Rs << #u;
+"Rx[&|]=asr(Rs,#u5)",Rx = Rx [|&] Rs >> #u;
+"Rx[&|]=lsr(Rs,#u5)",Rx = Rx [|&] Rs >>> #u;
+"Rx[&|]=rol(Rs,#u5)",Rx = Rx [|&] Rs <<R #u;
+"Rx^=asl(Rs,#u5)",Rx = Rx ^ Rs << #u;
+"Rx^=lsr(Rs,#u5)",Rx = Rx ^ Rs >>> #u;
+"Rx^=rol(Rs,#u5)",Rx = Rx ^ Rs <<R #u;
+"Rxx[&|]=asl(Rss,#u6)",Rxx = Rxx [|&] Rss << #u;
+"Rxx[&|]=asr(Rss,#u6)",Rxx = Rxx [|&] Rss >> #u;
+"Rxx[&|]=lsr(Rss,#u6)",Rxx = Rxx [|&] Rss >>> #u;
+"Rxx[&|]=rol(Rss,#u6)",Rxx = Rxx [|&] Rss <<R #u;
+"Rxx^=asl(Rss,#u6)",Rxx = Rxx ^ Rss << #u;
+"Rxx^=lsr(Rss,#u6)",Rxx = Rxx ^ Rss >>> #u;
+"Rxx^=rol(Rss,#u6)",Rxx = Rxx ^ Rss <<R #u;
+"Rd=asr(Rs,#u5):rnd",Rd = ((Rs >> #u)+1) >> 1;
+"Rd=asrrnd(Rs,#u5)","if (""#u5==0"") {Assembler mapped to: ""Rd=Rs"";} else {Assembler mapped to: ""Rd=asr(Rs,#u5-1):rnd"";};"
+"Rdd=asr(Rss,#u6):rnd","tmp = Rss >> #u;rnd = tmp & 1;Rdd = tmp >> 1 + rnd;"
+"Rdd=asrrnd(Rss,#u6)","if (""#u6==0"") {Assembler mapped to: ""Rdd=Rss"";} else {Assembler mapped to: ""Rdd=asr(Rss,#u6-1):rnd"";};"
+"Rd=asl(Rs,#u5):sat",Rd = sat32(sxt32->64(Rs) << #u);
+"Rd=asl(Rs,Rt)","shamt=sxt7->32(Rt);Rd = (shamt>0)?(sxt32->64(Rs)<<shamt):(sxt32->64(Rs)>>-shamt);"
+"Rd=asr(Rs,Rt)","shamt=sxt7->32(Rt);Rd = (shamt>0)?(sxt32->64(Rs)>>shamt):(sxt32->64(Rs)<<-shamt);"
+"Rd=lsl(#s6,Rt)","shamt = sxt7->32(Rt);Rd = (shamt>0)?(zxt32->64(#s)<<shamt):(zxt32->64(#s)>>>-shamt);"
+"Rd=lsl(Rs,Rt)","shamt=sxt7->32(Rt);Rd = (shamt>0)?(zxt32->64(Rs)<<shamt):(zxt32->64(Rs)>>>-shamt);"
+"Rd=lsr(Rs,Rt)","shamt=sxt7->32(Rt);Rd = (shamt>0)?(zxt32->64(Rs)>>>shamt):(zxt32->64(Rs)<<-shamt);"
+"Rdd=asl(Rss,Rt)","shamt=sxt7->32(Rt);Rdd = (shamt>0)?(Rss<<shamt):(Rss>>-shamt);"
+"Rdd=asr(Rss,Rt)","shamt=sxt7->32(Rt);Rdd = (shamt>0)?(Rss>>shamt):(Rss<<-shamt);"
+"Rdd=lsl(Rss,Rt)","shamt=sxt7->32(Rt);Rdd = (shamt>0)?(Rss<<shamt):(Rss>>>-shamt);"
+"Rdd=lsr(Rss,Rt)","shamt=sxt7->32(Rt);Rdd = (shamt>0)?(Rss>>>shamt):(Rss<<-shamt);"
+"Rx[+-]=asl(Rs,Rt)","shamt=sxt7->32(Rt);Rx = Rx [+-] ((shamt>0)?(sxt32->64(Rs)<<shamt):(sxt32->64(Rs)>>-shamt));"
+"Rx[+-]=asr(Rs,Rt)","shamt=sxt7->32(Rt);Rx = Rx [+-] ((shamt>0)?(sxt32->64(Rs)>>shamt):(sxt32->64(Rs)<<-shamt));"
+"Rx[+-]=lsl(Rs,Rt)","shamt=sxt7->32(Rt);Rx = Rx [+-] ((shamt>0)?(zxt32->64(Rs)<<shamt):(zxt32->64(Rs)>>>-shamt));"
+"Rx[+-]=lsr(Rs,Rt)","shamt=sxt7->32(Rt);Rx = Rx [+-] ((shamt>0)?(zxt32->64(Rs)>>>shamt):(zxt32->64(Rs)<<-shamt));"
+"Rxx[+-]=asl(Rss,Rt)","shamt=sxt7->32(Rt);Rxx = Rxx [+-]((shamt>0)?(Rss<<shamt):(Rss>>-shamt));"
+"Rxx[+-]=asr(Rss,Rt)","shamt=sxt7->32(Rt);Rxx = Rxx [+-]((shamt>0)?(Rss>>shamt):(Rss<<-shamt));"
+"Rxx[+-]=lsl(Rss,Rt)","shamt=sxt7->32(Rt);Rxx = Rxx [+-]((shamt>0)?(Rss<<shamt):(Rss>>>-shamt));"
+"Rxx[+-]=lsr(Rss,Rt)","shamt=sxt7->32(Rt);Rxx = Rxx [+-]((shamt>0)?(Rss>>>shamt):(Rss<<-shamt));"
+"Rx[&|]=asl(Rs,Rt)","shamt=sxt7->32(Rt);Rx = Rx [|&] ((shamt>0)?(sxt32->64(Rs)<<shamt):(sxt32->64(Rs)>>-shamt));"
+"Rx[&|]=asr(Rs,Rt)","shamt=sxt7->32(Rt);Rx = Rx [|&] ((shamt>0)?(sxt32->64(Rs)>>shamt):(sxt32->64(Rs)<<-shamt));"
+"Rx[&|]=lsl(Rs,Rt)","shamt=sxt7->32(Rt);Rx = Rx [|&] ((shamt>0)?(zxt32->64(Rs)<<shamt):(zxt32->64(Rs)>>>-shamt));"
+"Rx[&|]=lsr(Rs,Rt)","shamt=sxt7->32(Rt);Rx = Rx [|&] ((shamt>0)?(zxt32->64(Rs)>>>shamt):(zxt32->64(Rs)<<-shamt));"
+"Rxx[&|]=asl(Rss,Rt)","shamt=sxt7->32(Rt);Rxx = Rxx [|&]((shamt>0)?(Rss<<shamt):(Rss>>-shamt));"
+"Rxx[&|]=asr(Rss,Rt)","shamt=sxt7->32(Rt);Rxx = Rxx [|&]((shamt>0)?(Rss>>shamt):(Rss<<-shamt));"
+"Rxx[&|]=lsl(Rss,Rt)","shamt=sxt7->32(Rt);Rxx = Rxx [|&]((shamt>0)?(Rss<<shamt):(Rss>>>-shamt));"
+"Rxx[&|]=lsr(Rss,Rt)","shamt=sxt7->32(Rt);Rxx = Rxx [|&]((shamt>0)?(Rss>>>shamt):(Rss<<-shamt));"
+"Rxx^=asl(Rss,Rt)","shamt=sxt7->32(Rt);Rxx = Rxx ^((shamt>0)?(Rss<<shamt):(Rss>>-shamt));"
+"Rxx^=asr(Rss,Rt)","shamt=sxt7->32(Rt);Rxx = Rxx ^((shamt>0)?(Rss>>shamt):(Rss<<-shamt));"
+"Rxx^=lsl(Rss,Rt)","shamt=sxt7->32(Rt);Rxx = Rxx ^((shamt>0)?(Rss<<shamt):(Rss>>>-shamt));"
+"Rxx^=lsr(Rss,Rt)","shamt=sxt7->32(Rt);Rxx = Rxx ^((shamt>0)?(Rss>>>shamt):(Rss<<-shamt));"
+"Rd=asl(Rs,Rt):sat","shamt=sxt7->32(Rt);Rd = bidir_shiftl(Rs,shamt);"
+"Rd=asr(Rs,Rt):sat","shamt=sxt7->32(Rt);Rd = bidir_shiftr(Rs,shamt);"
+"Rdd=vaslh(Rss,#u4)","for (i=0;i<4;i++) {Rdd.h[i]=(Rss.h[i]<<#u);};",u);
+"Rdd=vasrh(Rss,#u4)","for (i=0;i<4;i++) {Rdd.h[i]=(Rss.h[i]>>#u);};",u);
+"Rdd=vlsrh(Rss,#u4)","for (i=0;i<4;i++) {Rdd.h[i]=(Rss.uh[i]>>#u);};","#u);"
+"Rdd=vasrh(Rss,#u4):raw","for (i=0;i<4;i++){Rdd.h[i]=( ((Rss.h[i] >> #u)+1)>>1 );};"
+"Rdd=vasrh(Rss,#u4):rnd","if (""#u4==0"")Assembler mapped to: ""Rdd=Rss"";} else {Assembler mapped to:""Rdd=vasrh(Rss,#u4-1):raw"";};"
+"Rd=vasrhub(Rss,#u4):raw","for (i=0;i<4;i++) {Rd.b[i]=usat8(((Rss.h[i] >> #u)+1)>>1);};"
+"Rd=vasrhub(Rss,#u4):rnd:sat","if (""#u4==0"") {Assembler mapped to: ""Rd=vsathub(Rss)"";} else {Assembler mapped to:""Rd=vasrhub(Rss,#u4-1):raw"";};"
+"Rd=vasrhub(Rss,#u4):sat","for (i=0;i<4;i++) {Rd.b[i]=usat8(Rss.h[i] >> #u);};"
+"Rdd=vaslh(Rss,Rt)","for (i=0;i<4;i++) {Rdd.h[i]=(sxt7->32(Rt)>0)?(sxt16->64(Rss.h[i])<<sxt7->32(Rt)):(sxt16->64(Rss.h[i])>>-sxt7->32(Rt));};"
+"Rdd=vasrh(Rss,Rt)","for (i=0;i<4;i++) {Rdd.h[i]=(sxt7->32(Rt)>0)?(sxt16->64(Rss.h[i])>>sxt7->32(Rt)):(sxt16->64(Rss.h[i])<<-sxt7->32(Rt));};"
+"Rdd=vlslh(Rss,Rt)","for (i=0;i<4;i++) {Rdd.h[i]=(sxt7->32(Rt)>0)?(zxt16->64(Rss.uh[i])<<sxt7->32(Rt)):(zxt16->64(Rss.uh[i])>>>-sxt7->32(Rt));};"
+"Rdd=vlsrh(Rss,Rt)","for (i=0;i<4;i++) {Rdd.h[i]=(sxt7->32(Rt)>0)?(zxt16->64(Rss.uh[i])>>>sxt7->32(Rt)):(zxt16->64(Rss.uh[i])<<-sxt7->32(Rt));};"
+"Rdd=vaslw(Rss,#u5)","for (i=0;i<2;i++) {Rdd.w[i]=(Rss.w[i]<<#u);}"
+"Rdd=vasrw(Rss,#u5)","for (i=0;i<2;i++) {Rdd.w[i]=(Rss.w[i]>>#u);}"
+"Rdd=vlsrw(Rss,#u5)","for (i=0;i<2;i++) {Rdd.w[i]=(Rss.uw[i]>>#u);}"
+"Rdd=vaslw(Rss,Rt)","for (i=0;i<2;i++) {Rdd.w[i]=(sxt7->32(Rt)>0)?(sxt32->64(Rss.w[i])<<sxt7->32(Rt)):(sxt32->64(Rss.w[i])>>-sxt7->32(Rt));};"
+"Rdd=vasrw(Rss,Rt)","for (i=0;i<2;i++) {Rdd.w[i]=(sxt7->32(Rt)>0)?(sxt32->64(Rss.w[i])>>sxt7->32(Rt)):(sxt32->64(Rss.w[i])<<-sxt7->32(Rt));};"
+"Rdd=vlslw(Rss,Rt)","for (i=0;i<2;i++) {Rdd.w[i]=(sxt7->32(Rt)>0)?(zxt32->64(Rss.uw[i])<<sxt7->32(Rt)):(zxt32->64(Rss.uw[i])>>>-sxt7->32(Rt));};"
+"Rdd=vlsrw(Rss,Rt)","for (i=0;i<2;i++) {Rdd.w[i]=(sxt7->32(Rt)>0)?(zxt32->64(Rss.uw[i])>>>sxt7->32(Rt)):(zxt32->64(Rss.uw[i])<<-sxt7->32(Rt));};"
+"Rd=vasrw(Rss,#u5)","for (i=0;i<2;i++) {Rd.h[i]=(Rss.w[i]>>#u).h[0];};"
+"Rd=vasrw(Rss,Rt)","for (i=0;i<2;i++) {Rd.h[i]=(sxt7->32(Rt)>0)?(sxt32->64(Rss.w[i])>>sxt7->32(Rt)):(sxt32->64(Rss.w[i])<<-sxt7->32(Rt)).h[0];};"
+"Rd=memw(Rs+#u4:2)","apply_extension(#u);EA=Rs+#u;Rd = *EA;"
+"Rd=memub(Rs+#u4:0)","apply_extension(#u);EA=Rs+#u;Rd = *EA;"
+"Rd=#u6","apply_extension(#r);Rd=#u;"
+"Rd=memuh(Rs+#u3:1)","apply_extension(#u);EA=Rs+#u;Rd = *EA;"
+"Rd=memh(Rs+#u3:1)","apply_extension(#u);EA=Rs+#u;Rd = *EA;"
+"Rd=memb(Rs+#u3:0)","apply_extension(#u);EA=Rs+#u;Rd = *EA;"
+"Rd=memw(r29+#u5:2)","apply_extension(#u);EA=r29+#u;Rd = *EA;"
+"Rdd=memd(r29+#u5:3)","apply_extension(#u);EA=r29+#u;Rdd = *EA;"
+if ([!]P0) dealloc_return,";;if ([!]P0[0]) {EA=FP;tmp = *EA;tmp = frame_unscramble(tmp);LR=tmp.w[1];FP=tmp.w[0];SP=EA+8;PC=tmp.w[1];} else {NOP;};"
+"if ([!]P0.new)dealloc_return:nt",";if ([!]P0.new[0]) {EA=FP;tmp = *EA;tmp = frame_unscramble(tmp);LR=tmp.w[1];FP=tmp.w[0];SP=EA+8;PC=tmp.w[1];} else {NOP;};"
+jumpr R31,PC=R31;
+if ([!]P0) jumpr R31,"Assembler mapped to: ""if ([!]P0)""""jumpr"""":nt """"R31"""
+"if ([!]P0[.new])jumpr:<hint> R31","if([!]P0[.new][0]){PC=R31;};"
+"memw(Rs+#u4:2)=Rt","apply_extension(#u);EA=Rs+#u;*EA = Rt;"
+"memh(Rs+#u3:1)=Rt","apply_extension(#u);EA=Rs+#u;*EA = Rt.h[0];"
+"memb(Rs+#u4:0)=Rt","apply_extension(#u);EA=Rs+#u;*EA = Rt&0xff;"
+"memw(r29+#u5:2)=Rt","apply_extension(#u);EA=r29+#u;*EA = Rt;"
+memd(r29+#s6:3)=Rtt,"apply_extension(#s);EA=r29+#s;*EA = Rtt;"
+memw(Rs+#u4:2)=#U1,"apply_extension(#u);EA=Rs+#u;tmp = #U;*EA = tmp;"
+memb(Rs+#u4)=#U1,"apply_extension(#u);EA=Rs+#u;tmp = #U;*EA = tmp;"
+allocframe(#u5:3),"EA=SP-8;*EA=frame_scramble((zxt32->64(LR) << 32) | zxt32->64(FP));FP=EA;frame_check_limit(EA-#u);SP=EA-#u;"
+"Rx=add(Rx,#s7)","apply_extension(#s);Rx=Rx+#s;"
+"Rd=#-1","apply_extension(#r);Rd=-1;"
+if ([!]P0[.new]) Rd=#0,"apply_extension(#s);if ([!]P0[.new][0]) Rd=0;else NOP;"
+"Rd=add(r29,#u6:2)","apply_extension(#s);Rd=r29+#u;"
+"Rx=add(Rx,Rs)",Rx=Rx+Rs;
+"P0=cmp.eq(Rs,#u2)","apply_extension(#u);P0=Rs==#u ? 0xff : 0x00;"
+"Rdd=combine(#0,Rs)","Rdd.w[0]=Rs;Rdd.w[1]=0;"
+"Rdd=combine(Rs,#0)","Rdd.w[0]=0;Rdd.w[1]=Rs;"
+"Rdd=combine(#u2,#U2)","apply_extension(#u);apply_extension(#U);Rdd.w[0]=#U;Rdd.w[1]=#u;"
+"Rd=add(Rs,#1)","Rd=Rs+1;"
+"Rd=add(Rs,#-1)","Rd=Rs-1;"
+"Rd=and(Rs,#1)","Rd=Rs&1;"
+"Rd=and(Rs,#255)","Rd=Rs&255;"
diff --git a/target/hexagon/generator/semantics/semantics.lex b/target/hexagon/generator/semantics/semantics.lex
new file mode 100644
index 0000000000..1a049d9029
--- /dev/null
+++ b/target/hexagon/generator/semantics/semantics.lex
@@ -0,0 +1,592 @@
+%option noyywrap
+%option noinput
+%option nounput
+%option yylineno
+
+%{
+/*
+ * Hexagon emulation for qemu: semantics lexer.
+ *
+ * Copyright (c) 2017-2019 Comsecuris UG (haftungsbeschraenkt)
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <string.h>
+#include <stdbool.h>
+#include "semantics_struct.h"
+#include "semantics.tab.h"
+
+//#define TOKEN_DEBUG
+
+/* Global Error Counter */
+int error_count = 0;
+void yyerror(char *s);
+int fileno(FILE *stream);
+
+%}
+
+/* Definitions */
+DIGIT                    [0-9]
+LOWER_ID                 [a-z]
+UPPER_ID                 [A-Z]
+HEX_DIGIT                [0-9a-fA-F]
+REG_ID_32                e|s|d|t|u|v|x|y
+REG_ID_64                ee|ss|dd|tt|uu|vv|xx|yy
+SYS_ID_32                s|d
+SYS_ID_64                ss|dd
+LOWER_IMM_S              s|m|r
+LOWER_PRE                d|s|t|u|v|e
+UPPER_IMM_S              S|M|R
+ZERO_ONE                 0|1
+
+/* Tokens */
+%option noyywrap
+
+%%
+
+[ \t\f\v]+               { /* Ignore whitespaces. */ }
+[\n\r]+                    { /* Ignore newlines. */ }
+
+"{"                      { return LBR; }
+"}"                      { return RBR; }
+"["                      { return LSQ; } 
+"]"                      { return RSQ; }
+"("                      { return LPAR; }
+")"                      { return RPAR; }
+";"                      { return SEMI; }
+":"                      { return COLON; }
+"+"                      { return PLUS; }
+"-"                      { return MINUS; }
+"[+-]"                   { return PMINUS; }
+"*"                      { return MUL; }
+"**"                     { return POW; }
+"/"                      { return DIV; }
+"%"                      { return MOD; }
+"&"                      { return AND; }
+"|"                      { return OR; }
+"^"                      { return XOR; }
+"[|&]"                   { return ANDOR; }
+"[<<1]"                  { return OPTSHIFT; }
+"[<<N]"                  { return NSHIFT; }
+"~"                      { return NOT; }
+"="                      { return ASSIGN; }
+"+="                     { return INC; }
+"-="                     { return DEC; }
+"++"                     { return PLUSPLUS; }
+"[+-]="                  { return INCDECA; }
+"&="                     { return ANDA; }
+"|="                     { return ORA; }
+"^="                     { return XORA; }
+"[|&]="                  { return ANDORA; }
+"<"                      { return LT; }
+">"                      { return GT; }
+"<<"                     { return ASL; }
+">>"                     { return ASR; }
+"<<R"                    { return ROL; }
+">>>"                    { return LSR; }
+"=="                     { return EQ; }
+"[!]="                   { return OPTEQ; }
+"!="                     { return NEQ; }
+"<="                     { return LTE; }
+">="                     { return GTE; }
+"->"                     { return LARR; }
+"&&"                     { return ANDL; }
+"||"                     { return ORL; }
+"!"                      { return NOTL; }
+","                      { return COMMA; }
+"else"                   { return ELSE; }
+"for"                    { return FOR; }
+"i"                      { return I; }
+"I"                      { return ICIRC; }
+"if"                     { return IF; }
+"Assembler mapped to:"   { return MAPPED; }
+"apply_extension"        { return EXT; }
+"dcache_inv_all"         { return DCKILL; }
+"dcache_clean_addr"      { return DCLEAN; }
+"dcache_cleaninv_addr"   { return DCINVA; }
+"dcache_zero_addr"       { return DZEROA; }
+"dcache_fetch"           { return DFETCH; }
+"icache_inv_all"         { return ICKILL; }
+"l2cache_inv_all"        { return L2KILL; }
+"instruction_sync"       { return ISYNC; }
+"frame_scramble"         { return FSCR; }
+"frame_unscramble"       { return FSCR; }
+"frame_check_limit"      { return FCHK; }
+"Constant_extended"      { return CONSTEXT; }
+"Enter debug mode"       { return BRKPT; }
+"count_leading_ones"     { return LOCNT; }
+"reverse_bits"           { return BREV; }
+"memory_synch"           { return SYNCHT; }
+"(!in_debug_mode)"       { return DEBUG; }
+"lock_valid"             { return LOCK; }
+"modectl[TNUM]"          { return MODECTL; }
+"width"                  { return WIDTH; }
+"offset"                 { return OFFSET; }
+"shamt"                  { return SHAMT; }
+"addr"                   { return ADDR; }
+"sumr"                   { return SUMR; }
+"sumi"                   { return SUMI; }
+"control"                { return CTRL; }
+"tmpr"                   { return TMPR; }
+"tmpi"                   { return TMPI; }
+"tmp"                    { return TMP; }
+"x0"                     { return X0; }
+"x1"                     { return X1; }
+"y0"                     { return Y0; }
+"y1"                     { return Y1; }
+"prod0"                  { return PROD0; }
+"prod1"                  { return PROD1; }
+"sxt"                    { return SXT; }
+"zxt"                    { return ZXT; }
+"min"                    { return MIN; }
+"max"                    { return MAX; }
+"ABS"                    { return ABS; }
+"convround"              { return CROUND; }
+"round"                  { return ROUND; }
+"circ_add"               { return CIRCADD; }
+".new"                   { return NEW; }
+"[.new]"                 { return OPTNEW; }
+"[!]"                    { return OPTNOTL; }
+"[01]"                   { return ZEROONE; }
+"sat"{DIGIT}+            { yylval.vec.width = atoi(yytext + 3);
+                           yylval.vec.index = 0;
+                           yylval.vec.is_unsigned = false;
+                           yylval.vec.is_zeroone = false;
+                           yylval.vec.iter_type = NO_ITER;
+                           return (VEC); }
+"[sat"{DIGIT}+"]"        { yylval.vec.width = atoi(yytext + 4);
+                           yylval.vec.index = 0;
+                           yylval.vec.is_unsigned = false;
+                           yylval.vec.is_zeroone = false;
+                           yylval.vec.iter_type = NO_ITER;
+                           return (VEC); }
+"usat"{DIGIT}+           { yylval.vec.width = atoi(yytext + 4);
+                           yylval.vec.index = 0;
+                           yylval.vec.is_unsigned = true;
+                           yylval.vec.is_zeroone = false;
+                           yylval.vec.iter_type = NO_ITER;
+                           return (VEC); }
+"[usat"{DIGIT}+"]"       { yylval.vec.width = atoi(yytext + 5);
+                           yylval.vec.index = 0;
+                           yylval.vec.is_unsigned = true;
+                           yylval.vec.is_zeroone = false;
+                           yylval.vec.iter_type = NO_ITER;
+                           return (VEC); }
+".u64"                   { return (U64); }
+".i"                     { yylval.vec.width = 1;
+                           yylval.vec.index = -1;
+                           yylval.vec.is_unsigned = false;
+                           yylval.vec.is_zeroone = false;
+                           yylval.vec.iter_type = I_ITER;
+                           return (VEC); }
+".i*2"                   { yylval.vec.width = 1;
+                           yylval.vec.index = -1;
+                           yylval.vec.is_unsigned = false;
+                           yylval.vec.is_zeroone = false;
+                           yylval.vec.iter_type = I2_ITER;
+                           return (VEC); }
+".i*2+1"                 { yylval.vec.width = 1;
+                           yylval.vec.index = -1;
+                           yylval.vec.is_unsigned = false;
+                           yylval.vec.is_zeroone = false;
+                           yylval.vec.iter_type = I2PLUS1_ITER;
+                           return (VEC); }
+".b["{DIGIT}"]"          { yylval.vec.width = 8;
+                           yylval.vec.index = atoi(yytext + 3);
+                           yylval.vec.is_unsigned = false;
+                           yylval.vec.is_zeroone = false;
+                           yylval.vec.iter_type = NO_ITER;
+                           return (VEC); }
+".ub["{DIGIT}"]"         { yylval.vec.width = 8;
+                           yylval.vec.index = atoi(yytext + 4);
+                           yylval.vec.is_unsigned = true;
+                           yylval.vec.is_zeroone = false;
+                           yylval.vec.iter_type = NO_ITER;
+                           return (VEC); }
+".h["{DIGIT}"]"          { yylval.vec.width = 16;
+                           yylval.vec.index = atoi(yytext + 3);
+                           yylval.vec.is_unsigned = false;
+                           yylval.vec.is_zeroone = false;
+                           yylval.vec.iter_type = NO_ITER;
+                           return (VEC); }
+".h[01]"                 { yylval.vec.width = 16;
+                           yylval.vec.is_unsigned = false;
+                           yylval.vec.is_zeroone = true;
+                           yylval.vec.iter_type = NO_ITER;
+                           return (VEC); }
+".uh["{DIGIT}"]"         { yylval.vec.width = 16;
+                           yylval.vec.index = atoi(yytext + 4);
+                           yylval.vec.is_unsigned = true;
+                           yylval.vec.is_zeroone = false;
+                           yylval.vec.iter_type = NO_ITER;
+                           return (VEC); }
+".uh[01]"                { yylval.vec.width = 16;
+                           yylval.vec.index = -1;
+                           yylval.vec.is_unsigned = true;
+                           yylval.vec.is_zeroone = true;
+                           yylval.vec.iter_type = NO_ITER;
+                           return (VEC); }
+".w["{DIGIT}"]"          { yylval.vec.width = 32;
+                           yylval.vec.index = atoi(yytext + 3);
+                           yylval.vec.is_unsigned = false;
+                           yylval.vec.is_zeroone = false;
+                           yylval.vec.iter_type = NO_ITER;
+                           return (VEC); }
+".uw["{DIGIT}"]"         { yylval.vec.width = 32;
+                           yylval.vec.index = atoi(yytext + 4);
+                           yylval.vec.is_unsigned = true;
+                           yylval.vec.is_zeroone = false;
+                           yylval.vec.iter_type = NO_ITER;
+                           return (VEC); }
+".b[i]"                  { yylval.vec.width = 8;
+                           yylval.vec.index = -1;
+                           yylval.vec.is_unsigned = false;
+                           yylval.vec.is_zeroone = false;
+                           yylval.vec.iter_type = I_ITER;
+                           return (VEC); }
+".ub[i]"                 { yylval.vec.width = 8;
+                           yylval.vec.index = -1;
+                           yylval.vec.is_unsigned = true;
+                           yylval.vec.is_zeroone = false;
+                           yylval.vec.iter_type = I_ITER;
+                           return (VEC); }
+".ub[#u]"                { /* XXX: #u maps to the i variable, we assume it is
+                              not interleaved with the i for loop iterator */
+                           yylval.vec.width = 8;
+                           yylval.vec.index = -1;
+                           yylval.vec.is_unsigned = true;
+                           yylval.vec.is_zeroone = false;
+                           yylval.vec.iter_type = I_ITER;
+                           return (VEC); }
+".b[i+1]"                { yylval.vec.width = 8;
+                           yylval.vec.index = -1;
+                           yylval.vec.is_unsigned = false;
+                           yylval.vec.is_zeroone = false;
+                           yylval.vec.iter_type = IPLUS1_ITER;
+                           return (VEC); }
+".h[i]"                  { yylval.vec.width = 16;
+                           yylval.vec.index = -1;
+                           yylval.vec.is_unsigned = false;
+                           yylval.vec.is_zeroone = false;
+                           yylval.vec.iter_type = I_ITER;
+                           return (VEC); }
+".uh[i]"                 { yylval.vec.width = 16;
+                           yylval.vec.index = -1;
+                           yylval.vec.is_unsigned = true;
+                           yylval.vec.is_zeroone = false;
+                           yylval.vec.iter_type = I_ITER;
+                           return (VEC); }
+".w[i]"                  { yylval.vec.width = 32;
+                           yylval.vec.index = -1;
+                           yylval.vec.is_unsigned = false;
+                           yylval.vec.is_zeroone = false;
+                           yylval.vec.iter_type = I_ITER;
+                           return (VEC); }
+".uw[i]"                 { yylval.vec.width = 32;
+                           yylval.vec.index = -1;
+                           yylval.vec.is_unsigned = true;
+                           yylval.vec.is_zeroone = false;
+                           yylval.vec.iter_type = I_ITER;
+                           return (VEC); }
+".b[i*2]"                { yylval.vec.width = 8;
+                           yylval.vec.index = -1;
+                           yylval.vec.is_unsigned = false;
+                           yylval.vec.is_zeroone = false;
+                           yylval.vec.iter_type = I2_ITER;
+                           return (VEC); }
+".ub[i*2]"               { yylval.vec.width = 8;
+                           yylval.vec.index = -1;
+                           yylval.vec.is_unsigned = true;
+                           yylval.vec.is_zeroone = false;
+                           yylval.vec.iter_type = I2_ITER;
+                           return (VEC); }
+".h[i*2]"                { yylval.vec.width = 16;
+                           yylval.vec.index = -1;
+                           yylval.vec.is_unsigned = false;
+                           yylval.vec.is_zeroone = false;
+                           yylval.vec.iter_type = I2_ITER;
+                           return (VEC); }
+".uh[i*2]"               { yylval.vec.width = 16;
+                           yylval.vec.index = -1;
+                           yylval.vec.is_unsigned = true;
+                           yylval.vec.is_zeroone = false;
+                           yylval.vec.iter_type = I2_ITER;
+                           return (VEC); }
+".w[i*2]"                { yylval.vec.width = 32;
+                           yylval.vec.index = -1;
+                           yylval.vec.is_unsigned = false;
+                           yylval.vec.is_zeroone = false;
+                           yylval.vec.iter_type = I2_ITER;
+                           return (VEC); }
+".uw[i*2]"               { yylval.vec.width = 32;
+                           yylval.vec.index = -1;
+                           yylval.vec.is_unsigned = true;
+                           yylval.vec.is_zeroone = false;
+                           yylval.vec.iter_type = I2_ITER;
+                           return (VEC); }
+".b[i*2+1]"              { yylval.vec.width = 8;
+                           yylval.vec.index = -1;
+                           yylval.vec.is_unsigned = false;
+                           yylval.vec.is_zeroone = false;
+                           yylval.vec.iter_type = I2PLUS1_ITER;
+                           return (VEC); }
+".ub[i*2+1]"             { yylval.vec.width = 8;
+                           yylval.vec.index = -1;
+                           yylval.vec.is_unsigned = true;
+                           yylval.vec.is_zeroone = false;
+                           yylval.vec.iter_type = I2PLUS1_ITER;
+                           return (VEC); }
+".h[i*2+1]"              { yylval.vec.width = 16;
+                           yylval.vec.index = -1;
+                           yylval.vec.is_unsigned = false;
+                           yylval.vec.is_zeroone = false;
+                           yylval.vec.iter_type = I2PLUS1_ITER;
+                           return (VEC); }
+".uh[i*2+1]"             { yylval.vec.width = 16;
+                           yylval.vec.index = -1;
+                           yylval.vec.is_unsigned = true;
+                           yylval.vec.is_zeroone = false;
+                           yylval.vec.iter_type = I2PLUS1_ITER;
+                           return (VEC); }
+".w[i*2+1]"              { yylval.vec.width = 32;
+                           yylval.vec.index = -1;
+                           yylval.vec.is_unsigned = false;
+                           yylval.vec.is_zeroone = false;
+                           yylval.vec.iter_type = I2PLUS1_ITER;
+                           return (VEC); }
+".uw[i*2+1]"             { yylval.vec.width = 32;
+                           yylval.vec.index = -1;
+                           yylval.vec.is_unsigned = true;
+                           yylval.vec.is_zeroone = false;
+                           yylval.vec.iter_type = I2PLUS1_ITER;
+                           return (VEC); }
+".b[i+4]"                { yylval.vec.width = 8;
+                           yylval.vec.index = -1;
+                           yylval.vec.is_unsigned = false;
+                           yylval.vec.is_zeroone = false;
+                           yylval.vec.iter_type = IPLUS4_ITER;
+                           return (VEC); }
+"["{DIGIT}":"{DIGIT}"]"  { yylval.range.end = atoi(yytext + 1);
+                           yylval.range.begin = atoi(yytext + 3);
+                           return (RANGE); }
+"#"                      { return HASH; }
+"?"                      { return QMARK; }
+"EA"                     { return EA; }
+"PC"                     { return PC; }
+"NPC"                    { return NPC; }
+"*EA"                    { return STAREA; }
+"TRAP \"0\""             { return TRAP0; }
+"TRAP \"1\""             { return TRAP0; }
+"USR.LPCFG"              { return LPCFG; }
+"SSR.CAUSE"              { return CAUSE; }
+"SSR.SSR_EX"             { return EX; }
+"TLB"                    { return TLB; }
+"IPEND"                  { return IPEND; }
+"xv"                     { return TMP; }
+"sv"                     { return TMP; }
+"tv"                     { return TMP; }
+"(int)"                  { return INT; }
+"NOP"                    { return NOP; }
+
+"SA"{ZERO_ONE}           { yylval.index = atoi(yytext);
+                           return SA; }
+"LC"{ZERO_ONE}           { yylval.index = atoi(yytext);
+                           return LC; }
+"R"{REG_ID_32}           { yylval.rvalue.type = REGISTER;
+                           yylval.rvalue.reg.type = GENERAL_PURPOSE;
+                           yylval.rvalue.reg.id = yytext[1];
+                           yylval.rvalue.reg.is_const = false;
+                           yylval.rvalue.reg.offset = 0;
+                           yylval.rvalue.bit_width = 32;
+                           return (REG); }
+"C"{REG_ID_32}           { yylval.rvalue.type = REGISTER;
+                           yylval.rvalue.reg.type = CONTROL;
+                           yylval.rvalue.reg.id = yytext[1];
+                           yylval.rvalue.reg.is_const = false;
+                           yylval.rvalue.reg.offset = 0;
+                           yylval.rvalue.bit_width = 32;
+                           return (REG); }
+"C"{REG_ID_64}           { yylval.rvalue.type = REGISTER;
+                           yylval.rvalue.reg.type = CONTROL;
+                           yylval.rvalue.reg.id = yytext[1];
+                           yylval.rvalue.reg.is_const = false;
+                           yylval.rvalue.reg.offset = 0;
+                           yylval.rvalue.bit_width = 64;
+                           return (REG); }
+"R"{REG_ID_64}           { yylval.rvalue.type = REGISTER;
+                           yylval.rvalue.reg.type = GENERAL_PURPOSE;
+                           yylval.rvalue.reg.id = yytext[1];
+                           yylval.rvalue.reg.is_const = false;
+                           yylval.rvalue.reg.offset = 0;
+                           yylval.rvalue.bit_width = 64;
+                           return (REG); }
+"N"{LOWER_ID}            { yylval.rvalue.type = REGISTER;
+                           yylval.rvalue.reg.type = GENERAL_PURPOSE;
+                           yylval.rvalue.reg.id = yytext[1];
+                           yylval.rvalue.reg.offset = 0;
+                           yylval.rvalue.reg.is_const = false;
+                           return (REG); }
+"S"{SYS_ID_32}           { yylval.rvalue.type = REGISTER;
+                           yylval.rvalue.reg.type = SYSTEM;
+                           yylval.rvalue.reg.id = yytext[1];
+                           yylval.rvalue.reg.offset = 0;
+                           yylval.rvalue.reg.is_const = false;
+                           yylval.rvalue.bit_width = 32;
+                           return (REG); }
+"S"{SYS_ID_64}           { yylval.rvalue.type = REGISTER;
+                           yylval.rvalue.reg.type = SYSTEM;
+                           yylval.rvalue.reg.id = yytext[1];
+                           yylval.rvalue.reg.offset = 0;
+                           yylval.rvalue.reg.is_const = false;
+                           yylval.rvalue.bit_width = 64;
+                           return (REG); }
+[rR]{DIGIT}+             { yylval.rvalue.type = REGISTER;
+                           yylval.rvalue.reg.type = GENERAL_PURPOSE;
+                           yylval.rvalue.reg.id = atoi(yytext + 1);
+                           yylval.rvalue.reg.offset = 0;
+                           yylval.rvalue.reg.is_const = true;
+                           yylval.rvalue.bit_width = 32;
+                           return (REG); }
+"SGP"{DIGIT}             { yylval.rvalue.type = REGISTER;
+                           yylval.rvalue.reg.type = SYSTEM;
+                           yylval.rvalue.reg.id = atoi(yytext + 3);
+                           yylval.rvalue.reg.offset = 0;
+                           yylval.rvalue.reg.is_const = true;
+                           yylval.rvalue.bit_width = 32;
+                           return (REG); }
+"SP"                     { yylval.rvalue.type = REGISTER;
+                           yylval.rvalue.reg.type = GENERAL_PURPOSE;
+                           yylval.rvalue.reg.id = 29;
+                           yylval.rvalue.reg.offset = 0;
+                           yylval.rvalue.reg.is_const = true;
+                           yylval.rvalue.bit_width = 32;
+                           return (REG); }
+"FP"                     { yylval.rvalue.type = REGISTER;
+                           yylval.rvalue.reg.type = GENERAL_PURPOSE;
+                           yylval.rvalue.reg.id = 30;
+                           yylval.rvalue.reg.offset = 0;
+                           yylval.rvalue.reg.is_const = true;
+                           yylval.rvalue.bit_width = 32;
+                           return (REG); }
+"LR"                     { yylval.rvalue.type = REGISTER;
+                           yylval.rvalue.reg.type = GENERAL_PURPOSE;
+                           yylval.rvalue.reg.id = 31;
+                           yylval.rvalue.reg.offset = 0;
+                           yylval.rvalue.reg.is_const = true;
+                           yylval.rvalue.bit_width = 32;
+                           return (REG); }
+"GP"                     { yylval.rvalue.type = REGISTER;
+                           yylval.rvalue.reg.type = CONTROL;
+                           yylval.rvalue.reg.id = 11;
+                           yylval.rvalue.reg.offset = 0;
+                           yylval.rvalue.reg.is_const = true;
+                           yylval.rvalue.bit_width = 32;
+                           return (REG); }
+"MuV"                    { yylval.rvalue.type = REGISTER;
+                           yylval.rvalue.reg.type = CONTROL;
+                           yylval.rvalue.reg.id = yytext[1];
+                           yylval.rvalue.reg.offset = 6;
+                           yylval.rvalue.reg.is_const = false;
+                           yylval.rvalue.bit_width = 32;
+                           return (REG); }
+"ELR"                    { yylval.rvalue.type = REGISTER;
+                           yylval.rvalue.reg.type = SYSTEM;
+                           yylval.rvalue.reg.id = 3;
+                           yylval.rvalue.reg.offset = 0;
+                           yylval.rvalue.reg.is_const = true;
+                           yylval.rvalue.bit_width = 32;
+                           return (REG); }
+[pP]{DIGIT}              { yylval.rvalue.type = PREDICATE;
+                           yylval.rvalue.pre.id = yytext[1];
+                           yylval.rvalue.pre.is_zeroone = false;
+                           yylval.rvalue.pre.is_bit_iter = false;
+                           yylval.rvalue.bit_width = 8;
+                           return (PRE); }
+"P"{LOWER_PRE}           { yylval.rvalue.type = PREDICATE;
+                           yylval.rvalue.pre.id = yytext[1];
+                           yylval.rvalue.pre.is_zeroone = false;
+                           yylval.rvalue.pre.is_bit_iter = false;
+                           yylval.rvalue.bit_width = 8;
+                           return (PRE); }
+"P"                      { yylval.rvalue.type = PREDICATE;
+                           yylval.rvalue.bit_width = 8;
+                           return (PRE); }
+"#"{LOWER_IMM_S}{DIGIT}* { yylval.rvalue.type = IMMEDIATE;
+                           yylval.rvalue.is_unsigned = false;
+                           yylval.rvalue.imm.type = VARIABLE;
+                           yylval.rvalue.imm.id = 'j';
+                           return (IMM); }
+"#"{UPPER_IMM_S}{DIGIT}* { yylval.rvalue.type = IMMEDIATE;
+                           yylval.rvalue.is_unsigned = false;
+                           yylval.rvalue.imm.type = VARIABLE;
+                           yylval.rvalue.imm.id = 'I';
+                           return (IMM); }
+"#u"{DIGIT}*             { yylval.rvalue.type = IMMEDIATE;
+                           yylval.rvalue.is_unsigned = true;
+                           yylval.rvalue.imm.type = VARIABLE;
+                           yylval.rvalue.imm.id = 'j';
+                           return (IMM); }
+"#U"{DIGIT}*             { yylval.rvalue.type = IMMEDIATE;
+                           yylval.rvalue.is_unsigned = true;
+                           yylval.rvalue.imm.type = VARIABLE;
+                           yylval.rvalue.imm.id = 'I';
+                           return (IMM); }
+"N"                      { yylval.rvalue.type = REGISTER;
+                           yylval.rvalue.imm.type = VARIABLE;
+                           yylval.rvalue.imm.id = 'N';
+                           return (IMM); }
+{DIGIT}+                 { yylval.rvalue.type = IMMEDIATE;
+                           yylval.rvalue.bit_width = 32;
+                           yylval.rvalue.imm.type = VALUE;
+                           yylval.rvalue.imm.value = atoi(yytext);
+                           return (IMM); }
+"0x"{HEX_DIGIT}+         { yylval.rvalue.type = IMMEDIATE;
+                           yylval.rvalue.bit_width = 32;
+                           yylval.rvalue.imm.type = VALUE;
+                           yylval.rvalue.imm.value = strtol(yytext, NULL, 16);
+                           return (IMM); }
+
+.                        { printf("Error: unexpected token \"%s\"\n", yytext);
+                           error_count++;
+                           return (-1); /* invalid token */
+                         }
+
+%%
+
+YYSTYPE yylval;
+
+void yyerror(char *s)               
+{                                   
+    printf("Error '%s' on line %d:\n", s, yylineno);      
+    error_count++;                  
+}                                   
+
+
+#ifdef TOKEN_DEBUG
+int main(void)
+{
+    int token;
+    while ((token = yylex()) != 0)
+        printf("Token: %d (%s)\n", token, yytext);
+    return 0;
+} 
+#endif
diff --git a/target/hexagon/generator/semantics/semantics.y b/target/hexagon/generator/semantics/semantics.y
new file mode 100644
index 0000000000..9516d3900c
--- /dev/null
+++ b/target/hexagon/generator/semantics/semantics.y
@@ -0,0 +1,2723 @@
+%{
+/*
+ * Hexagon emulation for qemu: semantics parser.
+ *
+ * Copyright (c) 2017-2019 Comsecuris UG (haftungsbeschraenkt)
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <assert.h>
+#include <inttypes.h>
+#include <stdarg.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include "semantics_struct.h"
+
+#if __STDC_VERSION__ >= 201112L
+#define C11
+#endif
+
+#define TCGV_NAME_SIZE 7
+#define MAX_WRITTEN_REGS 32
+#define OFFSET_STR_LEN 32
+
+enum op_type {ADD, SUBTRACT, ADDSUB, MULTIPLY, DIVIDE,
+              ASHIFTL, ASHIFTR, LSHIFTR, ROTATE, ANDB, ORB, ANDORB, XORB,
+              MINI, MAXI, MODULO};
+enum cmp_type {EQ_OP, NEQ_OP, OPTEQ_OP, LT_OP, LTU_OP, GT_OP, GTU_OP,
+               LTE_OP, LEU_OP, GTE_OP, GEU_OP};
+enum mem_type {MEM_BYTE, MEM_HALF, MEM_WORD, MEM_DOUBLE};
+
+/* Global Variables */
+int tmp_count = 0;
+int qemu_tmp_count = 0;
+int not_count = 0;
+int zeroone_count = 0;
+int predicate_count = 0;
+int highlow_count = 0;
+int p_reg_count = 0;
+int if_count = 0;
+bool no_track_regs = false;
+bool is_extra_created[TMP_T - EA_T + 1] = { 0 };
+bool ea_declared = false;
+bool is_jump = false;
+bool is_stop = false;
+bool mem_unsigned = false;
+enum mem_type mem_size = MEM_DOUBLE; 
+char written_regs[MAX_WRITTEN_REGS] = { 0 };
+int written_index = 0;
+
+extern void yyerror(const char *s);
+extern int error_count;
+
+/* Print functions */
+void str_print(const char *string) {
+    printf("%s", string);
+}
+
+void uint64_print(uint64_t *num) {
+    printf("%" PRIu64, *num);
+}
+
+void int_print(int *num) {
+    printf("%d", *num);
+}
+
+void tmp_print(t_hex_tmp *tmp) {
+    printf("tmp_");
+    printf("%d", tmp->index);
+}
+
+void reg_print(t_hex_reg *reg, bool is_dotnew, bool is_optnew) {
+  /* TODO: Handle optnew */
+  char * reg_prefix;
+  switch (reg->type) {
+    case GENERAL_PURPOSE:
+        reg_prefix = "GPR";
+        for(int i = 0; i < written_index; i++) {
+          if (reg->id == written_regs[i]) {
+              is_dotnew = true;
+              is_optnew = false;
+          }
+        }
+        break;
+    case CONTROL: reg_prefix = "CR"; break;
+    case SYSTEM: reg_prefix = "SR"; break;
+  }
+  assert(reg->type != SYSTEM || !is_dotnew &&
+         "System registers can't be .new!");
+  char * reg_suffix = (is_dotnew) ? "_new[" : "[";
+  if (reg->offset != 0)
+    printf("%s%s%d +", reg_prefix, reg_suffix, reg->offset);
+  else
+    printf("%s%s", reg_prefix, reg_suffix);
+  if (reg->is_const)
+    printf("%d", reg->id);
+  else
+    printf("%c", reg->id);
+  printf("]");
+}
+
+void imm_print(t_hex_imm *imm) {
+    switch(imm->type) {
+        case VARIABLE:
+            printf("%c", imm->id);
+            break;
+        case VALUE:
+            printf("%" PRIu64, imm->value);
+            break;
+        case QEMU_TMP:
+            printf("qemu_tmp_%" PRIu64, imm->index);
+            break;
+        case IMM_PC:
+            printf("dc->pc");
+            break;
+        case IMM_CONSTEXT:
+            printf("dc->extender_present");
+            break;
+        default:
+            assert(false && "Cannot print this!");
+            yyerror("Cannot print this expression");
+    }
+}
+
+void extra_print(t_hex_extra *extra) {
+    switch (extra->type) {
+        case EA_T:
+            printf("EA");
+            break;
+        case LPCFG_T:
+            printf("LPCFG");
+            break;
+        case LC_T:
+            printf("LC[%d]", extra->index); 
+            break;
+        case SA_T:
+            printf("SA[%d]", extra->index); 
+            break;
+        case WIDTH_T:
+            printf("width");
+            break;
+        case OFFSET_T:
+            printf("offset");
+            break;
+        case SHAMT_T:
+            printf("shamt");
+            break;
+        case ADDR_T:
+            printf("addr");
+            break;
+        case SUMR_T:
+            printf("sumr");
+            break;
+        case SUMI_T:
+            printf("sumi");
+            break;
+        case CTRL_T:
+            printf("control");
+            break;
+        case TMPR_T:
+            printf("tmpr");
+            break;
+        case TMPI_T:
+            printf("tmpi");
+            break;
+        case X0_T:
+            printf("x0");
+            break;
+        case X1_T:
+            printf("x1");
+            break;
+        case Y0_T:
+            printf("y0");
+            break;
+        case Y1_T:
+            printf("y1");
+            break;
+        case PROD0_T:
+            printf("prod0");
+            break;
+        case PROD1_T:
+            printf("prod1");
+            break;
+        case MAX_T:
+            printf("max");
+            break;
+        case MIN_T:
+            printf("min");
+            break;
+        case TMP_T:
+            printf("tmp");
+            break;
+        default:
+            assert(false && "Error: malformed extra type!");
+    }
+}
+
+void rvalue_out(void *pointer) {
+  t_hex_value *rvalue = (t_hex_value *) pointer;
+  switch (rvalue->type) {
+      case REGISTER:
+          reg_print(&rvalue->reg, rvalue->is_dotnew, rvalue->is_optnew);
+          break;
+      case TEMP:
+          tmp_print(&rvalue->tmp);
+          break;
+      case IMMEDIATE:
+          imm_print(&rvalue->imm);
+          break;
+      case EXTRA:
+          extra_print(&rvalue->extra);
+          break;
+      default:
+          assert(false && "Cannot print this!");
+          yyerror("Cannot print this expression");
+  }
+}
+
+void cmp_out(void *pointer) {
+    enum cmp_type *type = (enum cmp_type *) pointer;
+    switch(*type) {
+        case EQ_OP:
+            puts("TCG_COND_EQ");
+            break;
+        case NEQ_OP:
+            puts("TCG_COND_NE");
+            break;
+        case OPTEQ_OP:
+            printf("not");
+            printf("%d", not_count);
+            printf(" ? TCG_COND_NE : TCG_COND_EQ");
+            not_count++;
+            break;
+        case LT_OP:
+            puts("TCG_COND_LT");
+            break;
+        case LTU_OP:
+            puts("TCG_COND_LTU");
+            break;
+        case GT_OP:
+            puts("TCG_COND_GT");
+            break;
+        case GTU_OP:
+            puts("TCG_COND_GTU");
+            break;
+        case LTE_OP:
+            puts("TCG_COND_LE");
+            break;
+        case LEU_OP:
+            puts("TCG_COND_LEU");
+            break;
+        case GTE_OP:
+            puts("TCG_COND_GE");
+            break;
+        case GEU_OP:
+            puts("TCG_COND_GEU");
+            break;
+        default:
+            assert(false && "Unhandled comparison operator!");
+    }
+}
+
+#ifdef C11
+
+#define OUT_IMPL(x)                                             \
+  do {                                                          \
+    _Generic((x),                                               \
+             char *: str_print,                                 \
+             const char *: str_print,                           \
+             int *: int_print,                                  \
+             uint64_t *: uint64_print,                          \
+             t_hex_value *: rvalue_out,                         \
+             enum cmp_type *: cmp_out)((x));                    \
+  } while(0);
+
+#else
+
+#define OUT_IMPL(x)                                                     \
+  do {                                                                  \
+    if (__builtin_types_compatible_p (typeof (*x), char))               \
+      str_print((char *) x);                                            \
+    else if (__builtin_types_compatible_p (typeof (*x), uint64_t))      \
+      uint64_print((uint64_t *) x);                                     \
+    else if (__builtin_types_compatible_p (typeof (*x), int))           \
+      int_print((int *) x);                                             \
+    else if (__builtin_types_compatible_p (typeof (*x), t_hex_value))     \
+      rvalue_out((t_hex_value *) x);                                         \
+    else if (__builtin_types_compatible_p (typeof (*x), enum cmp_type)) \
+      cmp_out((enum cmp_type *) x);                                     \
+    else                                                                \
+      assert(false && "Unhandled print type!");                         \
+  } while(0);
+
+#endif
+
+// Make a FOREACH macro
+#define FE_1(WHAT, X) WHAT(X)
+#define FE_2(WHAT, X, ...) WHAT(X)FE_1(WHAT, __VA_ARGS__)
+#define FE_3(WHAT, X, ...) WHAT(X)FE_2(WHAT, __VA_ARGS__)
+#define FE_4(WHAT, X, ...) WHAT(X)FE_3(WHAT, __VA_ARGS__)
+#define FE_5(WHAT, X, ...) WHAT(X)FE_4(WHAT, __VA_ARGS__)
+#define FE_6(WHAT, X, ...) WHAT(X)FE_5(WHAT, __VA_ARGS__)
+#define FE_7(WHAT, X, ...) WHAT(X)FE_6(WHAT, __VA_ARGS__)
+#define FE_8(WHAT, X, ...) WHAT(X)FE_7(WHAT, __VA_ARGS__)
+#define FE_9(WHAT, X, ...) WHAT(X)FE_8(WHAT, __VA_ARGS__)
+//... repeat as needed
+
+#define GET_MACRO(_1, _2, _3, _4, _5, _6, _7, _8, _9, NAME, ...) NAME
+
+#define FOR_EACH(action, ...)                   \
+  do {                                          \
+    GET_MACRO(__VA_ARGS__,                      \
+              FE_9,                             \
+              FE_8,                             \
+              FE_7,                             \
+              FE_6,                             \
+              FE_5,                             \
+              FE_4,                             \
+              FE_3,                             \
+              FE_2,                             \
+              FE_1)(action,                     \
+                    __VA_ARGS__)                \
+  } while (0)
+
+#define OUT(...) FOR_EACH(OUT_IMPL, __VA_ARGS__)
+
+enum cmp_type cmp_swap(enum cmp_type type) {
+    switch(type) {
+        case EQ_OP:
+            return EQ_OP;
+            break;
+        case NEQ_OP:
+            return NEQ_OP;
+            break;
+        case LT_OP:
+            return GT_OP;
+            break;
+        case LTU_OP:
+            return GTU_OP;
+            break;
+        case GT_OP:
+            return LT_OP;
+            break;
+        case GTU_OP:
+            return LTU_OP;
+            break;
+        case LTE_OP:
+            return GTE_OP;
+            break;
+        case LEU_OP:
+            return GEU_OP;
+            break;
+        case GTE_OP:
+            return LTE_OP;
+            break;
+        case GEU_OP:
+            return LEU_OP;
+            break;
+        default:
+            assert(false && "Unhandled comparison swap!");
+    }
+}
+
+t_hex_value gen_extra(enum rvalue_extra_type type, int index, bool temp) {
+    t_hex_value rvalue;
+    rvalue.type = EXTRA;
+    rvalue.is_unsigned = false;
+    rvalue.is_dotnew = false;
+    rvalue.is_optnew = false;
+    rvalue.is_vectorial = false;
+    rvalue.is_range = false;
+    rvalue.is_symbol = false;
+    rvalue.extra.type = type;
+    rvalue.extra.index = index;
+    rvalue.extra.temp = temp;
+    rvalue.bit_width = (type == TMP_T) ? 64 : 32;
+    return rvalue;
+}
+
+/* Temporary values creation */
+t_hex_value gen_tmp(int bit_width) {
+    t_hex_value rvalue;
+    rvalue.type = TEMP;
+    bit_width = (bit_width == 64) ? 64 : 32;
+    rvalue.bit_width = bit_width;
+    rvalue.is_unsigned = false;
+    rvalue.is_dotnew = false;
+    rvalue.is_optnew = false;
+    rvalue.is_vectorial = false;
+    rvalue.is_range = false;
+    rvalue.is_symbol = false;
+    rvalue.tmp.index = tmp_count;
+    OUT("TCGv_i", &bit_width, " tmp_", &tmp_count, " = tcg_temp_new_i",
+        &bit_width, "();\n");
+    tmp_count++;
+    return rvalue;
+}
+
+t_hex_value gen_local_tmp(int bit_width) {
+    t_hex_value rvalue;
+    rvalue.type = TEMP;
+    bit_width = (bit_width == 64) ? 64 : 32;
+    rvalue.bit_width = bit_width;
+    rvalue.is_unsigned = false;
+    rvalue.is_dotnew = false;
+    rvalue.is_optnew = false;
+    rvalue.is_vectorial = false;
+    rvalue.is_range = false;
+    rvalue.is_symbol = false;
+    rvalue.tmp.index = tmp_count;
+    OUT("TCGv_i", &bit_width, " tmp_", &tmp_count, " = tcg_temp_local_new_i",
+        &bit_width, "();\n");
+    tmp_count++;
+    return rvalue;
+}
+
+t_hex_value gen_tmp_value(char * value, int bit_width) {
+    t_hex_value rvalue;
+    rvalue.type = TEMP;
+    rvalue.bit_width = bit_width;
+    rvalue.is_unsigned = false;
+    rvalue.is_dotnew = false;
+    rvalue.is_optnew = false;
+    rvalue.is_vectorial = false;
+    rvalue.is_range = false;
+    rvalue.is_symbol = false;
+    rvalue.tmp.index = tmp_count;
+    OUT("TCGv_i", &bit_width, " tmp_", &tmp_count, " = tcg_const_i", &bit_width, "(",
+        value, ");\n");
+    tmp_count++;
+    return rvalue;
+}
+
+t_hex_value gen_imm_value(int value, int bit_width) {
+    t_hex_value rvalue;
+    rvalue.type = IMMEDIATE;
+    rvalue.bit_width = bit_width;
+    rvalue.is_unsigned = false;
+    rvalue.is_dotnew = false;
+    rvalue.is_optnew = false;
+    rvalue.is_vectorial = false;
+    rvalue.is_range = false;
+    rvalue.is_symbol = false;
+    rvalue.imm.type = VALUE;
+    rvalue.imm.value = value;
+    return rvalue;
+}
+
+void rvalue_free(t_hex_value *rvalue) {
+    if (rvalue->type == TEMP) {
+        char * bit_suffix = (rvalue->bit_width == 64) ? "i64" : "i32";
+        OUT("tcg_temp_free_", bit_suffix, "(", rvalue, ");\n");
+    }
+}
+
+void rvalue_materialize(t_hex_value *rvalue) {
+    if (rvalue->type == IMMEDIATE) {
+        t_hex_value tmp = gen_tmp(rvalue->bit_width);
+        char * bit_suffix = (rvalue->bit_width == 64) ? "i64" : "i32";
+        OUT("tcg_gen_movi_", bit_suffix, "(", &tmp, ", ", rvalue, ");\n");
+        tmp.is_symbol = rvalue->is_symbol;
+        rvalue_free(rvalue);
+        *rvalue = tmp;
+    }
+}
+
+void rvalue_extend(t_hex_value *rvalue) {
+    if (rvalue->type == IMMEDIATE)
+        rvalue->bit_width = 64;
+    else {
+        if (rvalue->bit_width == 32) {
+            t_hex_value tmp = gen_tmp(64);
+            char * sign_suffix = (rvalue->is_unsigned) ? "u" : "";
+            OUT("tcg_gen_ext", sign_suffix, "_i32_i64(", &tmp, ", ", rvalue, ");\n");
+            rvalue_free(rvalue);
+            *rvalue = tmp;
+        }
+    }
+}
+
+void rvalue_truncate(t_hex_value *rvalue) {
+    if (rvalue->type == IMMEDIATE)
+        rvalue->bit_width = 32;
+    else {
+        if (rvalue->bit_width == 64) {
+            t_hex_value tmp = gen_tmp(32);
+            OUT("tcg_gen_trunc_i64_tl(", &tmp, ", ", rvalue, ");\n");
+            rvalue_free(rvalue);
+            *rvalue = tmp;
+        }
+    }
+}
+
+t_hex_value reg_concat(t_hex_value *rvalue) {
+    if (rvalue->type == REGISTER) {
+        if (rvalue->bit_width == 64) {
+            /* In a register pair the first register holds
+               the lower 32 bits, the next one holds the upper
+               32 bits */
+            const char * reg_prefix;
+            switch (rvalue->reg.type) {
+              case GENERAL_PURPOSE: reg_prefix = "GPR["; break;
+              case CONTROL: reg_prefix = "CR["; break;
+              case SYSTEM: reg_prefix = "SR["; break;
+            }
+            t_hex_value res = gen_tmp(64);
+            if (rvalue->reg.offset != 0) {
+                OUT("tcg_gen_concat_i32_i64(", &res, ", ");
+                OUT(reg_prefix, &(rvalue->reg.offset), " + ");
+                OUT(&(rvalue->reg.id), "], ");
+                OUT(reg_prefix, &(rvalue->reg.offset), " + ");
+                OUT(&(rvalue->reg.id), " + 1]);\n");
+            } else {
+                OUT("tcg_gen_concat_i32_i64(", &res, ", ", rvalue, ", ");
+                OUT(reg_prefix, &(rvalue->reg.id), " + 1]);\n");
+            }
+            res.vec = rvalue->vec;
+            res.is_unsigned = rvalue->is_unsigned;
+            res.is_dotnew = rvalue->is_dotnew;
+            res.is_optnew = rvalue->is_optnew;
+            res.is_vectorial = rvalue->is_vectorial;
+            return res;
+        }
+    }
+    return *rvalue;
+}
+
+void ea_free() {
+    OUT("tcg_temp_free(EA);\n");
+}
+
+void reg_set_written(t_hex_value *reg, int offset) {
+    written_regs[written_index] = reg->reg.id;
+    written_index++;
+    if (!no_track_regs)
+        OUT("SET_USED_REG(regs, ");
+    if (offset != 0) {
+        char *sign = (offset > 0) ? " + " : " - ";
+        int abs_offset = abs(offset);
+        if (reg->reg.is_const)
+          printf("(%d", reg->reg.id);
+        else
+          printf("(%c", reg->reg.id);
+        OUT(sign, &abs_offset, ")");
+    }
+    else {
+        if (reg->reg.is_const)
+          printf("%d", reg->reg.id);
+        else
+          printf("%c", reg->reg.id);
+    }
+    OUT(");\n");
+}
+
+/* Code generation functions */
+t_hex_value gen_bin_op(enum op_type type,
+                     t_hex_value *op1,
+                     t_hex_value *op2)
+{
+#define IMM_IMM 0
+#define IMM_REG 1
+#define REG_IMM 2
+#define REG_REG 3
+
+    int op_types = (op1->type != IMMEDIATE) << 1 | (op2->type != IMMEDIATE);
+
+    /* Find bit width of the two operands,
+       if at least one is 64 bit use a 64bit operation,
+       eventually extend 32bit operands. */
+    bool op_is64bit = op1->bit_width == 64 || op2->bit_width == 64;
+    /* Multiplication is always 64 bits wide */
+    if (type == MULTIPLY)
+        op_is64bit = true;
+    /* Shift greater than 32 are 64 bits wide */
+    if (type == ASHIFTL && op2->type == IMMEDIATE &&
+        op2->imm.type == VALUE && op2->imm.value >= 32)
+        op_is64bit = true;
+    char * bit_suffix = op_is64bit ? "i64" : "i32";
+    int bit_width = (op_is64bit) ? 64 : 32;
+    /* TODO: Handle signedness */
+    if (op_is64bit) {
+        switch(op_types) {
+            case IMM_REG:
+                rvalue_extend(op2);
+                break;
+            case REG_IMM:
+                rvalue_extend(op1);
+                break;
+            case REG_REG:
+                rvalue_extend(op1);
+                rvalue_extend(op2);
+                break;
+        }
+    }
+    t_hex_value res;
+    if (op_types != IMM_IMM) {
+        /* TODO: If one of the operands is a temp reuse it and don't free it */
+        res = gen_tmp(bit_width);
+        res.type = TEMP;
+    } else {
+        res.type = IMMEDIATE;
+        res.is_unsigned = false;
+        res.is_dotnew = false;
+        res.is_optnew = false;
+        res.is_vectorial = false;
+        res.is_range = false;
+        res.is_symbol = false;
+        res.imm.type = QEMU_TMP;
+        res.imm.index = qemu_tmp_count;
+    }
+
+    switch(type) {
+        case ADD:
+        {
+            switch(op_types) {
+                case IMM_IMM:
+                    OUT("int", &bit_width, "_t ", &res, " = ", op1, " + ", op2, ";\n");
+                    break;
+                case IMM_REG:
+                    OUT("tcg_gen_addi_", bit_suffix, "(", &res, ", ", op2, ", ", op1, ");\n");
+                    break;
+                case REG_IMM:
+                    OUT("tcg_gen_addi_", bit_suffix, "(", &res, ", ", op1, ", ", op2, ");\n");
+                    break;
+                case REG_REG:
+                    OUT("tcg_gen_add_", bit_suffix, "(", &res, ", ", op1, ", ", op2, ");\n");
+                    break;
+                default:
+                    fprintf(stderr, "Error in evalutating immediateness!");
+                    abort();
+            }
+            break;
+        }
+        case SUBTRACT:
+        {
+            switch(op_types) {
+                case IMM_IMM:
+                    OUT("int", &bit_width, "_t ", &res, " = ", op1, " - ", op2, ";\n");
+                    break;
+                case IMM_REG:
+                    OUT("tcg_gen_subfi_", bit_suffix, "(", &res, ", ", op1, ", ", op2, ");\n");
+                    break;
+                case REG_IMM:
+                    OUT("tcg_gen_subi_", bit_suffix, "(", &res, ", ", op1, ", ", op2, ");\n");
+                    break;
+                case REG_REG:
+                    OUT("tcg_gen_sub_", bit_suffix, "(", &res, ", ", op1, ", ", op2, ");\n");
+                    break;
+                default:
+                    fprintf(stderr, "Error in evalutating immediateness!");
+                    abort();
+            }
+            break;
+        }
+        case ADDSUB:
+        {
+            switch(op_types) {
+                case IMM_IMM:
+                    OUT("int", &bit_width, "_t ", &res, " = plus_minus ? (");
+                    OUT(op1, " + ", op2, ") : (", op1, " - ", op2, ");\n");
+                    break;
+                case IMM_REG:
+                    OUT("if (plus_minus)\n");
+                    OUT("tcg_gen_addi_", bit_suffix, "(", &res, ", ", op2, ", ", op1, ");\n");
+                    OUT("else\n");
+                    OUT("tcg_gen_subi_", bit_suffix, "(", &res, ", ", op2, ", ", op1, ");\n");
+                    break;
+                case REG_IMM:
+                    OUT("if (plus_minus)\n");
+                    OUT("tcg_gen_addi_", bit_suffix, "(", &res, ", ", op1, ", ", op2, ");\n");
+                    OUT("else\n");
+                    OUT("tcg_gen_subi_", bit_suffix, "(", &res, ", ", op1, ", ", op2, ");\n");
+                    break;
+                case REG_REG:
+                    OUT("if (plus_minus)\n");
+                    OUT("tcg_gen_add_", bit_suffix, "(", &res, ", ", op1, ", ", op2, ");\n");
+                    OUT("else\n");
+                    OUT("tcg_gen_sub_", bit_suffix, "(", &res, ", ", op1, ", ", op2, ");\n");
+                    break;
+                default:
+                    fprintf(stderr, "Error in evalutating immediateness!");
+                    abort();
+            }
+            break;
+        }
+        case MULTIPLY:
+        {
+            switch(op_types) {
+                case IMM_IMM:
+                    OUT("int64_t ", &res, " = ", op1, " * ", op2, ";\n");
+                    break;
+                case IMM_REG:
+                    rvalue_extend(op2);
+                    OUT("tcg_gen_muli_i64(", &res, ", ", op2, ", (int64_t)", op1, ");\n");
+                    break;
+                case REG_IMM:
+                    rvalue_extend(op1);
+                    OUT("tcg_gen_muli_i64(", &res, ", ", op1, ", (int64_t)", op2, ");\n");
+                    break;
+                case REG_REG:
+                    rvalue_extend(op1);
+                    rvalue_extend(op2);
+                    OUT("tcg_gen_mul_i64(", &res, ", ", op1, ", ", op2, ");\n");
+                    break;
+                default:
+                    fprintf(stderr, "Error in evalutating immediateness!");
+                    abort();
+            }
+            break;
+        }
+        case DIVIDE:
+        {
+            switch(op_types) {
+                case IMM_IMM:
+                    OUT("int64_t ", &res, " = ", op1, " / ", op2, ";\n");
+                    break;
+                case IMM_REG:
+                case REG_IMM:
+                case REG_REG:
+                    OUT(&res, " = gen_helper_divu(cpu_env, ", op1, ", ", op2, ");\n");
+                    break;
+                default:
+                    fprintf(stderr, "Error in evalutating immediateness!");
+                    abort();
+            }
+            break;
+        }
+        case ASHIFTL:
+        {
+            switch(op_types) {
+                case IMM_IMM:
+                    OUT("int", &bit_width, "_t ", &res, " = ", op1, " << ", op2, ";\n");
+                    break;
+                case REG_IMM:
+                    OUT("tcg_gen_shli_", bit_suffix, "(", &res, ", ", op1, ", ", op2, ");\n");
+                    break;
+                case IMM_REG:
+                    rvalue_materialize(op1);
+                    /* fallthrough */
+                case REG_REG:
+                    OUT("tcg_gen_shl_", bit_suffix, "(", &res, ", ", op1, ", ", op2, ");\n");
+                    break;
+                default:
+                    fprintf(stderr, "Error in evalutating immediateness!");
+                    abort();
+            }
+            if (op_types != IMM_IMM) {
+                /* Handle left shift by 64 which hexagon-sim expects to clear out register */
+                t_hex_value edge = gen_tmp_value("64", bit_width);
+                t_hex_value zero = gen_tmp_value("0", bit_width);
+                if (op_is64bit)
+                    rvalue_extend(op2);
+                rvalue_materialize(op1);
+                rvalue_materialize(op2);
+                op2->is_symbol = true;
+                rvalue_materialize(&edge);
+                OUT("tcg_gen_movcond_i", &bit_width);
+                if (op_types == REG_REG || op_types == IMM_REG)
+                    OUT("(TCG_COND_EQ, ", &res, ", ", op2, ", ", &edge);
+                else
+                    OUT("(TCG_COND_EQ, ", &res, ", ", op2, ", ", &edge);
+                OUT(", ", &zero, ", ", &res, ");\n");
+                rvalue_free(&edge);
+                rvalue_free(&zero);
+            }
+            break;
+        }
+        case ASHIFTR:
+        {
+            switch(op_types) {
+                case IMM_IMM:
+                    OUT("int", &bit_width, "_t ", &res, " = ", op1, " >> ", op2, ";\n");
+                    break;
+                case REG_IMM:
+                    OUT("tcg_gen_sari_", bit_suffix, "(", &res, ", ", op1, ", ", op2, ");\n");
+                    break;
+                case IMM_REG:
+                    rvalue_materialize(op1);
+                    /* fallthrough */
+                case REG_REG:
+                    OUT("tcg_gen_sar_", bit_suffix, "(", &res, ", ", op1, ", ", op2, ");\n");
+                    break;
+                default:
+                    fprintf(stderr, "Error in evalutating immediateness!");
+                    abort();
+            }
+            break;
+        }
+        case LSHIFTR:
+        {
+            switch(op_types) {
+                case IMM_IMM:
+                    OUT("int", &bit_width, "_t ", &res, " = ", op1, " >> ", op2, ";\n");
+                    break;
+                case REG_IMM:
+                    OUT("tcg_gen_shri_", bit_suffix, "(", &res, ", ", op1, ", ", op2, ");\n");
+                    break;
+                case IMM_REG:
+                    rvalue_materialize(op1);
+                    /* fallthrough */
+                case REG_REG:
+                    OUT("tcg_gen_shr_", bit_suffix, "(", &res, ", ", op1, ", ", op2, ");\n");
+                    break;
+                default:
+                    fprintf(stderr, "Error in evalutating immediateness!");
+                    abort();
+            }
+            break;
+        }
+        case ROTATE:
+        {
+            switch(op_types) {
+                case IMM_IMM:
+                    OUT("int", &bit_width, "_t ", &res, " = ", op1, " >> ", op2, ";\n");
+                    break;
+                case REG_IMM:
+                    OUT("tcg_gen_rotli_", bit_suffix, "(", &res, ", ", op1, ", ", op2, ");\n");
+                    break;
+                case IMM_REG:
+                    rvalue_materialize(op1);
+                    /* fallthrough */
+                case REG_REG:
+                    OUT("tcg_gen_rotl_", bit_suffix, "(", &res, ", ", op1, ", ", op2, ");\n");
+                    break;
+                default:
+                    fprintf(stderr, "Error in evalutating immediateness!");
+                    abort();
+            }
+            break;
+        }
+        case ANDB:
+        {
+            switch(op_types) {
+                case IMM_IMM:
+                    OUT("int", &bit_width, "_t ", &res, " = ", op1, " & ", op2, ";\n");
+                    break;
+                case IMM_REG:
+                    OUT("tcg_gen_andi_", bit_suffix, "(", &res, ", ", op2, ", ", op1, ");\n");
+                    break;
+                case REG_IMM:
+                    OUT("tcg_gen_andi_", bit_suffix, "(", &res, ", ", op1, ", ", op2, ");\n");
+                    break;
+                case REG_REG:
+                    OUT("tcg_gen_and_", bit_suffix, "(", &res, ", ", op1, ", ", op2, ");\n");
+                    break;
+                default:
+                    fprintf(stderr, "Error in evalutating immediateness!");
+                    abort();
+            }
+            break;
+        }
+        case ORB:
+        {
+            switch(op_types) {
+                case IMM_IMM:
+                    OUT("int", &bit_width, "_t ", &res, " = ", op1, " & ", op2, ";\n");
+                    break;
+                case IMM_REG:
+                    OUT("tcg_gen_ori_", bit_suffix, "(", &res, ", ", op2, ", ", op1, ");\n");
+                    break;
+                case REG_IMM:
+                    OUT("tcg_gen_ori_", bit_suffix, "(", &res, ", ", op1, ", ", op2, ");\n");
+                    break;
+                case REG_REG:
+                    OUT("tcg_gen_or_", bit_suffix, "(", &res, ", ", op1, ", ", op2, ");\n");
+                    break;
+                default:
+                    fprintf(stderr, "Error in evalutating immediateness!");
+                    abort();
+            }
+            break;
+        }
+        case ANDORB:
+        {
+            switch(op_types) {
+                case IMM_IMM:
+                    OUT("int", &bit_width, "_t ", &res, " = and_or ? (");
+                    OUT(op1, " & ", op2, ") : (", op1, " | ", op2, ");\n");
+                    break;
+                case IMM_REG:
+                    OUT("if (and_or)\n");
+                    OUT("tcg_gen_andi_", bit_suffix, "(", &res, ", ", op2, ", ", op1, ");\n");
+                    OUT("else\n");
+                    OUT("tcg_gen_ori_", bit_suffix, "(", &res, ", ", op2, ", ", op1, ");\n");
+                    break;
+                case REG_IMM:
+                    OUT("if (and_or)\n");
+                    OUT("tcg_gen_andi_", bit_suffix, "(", &res, ", ", op1, ", ", op2, ");\n");
+                    OUT("else\n");
+                    OUT("tcg_gen_ori_", bit_suffix, "(", &res, ", ", op1, ", ", op2, ");\n");
+                    break;
+                case REG_REG:
+                    OUT("if (and_or)\n");
+                    OUT("tcg_gen_and_", bit_suffix, "(", &res, ", ", op1, ", ", op2, ");\n");
+                    OUT("else\n");
+                    OUT("tcg_gen_or_", bit_suffix, "(", &res, ", ", op1, ", ", op2, ");\n");
+                    break;
+                default:
+                    fprintf(stderr, "Error in evalutating immediateness!");
+                    abort();
+            }
+            break;
+        }
+        case XORB:
+        {
+            switch(op_types) {
+                case IMM_IMM:
+                    OUT("int", &bit_width, "_t ", &res, " = ", op1, " & ", op2, ";\n");
+                    break;
+                case IMM_REG:
+                    OUT("tcg_gen_xori_", bit_suffix, "(", &res, ", ", op2, ", ", op1, ");\n");
+                    break;
+                case REG_IMM:
+                    OUT("tcg_gen_xori_", bit_suffix, "(", &res, ", ", op1, ", ", op2, ");\n");
+                    break;
+                case REG_REG:
+                    OUT("tcg_gen_xor_", bit_suffix, "(", &res, ", ", op1, ", ", op2, ");\n");
+                    break;
+                default:
+                    fprintf(stderr, "Error in evalutating immediateness!");
+                    abort();
+            }
+            break;
+        }
+        case MINI:
+        {
+            switch(op_types) {
+                case IMM_IMM:
+                    OUT("int", &bit_width, "_t ", &res, " = (", op1, " <= ");
+                    OUT(op2, ") ? ", op1, " : ", op2, ";\n");
+                    break;
+                case IMM_REG:
+                    rvalue_materialize(op1);
+                    OUT("tcg_gen_movcond_i", &bit_width);
+                    OUT("(TCG_COND_LE, ", &res, ", ", op1, ", ", op2);
+                    OUT(", ", op1, ", ", op2, ");\n");
+                    break;
+                case REG_IMM:
+                    rvalue_materialize(op2);
+                    /* Fallthrough */
+                case REG_REG:
+                    OUT("tcg_gen_movcond_i", &bit_width);
+                    OUT("(TCG_COND_LE, ", &res, ", ", op1, ", ", op2);
+                    OUT(", ", op1, ", ", op2, ");\n");
+                    break;
+                default:
+                    fprintf(stderr, "Error in evalutating immediateness!");
+                    abort();
+            }
+            break;
+        }
+        case MAXI:
+        {
+            switch(op_types) {
+                case IMM_IMM:
+                    OUT("int", &bit_width, "_t ", &res, " = (", op1, " <= ");
+                    OUT(op2, ") ? ", op2, " : ", op1, ";\n");
+                    break;
+                case IMM_REG:
+                    rvalue_materialize(op1);
+                    OUT("tcg_gen_movcond_i", &bit_width);
+                    OUT("(TCG_COND_LE, ", &res, ", ", op1, ", ", op2);
+                    OUT(", ", op2, ", ", op1, ");\n");
+                    break;
+                case REG_IMM:
+                    rvalue_materialize(op2);
+                    /* Fallthrough */
+                case REG_REG:
+                    OUT("tcg_gen_movcond_i", &bit_width);
+                    OUT("(TCG_COND_LE, ", &res, ", ", op1, ", ", op2);
+                    OUT(", ", op2, ", ", op1, ");\n");
+                    break;
+                default:
+                    fprintf(stderr, "Error in evalutating immediateness!");
+                    abort();
+            }
+            break;
+        }
+        case MODULO:
+        {
+            switch(op_types) {
+                case IMM_IMM:
+                    OUT("int64_t ", &res, " = ", op1, " % ", op2, ";\n");
+                    break;
+                case IMM_REG:
+                case REG_IMM:
+                case REG_REG:
+                    OUT("gen_helper_mod(", &res, ", ", op1, ", ", op2, ");\n");
+                    break;
+                default:
+                    fprintf(stderr, "Error in evalutating immediateness!");
+                    abort();
+            }
+            break;
+        }
+    }
+    /* Free operands only if they are unnamed */
+    if (!op1->is_symbol)
+        rvalue_free(op1);
+    if (!op2->is_symbol)
+        rvalue_free(op2);
+    if (op_types == IMM_IMM)
+        qemu_tmp_count++;
+    return res;
+
+#undef IMM_IMM
+#undef IMM_REG
+#undef REG_IMM
+#undef REG_REG
+}
+
+t_hex_value gen_bin_cmp(enum cmp_type type,
+                      t_hex_value *op1,
+                      t_hex_value *op2)
+{
+#define IMM_IMM 0
+#define IMM_REG 1
+#define REG_IMM 2
+#define REG_REG 3
+
+    int op_types = (op1->type != IMMEDIATE) << 1 | (op2->type != IMMEDIATE);
+
+    /* Find bit width of the two operands,
+       if at least one is 64 bit use a 64bit operation,
+       eventually extend 32bit operands. */
+    bool op_is64bit = op1->bit_width == 64 || op2->bit_width == 64;
+    char * bit_suffix = op_is64bit ? "i64" : "i32";
+    int bit_width = (op_is64bit) ? 64 : 32;
+    /* TODO: Handle signedness */
+    if (op_is64bit) {
+        switch(op_types) {
+            case IMM_REG:
+                rvalue_extend(op2);
+                break;
+            case REG_IMM:
+                rvalue_extend(op1);
+                break;
+            case REG_REG:
+                rvalue_extend(op1);
+                rvalue_extend(op2);
+                break;
+        }
+    }
+
+    t_hex_value res = gen_tmp(bit_width);
+
+    switch(op_types) {
+        case IMM_IMM:
+        {
+            OUT("tcg_gen_movi_", bit_suffix, "(", &res, ", ", op1, " == ", op2, ");\n");
+            break;
+        }
+        case IMM_REG:
+        {
+            t_hex_value swp = *op2;
+            *op2 = *op1;
+            *op1 = swp;
+            /* Swap comparison direction */
+            type = cmp_swap(type);
+            /* fallthrough */
+        }
+        case REG_IMM:
+        {
+            OUT("tcg_gen_setcondi_", bit_suffix, "(");
+            OUT(&type, ", ", &res, ", ", op1, ", ", op2, ");\n");
+            break;
+        }
+        case REG_REG:
+        {
+            OUT("tcg_gen_setcond_", bit_suffix, "(");
+            OUT(&type, ", ", &res, ", ", op1, ", ", op2, ");\n");
+            break;
+        }
+        default:
+        {
+            fprintf(stderr, "Error in evalutating immediateness!");
+            abort();
+        }
+    }
+    /* Free operands */
+    /* TODO: Try to eliminate double free */
+    rvalue_free(op1);
+    rvalue_free(op2);
+
+    return res;
+
+#undef IMM_IMM
+#undef IMM_REG
+#undef REG_IMM
+#undef REG_REG
+}
+
+t_hex_value gen_extract(t_hex_value *source) {
+    if (!source->is_vectorial) {
+        /* Handle range extraction */
+        if (source->is_range) {
+            int bit_width = (source->bit_width == 64) ? 64 : 32;
+            int begin = source->range.begin;
+            int end = source->range.end;
+            int width = end - begin + 1;
+            t_hex_value res = gen_tmp(bit_width);
+            OUT("tcg_gen_extract_i", &bit_width, "(", &res, ", ", source);
+            OUT(", ", &begin, ", ", &width, ");\n");
+            *source = res;
+            return res;
+        } else {
+            return *source;
+        }
+    }
+    t_hex_vec access = source->vec;
+    int width = access.width;
+    t_hex_value res = gen_tmp(source->bit_width);
+    /* Generating string containing access offset */
+    char offset_string[OFFSET_STR_LEN];
+    int offset_value = access.index * width;
+    snprintf(offset_string, OFFSET_STR_LEN, "%d", offset_value);
+    char * offset = offset_string;
+    /* Parametric half-word access index */
+    if (access.is_zeroone) {
+        if (highlow_count == 0)
+            OUT("int ");
+        OUT("offset = (high_low", &highlow_count);
+        OUT(") ? ", &width, " : 0;\n");
+        offset = "offset";
+        highlow_count++;
+    } else if (access.iter_type != NO_ITER) {
+        /* All iteration types */
+        switch(access.iter_type) {
+            case I_ITER:
+                snprintf(offset, OFFSET_STR_LEN, "i * %d", width);
+                break;
+            case I2_ITER:
+                snprintf(offset, OFFSET_STR_LEN, "i*2 * %d", width);
+                break;
+            case I2PLUS1_ITER:
+                snprintf(offset, OFFSET_STR_LEN, "(i*2+1) * %d", width);
+                break;
+            case IPLUS1_ITER:
+                snprintf(offset, OFFSET_STR_LEN, "(i+1) * %d", width);
+                break;
+            case IPLUS4_ITER:
+                snprintf(offset, OFFSET_STR_LEN, "(i+4) * %d", width);
+                break;
+            default:
+                assert(false && "Unhandled iterator enum type!\n");
+        }
+    }
+    /* Sanity check that offset is positive */
+    assert(offset[0] != '-' && "Offset is negative, fix lexer!\n");
+    if (source->type == REGISTER) {
+        char * increment = "";
+        /* Handle write to 64 bit registers */
+        if (offset_value >= 32) {
+            offset_value -= 32;
+            snprintf(offset_string, OFFSET_STR_LEN, "%d", offset_value);
+            increment = " + 1";
+        }
+        if (source->is_optnew) {
+            OUT("TCGv *reg = (new) ? GPR_new : GPR;\n");
+            OUT("tcg_gen_extract_i32(", &res, ", reg[");
+            OUT(&(source->reg.id), increment);
+            OUT("], ", offset, ", ", &width, ");\n");
+        } else {
+            char * dotnew = (source->is_dotnew) ? "_new" : "";
+            OUT("tcg_gen_extract_i32(", &res, ", GPR", dotnew);
+            OUT("[", &(source->reg.id), increment);
+            OUT("], ", offset, ", ", &width, ");\n");
+        }
+    } else {
+        if (source->bit_width == 64)
+            rvalue_extend(source);
+        rvalue_materialize(source);
+        int bit_width = (source->bit_width == 64) ? 64 : 32;
+        OUT("tcg_gen_extract_i", &bit_width, "(", &res, ", ", source);
+        OUT(", ", offset, ", ", &width, ");\n");
+        rvalue_truncate(&res);
+    }
+    /* Handle vectorial+range extraction */
+    if (source->is_range) {
+        int bit_width = (source->bit_width == 64) ? 64 : 32;
+        int begin = source->range.begin;
+        int end = source->range.end;
+        int width = end - begin + 1;
+        OUT("tcg_gen_extract_i", &bit_width, "(", &res, ", ", &res);
+        OUT(", ", &begin, ", ", &width, ");\n");
+    }
+    rvalue_free(source);
+    /* Apply source properties */
+    res.is_unsigned = source->is_unsigned;
+    return res;
+}
+
+void gen_deposit(t_hex_value *dest,
+                 t_hex_value *value) {
+    t_hex_vec access = dest->vec;
+    int width = access.width;
+    /* Generating string containing access offset */
+    char offset_string[OFFSET_STR_LEN] = { 0 };
+    char increment_string[OFFSET_STR_LEN] = { 0 };
+    char * offset = offset_string;
+    char * increment = increment_string;
+    int offset_value = access.index * width;
+    snprintf(offset_string, OFFSET_STR_LEN, "%d", offset_value);
+    /* Parametric half-word access index */
+    if (access.is_zeroone) {
+        if (highlow_count == 0)
+            OUT("int ");
+        OUT("offset = (high_low", &highlow_count);
+        OUT(") ? ", &width, " : 0;\n");
+        offset = "offset";
+        highlow_count++;
+    } else if (access.iter_type != NO_ITER) {
+        /* All iteration types */
+        switch(access.iter_type) {
+            case I_ITER:
+                offset = "i";
+                break;
+            case I2_ITER:
+                offset = "i*2";
+                break;
+            case I2PLUS1_ITER:
+                offset = "i*2+1";
+                break;
+            case IPLUS1_ITER:
+                offset = "i+1";
+                break;
+            case IPLUS4_ITER:
+                offset = "i+4";
+                break;
+            default:
+                assert(false && "Unhandled iterator enum type!\n");
+        }
+    }
+    if (dest->type == REGISTER) {
+        /* Handle write to 64 bit registers */
+        if (!access.is_zeroone && access.iter_type == NO_ITER && offset_value >= 32) {
+            offset_value -= 32;
+            snprintf(offset_string, OFFSET_STR_LEN, "%d", offset_value);
+            increment = " + 1";
+            reg_set_written(dest, 1);
+        }
+        /* Handle runtime 64bit register selection by i iterator */
+        if (access.iter_type != NO_ITER) {
+            // deposit is broken when saving to 64bit registers
+            // Algorithm is: offset = <iterator> % (32 / width)
+            //            increment = <iterator> / (32 / width)
+            // If width is 32 it is fine, if width is 16 we have to store
+            // split up the deposit
+            snprintf(increment_string, OFFSET_STR_LEN, "+ %s / (32 / %d)", offset, width);
+            snprintf(offset_string, OFFSET_STR_LEN, "(%s %% (32 / %d)) * %d", offset, width, width);
+            offset = offset_string;
+            // Emit conditional regs written
+            OUT("SET_USED_REG(regs, ", &(dest->reg.id), increment, ");\n");
+            rvalue_truncate(value);
+            rvalue_materialize(value);
+            OUT("tcg_gen_deposit_i32(GPR_new[", &(dest->reg.id), increment);
+            OUT("], GPR_new[", &(dest->reg.id), increment, "], ", value);
+            OUT(", ", offset, ", ", &width, ");\n");
+        } else {
+            rvalue_truncate(value);
+            rvalue_materialize(value);
+            OUT("if (GET_USED_REG(regs, ", &(dest->reg.id), increment, "))\n");
+            OUT("tcg_gen_deposit_i32(GPR_new[", &(dest->reg.id), increment);
+            OUT("], GPR_new[", &(dest->reg.id), increment, "], ", value);
+            OUT(", ", offset, ", ", &width, ");\n");
+            OUT("else\n");
+            OUT("tcg_gen_deposit_i32(GPR_new[", &(dest->reg.id), increment);
+            OUT("], GPR[", &(dest->reg.id), increment, "], ", value);
+            OUT(", ", offset, ", ", &width, ");\n");
+        }
+        reg_set_written(dest, 0);
+    } else {
+        if (dest->extra.temp) {
+            if (!is_extra_created[dest->extra.type]) {
+                OUT("TCGv_i", &dest->bit_width, " ", dest,
+                    " = tcg_temp_new_i", &dest->bit_width, "();\n");
+            }
+        }
+        OUT("tcg_gen_deposit_i32(", dest, ", ", dest, ", ");
+        OUT(value, ", ", offset, ", ", &width, ");\n");
+    }
+    rvalue_free(value);
+}
+
+void gen_assign(t_hex_value *dest, t_hex_value *value) {
+    dest->is_symbol = true;
+    value->is_symbol = true;
+
+    int bit_width = dest->bit_width;
+    if (dest->is_vectorial) {
+        gen_deposit(dest, value);
+        return;
+    }
+    if (dest->type == EXTRA) {
+        if (dest->bit_width == 64)
+            rvalue_extend(value);
+        if (dest->extra.temp) {
+            assert(!(dest->extra.type == EA_T && is_extra_created[EA_T]) &&
+                   "EA assigned multiple times!");
+            if (!is_extra_created[dest->extra.type]) {
+                /* EA must be a tmp_local because it might cross a branch */
+                OUT("TCGv_i", &bit_width, " ", dest,
+                    " = tcg_temp_local_new_i", &bit_width, "();\n");
+                is_extra_created[dest->extra.type] = true;
+            }
+        }
+        if (value->type == IMMEDIATE)
+            OUT("tcg_gen_movi_i", &bit_width, "(", dest, ", ", value, ");\n");
+        else
+            OUT("tcg_gen_mov_i", &bit_width, "(", dest, ", ", value, ");\n");
+        rvalue_free(value); /* Free temporary value */
+        return;
+    }
+    if (dest->bit_width == 64) {
+        rvalue_extend(value);
+        rvalue_materialize(value);
+        assert(value->bit_width == 64 &&
+               "Bit width mismatch in assignment!");
+        OUT("tcg_gen_extrl_i64_i32(");
+        t_hex_value reg_new = *dest;
+        if (dest->reg.type != SYSTEM)
+            reg_new.is_dotnew = true;
+        OUT(&reg_new, ", ", value, ");\n", "tcg_gen_extrh_i64_i32(GPR_new[");
+        OUT(&(dest->reg.id), " + 1], ", value, ");\n");
+        reg_set_written(dest, 0);
+        reg_set_written(dest, 1);
+        /* TODO assert that no one is using this value as Nt */
+    } else if (dest->bit_width == 32){
+        if (value->type == IMMEDIATE)
+            OUT("tcg_gen_movi_tl(");
+        else {
+            if (value->bit_width == 64)
+                OUT("tcg_gen_trunc_i64_tl(");
+            else
+                OUT("tcg_gen_mov_tl(");
+        }
+        t_hex_value reg_new = *dest;
+        if (dest->reg.type != SYSTEM)
+            reg_new.is_dotnew = true;
+        OUT(&reg_new, ", ", value, ");\n");
+        if (dest->reg.type == CONTROL)
+            reg_set_written(dest, 32);
+        else if (dest->reg.type == GENERAL_PURPOSE)
+            reg_set_written(dest, 0);
+    } else
+        assert(false && "Unhandled bit width!");
+    rvalue_free(value);
+}
+
+t_hex_value gen_cast_op(t_hex_value *source, unsigned target_width) {
+    // Bit width sanity check
+    //assert((source->bit_width == 32 || source->bit_width == 64) &&
+    //       (target_width == 32 || target_width == 64) &&
+    //       "Unhandled cast operation!");
+    if (source->bit_width == target_width)
+        return *source;
+    else if (source->type == IMMEDIATE) {
+        source->bit_width = target_width;
+        return *source;
+    } else {
+        t_hex_value res = gen_tmp(target_width);
+        // Truncate
+        if (source->bit_width > target_width)
+            OUT("tcg_gen_trunc_i64_tl(", &res, ", ", source, ");\n");
+        // Extend unsigned
+        else if (source->is_unsigned)
+            OUT("tcg_gen_extu_i32_i64(", &res, ", ", source, ");\n");
+        // Extend signed
+        else
+            OUT("tcg_gen_ext_i32_i64(", &res, ", ", source, ");\n");
+        rvalue_free(source);
+        return res;
+    }
+}
+
+t_hex_value gen_convround(t_hex_value *source, t_hex_value *round_bit) {
+    round_bit->is_symbol = true;
+    /* Round bit is given in one hot encoding */
+    /* If input is 64 bit cast it to 32 (used for vavgw) */
+    *source = gen_cast_op(source, 32);
+    source->is_symbol = true;
+    /* Add .5 if > .5 but not if is == .5 and value is even */
+    assert(source->bit_width <= 32 &&
+           "Convround not implemented for bit widths > 32!");
+    t_hex_value zero = gen_tmp_value("0", 32);
+    t_hex_value one = gen_imm_value(1, 32);
+    t_hex_value two = gen_imm_value(2, 32);
+    t_hex_value remainder = gen_bin_op(ANDB, source, round_bit);
+    t_hex_value tmp_mask = gen_bin_op(ASHIFTL, round_bit, &two);
+    t_hex_value mask = gen_bin_op(SUBTRACT, &tmp_mask, &one);
+    t_hex_value masked_value = gen_bin_op(ANDB, source, &mask);
+    rvalue_materialize(&masked_value);
+    rvalue_materialize(round_bit);
+    /* If value is even and == .5 do not round */
+    t_hex_value new_remainder = gen_tmp(32);
+    OUT("tcg_gen_movcond_i32(TCG_COND_EQ, ", &new_remainder);
+    OUT(", ", &masked_value, ", ", round_bit, ", ");
+    OUT(&zero, ", ", &remainder, ");\n");
+    t_hex_value res = gen_bin_op(ADD, source, &new_remainder);
+    /* Zero out trailing bits */
+    mask = gen_bin_op(ASHIFTL, round_bit, &one);
+    mask = gen_bin_op(SUBTRACT, &mask, &one);
+    t_hex_value new_mask = gen_tmp(32);
+    OUT("tcg_gen_not_i32(", &new_mask, ", ", &mask, ");\n");
+    res = gen_bin_op(ANDB, &res, &new_mask);
+    rvalue_free(&remainder);
+    rvalue_free(&masked_value);
+    rvalue_free(&mask);
+    rvalue_free(&zero);
+    rvalue_free(source);
+    rvalue_free(round_bit);
+    return res;
+}
+
+/* Circular buffer operation */
+t_hex_value gen_circ_op(t_hex_value *addr,
+                        t_hex_value *increment,
+                        t_hex_value *slot) {
+    /* Circular addressing mode with auto-increment */
+    /* Extract iteration variables */
+    t_hex_value I = gen_tmp(32);
+    t_hex_value K = gen_tmp(32);
+    t_hex_value Length = gen_tmp(32);
+    t_hex_value tmp = gen_tmp(32);
+    t_hex_value delta = gen_tmp(32);
+    /* Assume that CS0 is populated, since it's required by the ISA reference manual */
+    OUT("tcg_gen_extract_i32(", &I, ", ", slot, ", 17, 7);\n");
+    OUT("tcg_gen_extract_i32(", &K, ", ", slot, ", 24, 3);\n");
+    OUT("tcg_gen_extract_i32(", &Length, ", ", slot, ", 0, 16);\n");
+    OUT("tcg_gen_extract_i32(", &tmp, ", ", slot, ", 28, 4);\n");
+    OUT("tcg_gen_deposit_i32(", &I, ", ", &I, ", ", &tmp);
+    OUT(", 7, 4);\n");
+    /* The increment must become modulo Length */
+    t_hex_value res = gen_bin_op(ADD, addr, increment);
+    OUT("tcg_gen_sub_i32(", &delta, ", ", &res);
+    OUT(", CR[12 + ", &(slot->reg.id), "]);");
+    res = gen_bin_op(MODULO, &delta, &Length);
+    OUT("tcg_gen_add_i32(", &res, ", CR[12 + ", &(slot->reg.id));
+    OUT("], ", &res, ");");
+    return res;
+}
+
+t_hex_value gen_bitcnt_op(t_hex_value *source,
+                          bool negate,
+                          bool reverse)
+{
+    char * bit_suffix = source->bit_width == 64 ? "64" : "32";
+    t_hex_value res = gen_tmp(source->bit_width == 64 ? 64 : 32);
+    res.type = TEMP;
+    /* TODO: use native c primitive if we deal with immediates */
+    rvalue_materialize(source);
+    switch(negate << 1 | reverse) {
+        case 0b00:
+            OUT("tcg_gen_clzi_i", bit_suffix, "(", &res, ", ", source, ", ");
+            OUT(bit_suffix, ");");
+            break;
+        case 0b01:
+            OUT("tcg_gen_ctzi_i", bit_suffix, "(", &res, ", ", source, ", ");
+            OUT(bit_suffix, ");");
+            break;
+        case 0b10:
+            OUT("tcg_gen_not_i", bit_suffix, "(", &res, ", ", source, ");\n");
+            OUT("tcg_gen_clzi_i", bit_suffix, "(", &res, ", ", &res, ", ");
+            OUT(bit_suffix, ");");
+            break;
+        case 0b11:
+            OUT("tcg_gen_not_i", bit_suffix, "(", &res, ", ", source, ");\n");
+            OUT("tcg_gen_clzi_i", bit_suffix, "(", &res, ", ", &res, ", ");
+            OUT(bit_suffix, ");");
+            break;
+    }
+    rvalue_free(source);
+    return res;
+}
+
+/* Keep compiler happy */
+int yylex();
+
+%}
+
+%define parse.error verbose
+%define parse.lac full
+
+%union {
+    t_hex_value rvalue;
+    t_hex_vec vec;
+    t_hex_range range;
+    int index;
+}
+
+
+/* Tokens */
+%start code
+
+%expect 1
+
+%token LBR RBR LPAR RPAR LSQ RSQ LARR
+%token SEMI COLON PLUS MINUS PMINUS MUL POW DIV MOD ABS CROUND ROUND CIRCADD
+%token AND OR ANDOR XOR NOT OPTSHIFT NSHIFT
+%token ASSIGN INC DEC INCDECA ANDA ORA XORA ANDORA PLUSPLUS
+%token LT GT ASL ASR LSR ROL EQ NEQ OPTEQ LTE GTE MIN MAX
+%token ANDL ORL NOTL OPTNOTL
+%token COMMA FOR I ICIRC IF
+%token MAPPED EXT FSCR FCHK TLB IPEND DEBUG MODECTL
+%token SXT ZXT NEW OPTNEW ZEROONE CONSTEXT LOCNT BREV U64
+%token HASH EA PC FP GP NPC LPCFG STAREA WIDTH OFFSET SHAMT ADDR SUMR SUMI CTRL
+%token TMPR TMPI X0 X1 Y0 Y1 PROD0 PROD1 TMP QMARK TRAP0 TRAP1 CAUSE EX INT NOP
+%token DCKILL DCLEAN DCINVA DZEROA DFETCH ICKILL L2KILL ISYNC BRKPT SYNCHT LOCK
+
+%token <index> SA
+%token <index> LC
+%token <rvalue> REG
+%token <rvalue> IMM
+%token <rvalue> PRE
+%token <index> ELSE
+%token <vec> VEC
+%token <range> RANGE
+%type <rvalue> rvalue
+%type <rvalue> lvalue
+%type <rvalue> assign_statement
+%type <rvalue> pre
+%type <rvalue> reg
+%type <rvalue> extra
+%type <index> if_stmt
+%type <index> IF
+
+/* Operator Precedences */
+%right INT
+%left COMMA
+%left ASSIGN
+%right CIRCADD
+%right INC DEC INCDECA ANDA ORA XORA ANDORA
+%left QMARK COLON
+%left ORL
+%left ANDL
+%left OR
+%left XOR ANDOR
+%left AND
+%left EQ NEQ OPTEQ
+%left LT GT LTE GTE
+%left ASL ASR LSR ROL
+%right ABS CROUND
+%left MINUS PLUS PMINUS
+%left POW
+%left MUL DIV MOD
+%right NOT NOTL OPTNOTL
+%left LSQ
+%left NEW OPTNEW ZEROONE
+%left VEC OPTSHIFT NSHIFT
+%right EXT LOCNT BREV
+
+/* Bison Grammar */
+%%
+
+/* Return the modified registers list */
+code  : statements
+      {
+         YYACCEPT;
+      }
+;
+
+/* A list of one or more statements */
+statements  : statements statement       { /* does nothing */ }
+            | statement                  { /* does nothing */ }
+;
+
+code_block : LBR statements RBR          { /* does nothing */ }
+           | statement                   { /* does nothing */ }
+;
+
+/* Statements can be assignment, control or memory statements */
+statement   : control_statement          { /* does nothing */ }
+            | rvalue SEMI                { /* does nothing */ }
+;
+
+/* Add this to the modified registers list */
+assign_statement  : lvalue ASSIGN rvalue
+                  {
+                    gen_assign(&$1, &$3);
+                    $$ = $1;
+                  }
+                  | lvalue INC rvalue
+                  {
+                    t_hex_value reg = reg_concat(&$1);
+                    t_hex_value tmp = gen_bin_op(ADD, &reg, &$3);
+                    gen_assign(&$1, &tmp);
+                    $$ = $1;
+                  }
+                  | lvalue DEC rvalue
+                  {
+                    t_hex_value reg = reg_concat(&$1);
+                    t_hex_value tmp = gen_bin_op(SUBTRACT, &reg, &$3);
+                    gen_assign(&$1, &tmp);
+                    $$ = $1;
+                  }
+                  | lvalue INCDECA rvalue
+                  {
+                    t_hex_value reg = reg_concat(&$1);
+                    t_hex_value tmp = gen_bin_op(ADDSUB, &reg, &$3);
+                    gen_assign(&$1, &tmp);
+                    $$ = $1;
+                  }
+                  | lvalue ANDA rvalue
+                  {
+                    t_hex_value reg = reg_concat(&$1);
+                    t_hex_value tmp = gen_bin_op(ANDB, &reg, &$3);
+                    gen_assign(&$1, &tmp);
+                    $$ = $1;
+                  }
+                  | lvalue ORA rvalue
+                  {
+                    t_hex_value reg = reg_concat(&$1);
+                    t_hex_value tmp = gen_bin_op(ORB, &reg, &$3);
+                    gen_assign(&$1, &tmp);
+                    $$ = $1;
+                  }
+                  | lvalue XORA rvalue
+                  {
+                    t_hex_value reg = reg_concat(&$1);
+                    t_hex_value tmp = gen_bin_op(XORB, &reg, &$3);
+                    gen_assign(&$1, &tmp);
+                    $$ = $1;
+                  }
+                  | lvalue ANDORA rvalue
+                  {
+                    t_hex_value reg = reg_concat(&$1);
+                    t_hex_value tmp = gen_bin_op(ANDORB, &reg, &$3);
+                    gen_assign(&$1, &tmp);
+                    $$ = $1;
+                  }
+                  | pre ASSIGN rvalue
+                  {
+                    assert(!$1.is_optnew && "Cannot assign to .new predicate!");
+                    /* Write to predicate register */
+                    OUT("int pre_index", &predicate_count, " = "); /* Get predicate index */
+                    if ($1.pre.is_zeroone)
+                        OUT("zero_one", &zeroone_count, ";\n");
+                    else
+                        OUT(&($1.pre.id), ";\n");
+                    rvalue_truncate(&$3);
+                    rvalue_materialize(&$3);
+                    if (!no_track_regs) {
+                        OUT("TCGv p_reg", &p_reg_count);
+                        OUT(" = (GET_WRITTEN_ANY_PRE(dc)) ? ");
+                        OUT("CR_new[CR_P] : CR[CR_P];\n");
+                    }
+                    /* Bitwise predicate assignment */
+                    if ($1.pre.is_bit_iter) {
+                         /* Extract lsb */
+                         OUT("tcg_gen_andi_i32(", &$3, ", ", &$3, ", 1);\n");
+                         /* Shift to reach predicate and bit offset */
+                         OUT("tcg_gen_shli_i32(", &$3, ", ", &$3, ", 8 * pre_index",
+                             &predicate_count, " + i);\n");
+                         /* Clear previous predicate value */
+                         t_hex_value mask = gen_tmp(32);
+                         t_hex_value one = gen_tmp_value("1", 32);
+                         OUT("tcg_gen_shli_i32(", &mask);
+                         OUT(", ", &one, ", 8 * pre_index", &predicate_count, " + i);\n");
+                         OUT("tcg_gen_not_i32(", &mask, ", ", &mask, ");\n");
+                         OUT("tcg_gen_and_i32(CR_new[CR_P], p_reg", &p_reg_count, ", ",
+                              &mask, ");\n");
+                         p_reg_count++;
+                         /* Store new predicate value */
+                         if (no_track_regs) {
+                            if ($3.type == IMMEDIATE)
+                                OUT("tcg_gen_ori_i32(CR[CR_P], CR[CR_P], ", &$3, ");\n");
+                            else
+                                OUT("tcg_gen_or_i32(CR[CR_P], CR[CR_P], ", &$3, ");\n");
+                         } else {
+                            if ($3.type == IMMEDIATE)
+                                OUT("tcg_gen_ori_i32(CR_new[CR_P], CR_new[CR_P], ", &$3, ");\n");
+                            else
+                                OUT("tcg_gen_or_i32(CR_new[CR_P], CR_new[CR_P], ", &$3, ");\n");
+                         }
+                    /* Range-based predicate assignment */
+                    } else if ($1.is_range) {
+                        /* (bool) ? 0xff : 0x00 */
+                        t_hex_value tmp = gen_tmp(32);
+                        t_hex_value zero = gen_tmp_value("0x0", 32);
+                        t_hex_value ff = gen_tmp_value("0xff", 32);
+                        OUT("tcg_gen_movcond_i32");
+                        OUT("(TCG_COND_EQ, ", &tmp, ", ", &$3, ", ", &zero);
+                        OUT(", ", &zero, ", ", &ff, ");\n");
+                        /* Deposit into range */
+                        int begin = $1.range.begin;
+                        int end = $1.range.end;
+                        int width = end - begin + 1;
+                        OUT("tcg_gen_deposit_i32(CR_new[CR_P], p_reg");
+                        OUT(&p_reg_count, ", ");
+                        p_reg_count++;
+                        OUT(&tmp, ", 8 * pre_index", &predicate_count, " + ");
+                        OUT(&begin, ", ", &width, ");\n");
+                        rvalue_free(&zero);
+                        rvalue_free(&ff);
+                        rvalue_free(&tmp);
+                    /* Standard bytewise predicate assignment */
+                    } else {
+                         
+                         /* Extract first 8 bits */
+                         OUT("tcg_gen_andi_i32(", &$3, ", ", &$3, ", 0xff);\n");
+                         /* Shift to reach predicate */
+                         OUT("tcg_gen_shli_i32(", &$3, ", ", &$3, ", 8 * pre_index",
+                             &predicate_count, ");\n");
+                        if (!no_track_regs) {
+                            /* If predicate was already assigned just perform
+                               the logical AND between the two assignments */
+                            OUT("if (GET_WRITTEN_PREV_PRE(dc, pre_index0)) {");
+                            /* Filter out other predicate bytes */
+                            OUT("tcg_gen_ori_i32(", &$3, ", ", &$3, ", ");
+                            OUT("pred_whitening[pre_index", &predicate_count, "]);\n");
+                            if ($3.type == IMMEDIATE)
+                                OUT("tcg_gen_andi_i32(CR_new[CR_P], p_reg", &p_reg_count, ", ", &$3, ");\n");
+                            else
+                                OUT("tcg_gen_and_i32(CR_new[CR_P], p_reg", &p_reg_count, ", ", &$3, ");\n");
+                            /* Otherwise replace the old value completely */
+                            OUT("} else {\n");
+                            /* Clear previous predicate value */
+                            OUT("tcg_gen_andi_i32(CR_new[CR_P], p_reg", &p_reg_count, ", "
+                                    "pred_whitening[pre_index", &predicate_count, "]);\n");
+                            p_reg_count++;
+                            /* Store new predicate value */
+                            if ($3.type == IMMEDIATE)
+                                OUT("tcg_gen_ori_i32(CR_new[CR_P], CR_new[CR_P], ", &$3, ");\n");
+                            else
+                                OUT("tcg_gen_or_i32(CR_new[CR_P], CR_new[CR_P], ", &$3, ");\n");
+                                OUT("}\n");
+                        /* endloop0 special handling */
+                        } else {
+                            /* Clear previous predicate value */
+                            OUT("tcg_gen_andi_i32(CR[CR_P], CR[CR_P], "
+                                "pred_whitening[pre_index", &predicate_count, "]);\n");
+                            /* Store new predicate value */
+                            if ($3.type == IMMEDIATE)
+                                OUT("tcg_gen_ori_i32(CR[CR_P], CR[CR_P], ", &$3, ");\n");
+                            else
+                                OUT("tcg_gen_or_i32(CR[CR_P], CR[CR_P], ", &$3, ");\n");
+                        }
+                    }
+                    if (!no_track_regs) {
+                        OUT("SET_USED_REG(regs, CR_P + 32);\n");
+                        OUT("SET_WRITTEN_PRE(dc, pre_index", &predicate_count, ");\n");
+                    }
+                    rvalue_free(&$3);  /* Free temporary value */
+                    predicate_count++;
+                    $$ = $1;
+                  }
+                  | IMM ASSIGN rvalue
+                  {
+                    assert($3.type == IMMEDIATE &&
+                           "Cannot assign non-immediate to immediate!");
+                    assert($1.imm.type == VARIABLE &&
+                           "Cannot assign to non-variable!");
+                    /* Assign to the function argument */
+                    OUT(&$1, " = ", &$3, ";\n");
+                    $$ = $1;
+                  }
+                  | PC ASSIGN rvalue
+                  {
+                    /* Do not assign PC if pc_written is 1 */
+                    t_hex_value one = gen_tmp_value("1", 32);
+                    rvalue_materialize(&$3);
+                    OUT("tcg_gen_movcond_i32(");
+                    OUT("TCG_COND_EQ, CR[CR_PC], PC_written, ", &one, ", CR[CR_PC]");
+                    OUT(", ", &$3, ");\n");
+                    /* Update PC_written */
+                    if (!no_track_regs) {
+                        OUT("SET_USED_REG(regs, CR_PC + 32);\n");
+                    }
+                    OUT("tcg_gen_addi_i32(PC_written, PC_written, 1);\n");
+                    rvalue_free(&$3); /* Free temporary value */
+                  }
+                  | STAREA ASSIGN rvalue /* Store primitive */
+                  {
+                    rvalue_materialize(&$3);
+                    char *size_suffix;
+                    /* Select memop width according to rvalue bit width */
+                    switch(mem_size) {
+                        case MEM_BYTE: size_suffix = "8"; break;
+                        case MEM_HALF: size_suffix = "16"; break;
+                        case MEM_WORD: size_suffix = "32"; break;
+                        case MEM_DOUBLE: size_suffix = "64"; break;
+                        default: assert(false && "Wrong load size!");
+                    }
+                    if (mem_size != MEM_DOUBLE)
+                        rvalue_truncate(&$3);
+                    OUT("tcg_gen_qemu_st", size_suffix);
+                    OUT("(", &$3, ", EA, 0);\n");
+                    rvalue_free(&$3); /* Free temporary value */
+                  }
+                  | CAUSE ASSIGN IMM
+                  {
+                    /* TODO: Sync PC and flags between translator and runtime */
+                  }
+                  | EX ASSIGN IMM
+                  {
+                    /* TODO: Implement exception register */
+                  }
+                  | LOCK ASSIGN IMM
+                  {
+                    /* Do nothing since multithread lock is not implemented */
+                  }
+;
+
+control_statement : frame_check          { /* does nothing */ }
+                  | ckill_statement      { /* does nothing */ }
+                  | tlb_write            { /* does nothing */ }
+                  | clear_interrupts     { /* does nothing */ }
+                  | stop_statement       { /* does nothing */ }
+                  | trap_statement       { /* does nothing */ }
+                  | if_statement         { /* does nothing */ }
+                  | for_statement        { /* does nothing */ }
+                  | ISYNC SEMI           { /* does nothing */ }
+                  | BRKPT SEMI           { /* does nothing */ }
+                  | SYNCHT SEMI          { /* does nothing */ }
+                  | NOP SEMI             { /* does nothing */ }
+                  | SEMI                 { /* does nothing */ }
+;
+
+frame_check       : FCHK LPAR rvalue RPAR SEMI  { /* does nothing */ }
+;
+
+ckill_statement  : DCKILL LPAR RPAR SEMI        { /* does nothing */ }
+                 | ICKILL LPAR RPAR SEMI        { /* does nothing */ }
+                 | L2KILL LPAR RPAR SEMI        { /* does nothing */ }
+                 | DCLEAN LPAR rvalue RPAR SEMI { /* does nothing */ }
+                 | DCINVA LPAR rvalue RPAR SEMI { /* does nothing */ }
+                 | DZEROA LPAR rvalue RPAR SEMI { /* does nothing */ }
+                 | DFETCH LPAR rvalue RPAR SEMI { /* does nothing */ }
+;
+
+tlb_write        : TLB LSQ rvalue RSQ ASSIGN rvalue SEMI
+                 {
+                    /* We are not emulating the TLB, since we are
+                       only performing userspace emulation */
+                 }
+;
+
+clear_interrupts : IPEND ANDA rvalue SEMI { /* does nothing */ }
+;
+
+stop_statement : IF DEBUG MODECTL ASSIGN IMM SEMI { /* does nothing */ }
+;
+
+trap_statement    : TRAP0 SEMI
+                  {
+                    t_hex_value tmp = gen_tmp_value("j", 32);
+                    /* Put next program counter in ELR register */
+                    OUT("tcg_gen_movi_i32(SR[3], dc->pc + 4);\n");
+                    /* Jump to interrupt handler */
+                    t_hex_value handler_pc = gen_tmp(32);
+                    OUT("tcg_gen_addi_i32(", &handler_pc, ", SR[16], 0x1c);\n");
+                    OUT("tcg_gen_mov_i32(CR[CR_PC], ", &handler_pc, ");\n");
+                    OUT("gen_helper_handle_trap(cpu_env, ", &tmp, ");\n");
+                    rvalue_free(&tmp);
+                  }
+                  | TRAP1 SEMI
+                  {
+                    t_hex_value tmp = gen_tmp_value("j", 32);
+                    /* Put next program counter in ELR register */
+                    OUT("tcg_gen_movi_i32(SR[3], dc->pc + 4);\n");
+                    /* Jump to interrupt handler */
+                    t_hex_value handler_pc = gen_tmp(32);
+                    OUT("tcg_gen_addi_i32(", &handler_pc, ", SR[16], 0x20);\n");
+                    OUT("tcg_gen_mov_i32(CR[CR_PC], ", &handler_pc, ");\n");
+                    OUT("gen_helper_handle_trap(cpu_env, ", &tmp, ");\n");
+                    rvalue_free(&tmp);
+                  }
+;
+
+if_statement : if_stmt
+             {
+                /* Fix else label */
+               OUT("gen_set_label(if_label_", &$1, ");\n");
+             }
+             | if_stmt ELSE
+             {
+               /* Generate label to jump if else is not verified */
+               OUT("TCGLabel *if_label_", &if_count, " = gen_new_label();\n");
+               $2 = if_count;
+               if_count++;
+               /* Jump out of the else statement */
+               OUT("tcg_gen_br(if_label_", &$2, ");\n");
+               /* Fix the else label */
+               OUT("gen_set_label(if_label_", &$1, ");\n");
+             }
+             code_block
+             {
+               OUT("gen_set_label(if_label_", &$2, ");\n");
+             }
+;
+
+for_statement : FOR LPAR I ASSIGN IMM SEMI I LT IMM SEMI I PLUSPLUS RPAR
+              {
+                OUT("for(int i = ", &$5, "; i < ", &$9, "; i++) {\n");
+              }
+              code_block
+              {
+                OUT("}\n");
+              }
+;
+
+for_statement : FOR LPAR I ASSIGN IMM SEMI I LT IMM SEMI I INC IMM RPAR
+              {
+                OUT("for(int i = ", &$5, "; i < ", &$9, "; i += ", &$13, ") {\n");
+              }
+              code_block
+              {
+                OUT("}\n");
+              }
+;
+
+if_stmt      : IF
+             {
+               if (!no_track_regs)
+                 OUT("SET_BEGIN_COND();\n");
+               /* Generate an end label, if false branch to that label */
+               OUT("TCGLabel *if_label_", &if_count, " = gen_new_label();\n");
+             }
+             LPAR rvalue RPAR
+             {
+               rvalue_materialize(&$4);
+               char * bit_suffix = ($4.bit_width == 64) ? "i64" : "i32";
+               OUT("tcg_gen_brcondi_", bit_suffix, "(TCG_COND_EQ, ", &$4,
+                   ", 0, if_label_", &if_count, ");\n");
+               rvalue_free(&$4);
+               $1 = if_count;
+               if_count++;
+             }
+             code_block
+             {
+               if (!no_track_regs)
+                 OUT("SET_END_COND();\n");
+               $$ = $1;
+             }
+;
+
+rvalue            : assign_statement            { /* does nothing */ }
+                  | reg
+                  {
+                    $1 = reg_concat(&$1);
+                    $$ = gen_extract(&$1);
+                  }
+                  | IMM
+                  {
+                    $$ = $1;
+                  }
+                  | extra
+                  {
+                    $$ = gen_extract(&$1);
+                  }
+                  | pre
+                  {
+                    assert(!($1.is_dotnew && $1.is_optnew) && ".new cannot be"
+                           "optional and not optional at the same time!");
+                    /* Extract predicate value into a temporary */
+                    OUT("int pre_index", &predicate_count, " = "); /* Get predicate index */
+                    if ($1.pre.is_zeroone) {
+                        OUT("zero_one", &zeroone_count, ";\n");
+                        zeroone_count++;
+                    }
+                    else
+                        OUT(&($1.pre.id), ";\n");
+                    $$ = gen_tmp(32);
+                    if ($1.is_optnew) {
+                        OUT("TCGv p_reg", &p_reg_count);
+                        OUT(" = (new || GET_WRITTEN_PRE(dc, pre_index");
+                        OUT(&predicate_count, ")) ? CR_new[CR_P] : CR[CR_P];\n");
+                        OUT("tcg_gen_mov_i32(", &$$, ", ", "p_reg", &p_reg_count, ");\n");
+                        OUT("if (new)");
+                        OUT("SET_READ_PRE(dc, pre_index", &predicate_count, ");\n");
+                        p_reg_count++;
+                    } else {
+                        char * dotnew = ($1.is_dotnew) ? "_new" : "";
+                        OUT("TCGv p_reg", &p_reg_count);
+                        OUT(" = (GET_WRITTEN_PRE(dc, pre_index");
+                        OUT(&predicate_count, ")) ? ");
+                        OUT("CR_new[CR_P] : CR", dotnew, "[CR_P];\n");
+                        OUT("tcg_gen_mov_i32(", &$$, ", ", "p_reg", &p_reg_count, ");\n");
+                        p_reg_count++;
+                        if ($1.is_dotnew) 
+                            OUT("SET_READ_PRE(dc, pre_index", &predicate_count, ");\n");
+                        
+                    }
+                    /* Shift to select predicate */
+                    OUT("tcg_gen_shri_i32(", &$$, ", ", &$$, ", 8 * pre_index",
+                        &predicate_count, ");\n");
+                    /* Extract first 8 bits */
+                    OUT("tcg_gen_andi_i32(", &$$, ", ", &$$, ", 0xff);\n");
+                    predicate_count++;
+                  }
+                  | PC
+                  {
+                    t_hex_value rvalue;
+                    rvalue.type = IMMEDIATE;
+                    rvalue.imm.type = IMM_PC;
+                    rvalue.is_unsigned = true;
+                    rvalue.is_dotnew = false;
+                    rvalue.is_optnew = false;
+                    rvalue.is_vectorial = false;
+                    rvalue.is_range = false;
+                    rvalue.is_symbol = false;
+                    $$ = rvalue;
+                  }
+                  | NPC
+                  {
+                    /* Extract program counter into a temporary */
+                    $$ = gen_tmp(32);
+                    t_hex_value pc = gen_tmp_value("dc->npc", 32);
+                    OUT("tcg_gen_mov_i32(", &$$, ", ", &pc, ");\n");
+                  }
+                  | CONSTEXT
+                  {
+                    t_hex_value rvalue;
+                    rvalue.type = IMMEDIATE;
+                    rvalue.imm.type = IMM_CONSTEXT;
+                    rvalue.is_unsigned = true;
+                    rvalue.is_dotnew = false;
+                    rvalue.is_optnew = false;
+                    rvalue.is_vectorial = false;
+                    rvalue.is_range = false;
+                    rvalue.is_symbol = false;
+                    $$ = rvalue;
+                  }
+                  | rvalue PLUS rvalue
+                  {
+                    $$ = gen_bin_op(ADD, &$1, &$3);
+                  }
+                  | rvalue MINUS rvalue
+                  {
+                    $$ = gen_bin_op(SUBTRACT, &$1, &$3);
+                  }
+                  | rvalue PMINUS rvalue
+                  {
+                    $$ = gen_bin_op(ADDSUB, &$1, &$3);
+                  }
+                  | rvalue MUL rvalue
+                  {
+                    $$ = gen_bin_op(MULTIPLY, &$1, &$3);
+                  }
+                  | rvalue POW rvalue
+                  {
+                    /* We assume that this is a shorthand for a shift */
+                    assert($1.type == IMMEDIATE && $1.imm.value == 2 &&
+                           "Exponentiation is not a left shift!\n");
+                    t_hex_value one = gen_imm_value(1, 32);
+                    t_hex_value shift = gen_bin_op(SUBTRACT, &$3, &one);
+                    $$ = gen_bin_op(ASHIFTL, &$1, &shift);
+                    rvalue_free(&one);
+                    rvalue_free(&shift);
+                  }
+                  | rvalue DIV rvalue
+                  {
+                    $$ = gen_bin_op(DIVIDE, &$1, &$3);
+                  }
+                  | rvalue MOD rvalue
+                  {
+                    $$ = gen_bin_op(MODULO, &$1, &$3);
+                  }
+                  | rvalue ASL rvalue
+                  {
+                    $$ = gen_bin_op(ASHIFTL, &$1, &$3);
+                  }
+                  | rvalue ASR rvalue
+                  {
+                    $$ = gen_bin_op(ASHIFTR, &$1, &$3);
+                  }
+                  | rvalue LSR rvalue
+                  {
+                    $$ = gen_bin_op(LSHIFTR, &$1, &$3);
+                  }
+                  | rvalue ROL rvalue
+                  {
+                    $$ = gen_bin_op(ROTATE, &$1, &$3);
+                  }
+                  | rvalue AND rvalue
+                  {
+                    $$ = gen_bin_op(ANDB, &$1, &$3);
+                  }
+                  | rvalue OR rvalue
+                  {
+                    $$ = gen_bin_op(ORB, &$1, &$3);
+                  }
+                  | rvalue ANDOR rvalue
+                  {
+                    $$ = gen_bin_op(ANDORB, &$1, &$3);
+                  }
+                  | rvalue XOR rvalue
+                  {
+                    $$ = gen_bin_op(XORB, &$1, &$3);
+                  }
+                  | MIN LPAR rvalue COMMA rvalue RPAR
+                  {
+                    $$ = gen_bin_op(MINI, &$3, &$5);
+                  }
+                  | MAX LPAR rvalue COMMA rvalue RPAR
+                  {
+                    $$ = gen_bin_op(MAXI, &$3, &$5);
+                  }
+                  | NOT rvalue
+                  {
+                    char * bit_suffix = ($2.bit_width == 64) ? "i64" : "i32";
+                    int bit_width = ($2.bit_width == 64) ? 64 : 32;
+                    t_hex_value res;
+                    res.is_unsigned = $2.is_unsigned;
+                    res.is_dotnew = false;
+                    res.is_optnew = false;
+                    res.is_vectorial = false;
+                    res.is_range = false;
+                    res.is_symbol = false;
+                    if ($2.type == IMMEDIATE) {
+                        res.type = IMMEDIATE;
+                        res.imm.type = QEMU_TMP;
+                        res.imm.index = qemu_tmp_count;
+                        OUT("int", &bit_width, "_t ", &res, " = ~", &$2, ";\n");
+                        qemu_tmp_count++;
+                    } else {
+                        res = gen_tmp(bit_width);
+                        OUT("tcg_gen_not_", bit_suffix, "(", &res,
+                            ", ", &$2, ");\n");
+                        rvalue_free(&$2);
+                    }
+                    $$ = res;
+                  }
+                  | NOTL rvalue
+                  {
+                    char * bit_suffix = ($2.bit_width == 64) ? "i64" : "i32";
+                    int bit_width = ($2.bit_width == 64) ? 64 : 32;
+                    t_hex_value res;
+                    res.is_unsigned = $2.is_unsigned;
+                    res.is_dotnew = false;
+                    res.is_optnew = false;
+                    res.is_vectorial = false;
+                    res.is_range = false;
+                    res.is_symbol = false;
+                    if ($2.type == IMMEDIATE) {
+                        res.type = IMMEDIATE;
+                        res.imm.type = QEMU_TMP;
+                        res.imm.index = qemu_tmp_count;
+                        OUT("int", &bit_width, "_t ", &res, " = !", &$2, ";\n");
+                        qemu_tmp_count++;
+                        $$ = res;
+                    } else {
+                        res = gen_tmp(bit_width);
+                        t_hex_value zero = gen_tmp_value("0", bit_width);
+                        t_hex_value one = gen_tmp_value("0xff", bit_width);
+                        OUT("tcg_gen_movcond_", bit_suffix);
+                        OUT("(TCG_COND_EQ, ", &$$, ", ", &$2, ", ", &zero);
+                        OUT(", ", &one, ", ", &zero, ");\n");
+                        rvalue_free(&$2);
+                        rvalue_free(&zero);
+                        rvalue_free(&one);
+                        $$ = res;
+                    }
+                  }
+                  | OPTNOTL rvalue
+                  {
+                    char * bit_suffix = ($2.bit_width == 64) ? "i64" : "i32";
+                    OUT("if (not", &not_count, ") {\n");
+                    t_hex_value zero = gen_tmp_value("0", 32);
+                    t_hex_value one = gen_tmp_value("0xff", 32);
+                    OUT("tcg_gen_movcond_", bit_suffix);
+                    OUT("(TCG_COND_EQ, ", &$2, ", ", &$2, ", ", &zero);
+                    OUT(", ", &one, ", ", &zero, ");\n");
+                    rvalue_free(&zero);
+                    rvalue_free(&one);
+                    OUT("}\n");
+                    not_count++;
+                    $$ = $2;
+                  }
+                  | VEC rvalue
+                  {
+                    $2.vec = $1;
+                    $$ = $2;
+                  }
+                  | LPAR rvalue RPAR VEC
+                  {
+                    $2.vec = $4;
+                    $$ = $2;
+                  }
+                  | rvalue LSQ rvalue RSQ
+                  {
+                    t_hex_value one = gen_imm_value(1, $3.bit_width);
+                    t_hex_value tmp = gen_bin_op(ASHIFTR, &$1, &$3);
+                    $$ = gen_bin_op(ANDB, &tmp, &one);
+                  }
+                  | rvalue EQ rvalue
+                  {
+                    $$ = gen_bin_cmp(EQ_OP, &$1, &$3);
+                  }
+                  | rvalue NEQ rvalue
+                  {
+                    $$ = gen_bin_cmp(NEQ_OP, &$1, &$3);
+                  }
+                  | rvalue OPTEQ rvalue
+                  {
+                    $$ = gen_bin_cmp(OPTEQ_OP, &$1, &$3);
+                  }
+                  | rvalue LT rvalue
+                  {
+                    if ($1.is_unsigned && $3.is_unsigned)
+                        $$ = gen_bin_cmp(LTU_OP, &$1, &$3);
+                    else if (!$1.is_unsigned && !$3.is_unsigned)
+                        $$ = gen_bin_cmp(LT_OP, &$1, &$3);
+                    else {
+                        if (mem_unsigned)
+                            $$ = gen_bin_cmp(LTU_OP, &$1, &$3);
+                        else
+                            $$ = gen_bin_cmp(LT_OP, &$1, &$3);
+                    }
+                  }
+                  | rvalue GT rvalue
+                  {
+                    if ($1.is_unsigned && $3.is_unsigned)
+                        $$ = gen_bin_cmp(GTU_OP, &$1, &$3);
+                    else if (!$1.is_unsigned && !$3.is_unsigned)
+                        $$ = gen_bin_cmp(GT_OP, &$1, &$3);
+                    else {
+                        if (mem_unsigned)
+                            $$ = gen_bin_cmp(GTU_OP, &$1, &$3);
+                        else
+                            $$ = gen_bin_cmp(GT_OP, &$1, &$3);
+                    }
+                  }
+                  | rvalue LTE rvalue
+                  {
+                    if ($1.is_unsigned && $3.is_unsigned)
+                        $$ = gen_bin_cmp(LEU_OP, &$1, &$3);
+                    else if (!$1.is_unsigned && !$3.is_unsigned)
+                        $$ = gen_bin_cmp(LTE_OP, &$1, &$3);
+                    else {
+                        if (mem_unsigned)
+                            $$ = gen_bin_cmp(LEU_OP, &$1, &$3);
+                        else
+                            $$ = gen_bin_cmp(LTE_OP, &$1, &$3);
+                    }
+                  }
+                  | rvalue GTE rvalue
+                  {
+                    if ($1.is_unsigned && $3.is_unsigned)
+                        $$ = gen_bin_cmp(GEU_OP, &$1, &$3);
+                    else if (!$1.is_unsigned && !$3.is_unsigned)
+                        $$ = gen_bin_cmp(GTE_OP, &$1, &$3);
+                    else {
+                        if (mem_unsigned)
+                            $$ = gen_bin_cmp(GEU_OP, &$1, &$3);
+                        else
+                            $$ = gen_bin_cmp(GTE_OP, &$1, &$3);
+                    }
+                  }
+                  | rvalue QMARK rvalue COLON rvalue
+                  {
+                    bool is_64bit = ($3.bit_width == 64) || ($5.bit_width == 64);
+                    int bit_width = (is_64bit) ? 64 : 32;
+                    if (is_64bit) {
+                        rvalue_extend(&$1);
+                        rvalue_extend(&$3);
+                        rvalue_extend(&$5);
+                    } else {
+                        rvalue_truncate(&$1);
+                    }
+                    rvalue_materialize(&$1);
+                    rvalue_materialize(&$3);
+                    rvalue_materialize(&$5);
+                    t_hex_value res = gen_local_tmp(bit_width);
+                    t_hex_value zero = gen_tmp_value("0", bit_width);
+                    OUT("tcg_gen_movcond_i", &bit_width);
+                    OUT("(TCG_COND_NE, ", &res, ", ", &$1, ", ", &zero);
+                    OUT(", ", &$3, ", ", &$5, ");\n");
+                    rvalue_free(&zero);
+                    rvalue_free(&$1);
+                    rvalue_free(&$3);
+                    rvalue_free(&$5);
+                    $$ = res;
+                  }
+                  | FSCR LPAR rvalue RPAR
+                  {
+                    t_hex_value key = gen_tmp(64);
+                    t_hex_value res = gen_tmp(64);
+                    rvalue_extend(&$3);
+                    OUT("tcg_gen_concat_i32_i64(", &key,", CR[17], CR[17]);\n");
+                    OUT("tcg_gen_xor_i64(", &res, ", ", &$3,", ", &key, ");\n");
+                    $$ = res;
+                  }
+                  | SXT IMM LARR IMM LPAR rvalue RPAR
+                  {
+                    /* Handle weird destination widths */
+                    if ($4.imm.value > 32)
+                        $4.imm.value = 64;
+                    /* 32 bit constants are already sign extended */
+                    if ($4.imm.value == 32)
+                        $$ = $6;
+                    else if ($4.imm.value == 64) {
+                        $6.is_unsigned = false;
+                        rvalue_extend(&$6);
+                    } else
+                        assert(false && "Unhandled destination bit width!");
+                    $$ = $6;
+                  }
+                  | ZXT rvalue LARR IMM LPAR rvalue RPAR
+                  {
+                    /* Handle weird destination widths */
+                    if ($4.imm.value > 32)
+                        $4.imm.value = 64;
+                    t_hex_value tmp = $6;
+                    if ($2.type != IMMEDIATE || $2.imm.value != $6.bit_width) {
+                        // Cast $2 bit width to $6 bit width
+                        $2 = gen_cast_op(&$2, $6.bit_width);
+                        rvalue_materialize(&$2);
+                        /* First zero-out unwanted bits */
+                        t_hex_value reg = reg_concat(&$6);
+                        t_hex_value one = gen_imm_value(1, $6.bit_width);
+                        t_hex_value tmp_mask = gen_bin_op(ASHIFTL, &one, &$2);
+                        one = gen_imm_value(1, $6.bit_width);
+                        t_hex_value mask = gen_bin_op(SUBTRACT, &tmp_mask, &one);
+                        tmp = gen_bin_op(ANDB, &reg, &mask);
+                    }
+                    /* 32 bit constants are already zero extended */
+                    if ($4.imm.value == 32)
+                        $$ = tmp;
+                    else if ($4.imm.value == 64) {
+                        tmp.is_unsigned = true;
+                        rvalue_extend(&tmp);
+                    } else
+                        assert(false && "Unhandled destination bit width!");
+                    $$ = tmp;
+                  }
+                  | EXT LPAR IMM RPAR
+                  {
+                    $$ = $3;
+                  }
+                  | INT rvalue
+                  {
+                    $$ = $2;
+                  }
+                  | STAREA /* Load primitive */
+                  {
+                    int bit_width = (mem_size == MEM_DOUBLE) ? 64 : 32;
+                    char *sign_suffix = "", *size_suffix;
+                    if (mem_size != MEM_DOUBLE)
+                        sign_suffix = mem_unsigned ? "u" : "s";
+                    t_hex_value tmp = gen_tmp(bit_width);
+                    /* Select memop width according to rvalue bit width */
+                    switch(mem_size) {
+                        case MEM_BYTE: size_suffix = "8"; break;
+                        case MEM_HALF: size_suffix = "16"; break;
+                        case MEM_WORD: size_suffix = "32"; break;
+                        case MEM_DOUBLE: size_suffix = "64"; break;
+                        default: assert(false && "Wrong load size!");
+                    }
+                    OUT("tcg_gen_qemu_ld", size_suffix, sign_suffix);
+                    /* If signed perform 32 or 64 bit sign extension */
+                    OUT("(", &tmp, ", EA, 0);\n");
+                    $$ = tmp;
+                  }
+                  | LPAR rvalue RPAR
+                  {
+                    $$ = $2;
+                  }
+                  | ABS rvalue
+                  {
+                    char * bit_suffix = ($2.bit_width == 64) ? "i64" : "i32";
+                    int bit_width = ($2.bit_width == 64) ? 64 : 32;
+                    t_hex_value res;
+                    res.is_unsigned = $2.is_unsigned;
+                    res.is_dotnew = false;
+                    res.is_optnew = false;
+                    res.is_vectorial = false;
+                    res.is_range = false;
+                    res.is_symbol = false;
+                    if ($2.type == IMMEDIATE) {
+                        res.type = IMMEDIATE;
+                        res.imm.type = QEMU_TMP;
+                        res.imm.index = qemu_tmp_count;
+                        OUT("int", &bit_width, "_t ", &res, " = abs(", &$2, ");\n");
+                        qemu_tmp_count++;
+                        $$ = res;
+                    } else {
+                        res = gen_tmp(bit_width);
+                        t_hex_value zero = gen_tmp_value("0", bit_width);
+                        OUT("tcg_gen_neg_", bit_suffix, "(", &res, ", ",
+                            &$2, ");\n");
+                        OUT("tcg_gen_movcond_i", &bit_width);
+                        OUT("(TCG_COND_GT, ", &res, ", ", &$2, ", ", &zero);
+                        OUT(", ", &$2, ", ", &res, ");\n");
+                        rvalue_free(&$2);
+                        $$ = res;
+                    }
+                  }
+                  | CROUND LPAR rvalue COMMA rvalue RPAR
+                  {
+                    $$ = gen_convround(&$3, &$5);
+                  }
+                  | CROUND LPAR rvalue RPAR
+                  {
+                    /* When is not specified assume mask = 1 */
+                    t_hex_value one = gen_imm_value(1, 32);
+                    $$ = gen_convround(&$3, &one);
+                  }
+                  | ROUND LPAR rvalue COMMA rvalue RPAR
+                  {
+                    /* Add .5 only if .5 bit is set */
+                    assert($3.bit_width <= 32 &&
+                           "Convround not implemented for bit widths > 32!");
+                    t_hex_value one = gen_imm_value(1, 32);
+                    t_hex_value remainder = gen_bin_op(ANDB, &$3, &$5);
+                    t_hex_value res = gen_bin_op(ADD, &$3, &remainder);
+                    /* Zero out trailing bits */
+                    t_hex_value mask = gen_bin_op(ASHIFTL, &$5, &one);
+                    mask = gen_bin_op(SUBTRACT, &mask, &one);
+                    rvalue_materialize(&mask);
+                    OUT("tcg_gen_not_i32(", &mask, ", ", &mask, ");\n");
+                    res = gen_bin_op(ANDB, &res, &mask);
+                    rvalue_free(&$3);
+                    rvalue_free(&$5);
+                    $$ = res;
+                  }
+                  | MINUS rvalue
+                  {
+                    char * bit_suffix = ($2.bit_width == 64) ? "i64" : "i32";
+                    int bit_width = ($2.bit_width == 64) ? 64 : 32;
+                    t_hex_value res;
+                    res.is_unsigned = $2.is_unsigned;
+                    res.is_dotnew = false;
+                    res.is_optnew = false;
+                    res.is_vectorial = false;
+                    res.is_range = false;
+                    res.is_symbol = false;
+                    if ($2.type == IMMEDIATE) {
+                        res.type = IMMEDIATE;
+                        res.imm.type = QEMU_TMP;
+                        res.imm.index = qemu_tmp_count;
+                        OUT("int", &bit_width, "_t ", &res, " = -", &$2, ";\n");
+                        qemu_tmp_count++;
+                        $$ = res;
+                    } else {
+                        res = gen_tmp(bit_width);
+                        OUT("tcg_gen_neg_", bit_suffix, "(", &res, ", ",
+                            &$2, ");\n");
+                        rvalue_free(&$2);
+                        $$ = res;
+                    }
+                  }
+                  | rvalue OPTSHIFT
+                  {
+                    char * bit_suffix = ($1.bit_width == 64) ? "i64" : "i32";
+                    OUT("if (opt_shift) {\n");
+                    OUT("tcg_gen_shli_", bit_suffix, "(", &$1, ", ", &$1, ", 1);\n");
+                    OUT("}\n");
+                  }
+                  | rvalue NSHIFT
+                  {
+                    t_hex_value N = gen_tmp_value("N", 32);
+                    $$ = gen_bin_op(ASHIFTL, &$1, &N);
+                  }
+                  | CIRCADD LPAR rvalue COMMA rvalue COMMA rvalue RPAR
+                  {
+                    $$ = gen_circ_op(&$3, &$5, &$7);
+                  }
+                  | CIRCADD LPAR rvalue COMMA ICIRC ASL IMM COMMA rvalue RPAR
+                  {
+                    t_hex_value I = gen_tmp(32);
+                    OUT("tcg_gen_extract_i32(", &I, ", ", &$9, ", 17, 7);\n");
+                    I = gen_bin_op(ASHIFTL, &I, &$7);
+                    $$ = gen_circ_op(&$3, &I, &$9);
+                  }
+                  | LOCNT LPAR rvalue RPAR
+                  {
+                    /* Leading ones count */
+                    $$ = gen_bitcnt_op(&$3, true, false);
+                  }
+                  | LOCNT LPAR BREV LPAR rvalue RPAR RPAR
+                  {
+                    /* Trailing ones count */
+                    $$ = gen_bitcnt_op(&$5, true, true);
+                  }
+                  | LOCNT LPAR NOT BREV LPAR rvalue RPAR RPAR
+                  {
+                    /* Trailing zeroes count */
+                    $$ = gen_bitcnt_op(&$6, false, true);
+                  }
+                  | LOCK
+                  {
+                    $$ = gen_tmp_value("true", 32);
+                  }
+;
+
+pre               : PRE
+                  {
+                    $$ = $1;
+                  }
+                  | pre ZEROONE
+                  {
+                    $$ = $1;
+                    $$.pre.is_zeroone = true;
+                  }
+                  | pre NEW
+                  {
+                    $$ = $1;
+                    $$.is_dotnew = true;
+                  }
+                  | pre OPTNEW
+                  {
+                    $$ = $1;
+                    $$.is_optnew = true;
+                  }
+                  | pre VEC
+                  {
+                    assert($2.width == 1 && "Not-bitwise access to predicate!");
+                    $$ = $1;
+                    $$.pre.is_bit_iter = true;
+                  }
+                  | pre RANGE
+                  {
+                    $$ = $1;
+                    $$.range = $2;
+                    $$.is_range = true;
+                  }
+;
+
+lvalue            : reg       { /* does nothing */ }
+                  | extra     { /* does nothing */ }
+;
+
+reg               : REG
+                  {
+                    $$ = $1;
+                  }
+                  | reg NEW
+                  {
+                    $$ = $1;
+                    $$.is_dotnew = true;
+                  }
+                  | reg OPTNEW
+                  {
+                    $$ = $1;
+                    $$.is_optnew = true;
+                  }
+                  | reg VEC
+                  {
+                    $$ = $1;
+                    $$.vec = $2;
+                    $$.is_vectorial = true;
+                    $$.is_unsigned = $2.is_unsigned;
+                  }
+                  | reg RANGE
+                  {
+                    $$ = $1;
+                    $$.range = $2;
+                    $$.is_range = true;
+                  }
+                  | reg U64
+                  {
+                    $$ = $1;
+                    $$.is_unsigned = true;
+                  }
+;
+
+extra             : LPCFG
+                  {
+                    $$ = gen_extra(LPCFG_T, 0, false);
+                  }
+                  | LC
+                  {
+                    $$ = gen_extra(LC_T, $1, false);
+                  }
+                  | SA
+                  {
+                    $$ = gen_extra(SA_T, $1, false);
+                  }
+                  | EA
+                  {
+                    $$ = gen_extra(EA_T, 0, true);
+                  }
+                  | WIDTH
+                  {
+                    $$ = gen_extra(WIDTH_T, 0, true);
+                  }
+                  | OFFSET
+                  {
+                    $$ = gen_extra(OFFSET_T, 0, true);
+                  }
+                  | SHAMT
+                  {
+                    $$ = gen_extra(SHAMT_T, 0, true);
+                  }
+                  | ADDR
+                  {
+                    $$ = gen_extra(ADDR_T, 0, true);
+                  }
+                  | SUMR
+                  {
+                    $$ = gen_extra(SUMR_T, 0, true);
+                  }
+                  | SUMI
+                  {
+                    $$ = gen_extra(SUMI_T, 0, true);
+                  }
+                  | CTRL
+                  {
+                    $$ = gen_extra(CTRL_T, 0, true);
+                  }
+                  | TMPR
+                  {
+                    $$ = gen_extra(TMPR_T, 0, true);
+                  }
+                  | TMPI
+                  {
+                    $$ = gen_extra(TMPI_T, 0, true);
+                  }
+                  | X0
+                  {
+                    $$ = gen_extra(X0_T, 0, true);
+                  }
+                  | X1
+                  {
+                    $$ = gen_extra(X1_T, 0, true);
+                  }
+                  | Y0
+                  {
+                    $$ = gen_extra(Y0_T, 0, true);
+                  }
+                  | Y1
+                  {
+                    $$ = gen_extra(Y1_T, 0, true);
+                  }
+                  | PROD0
+                  {
+                    $$ = gen_extra(PROD0_T, 0, true);
+                  }
+                  | PROD1
+                  {
+                    $$ = gen_extra(PROD1_T, 0, true);
+                  }
+                  | MAX
+                  {
+                    $$ = gen_extra(MAX_T, 0, true);
+                  }
+                  | MIN
+                  {
+                    $$ = gen_extra(MIN_T, 0, true);
+                  }
+                  | TMP
+                  {
+                    $$ = gen_extra(TMP_T, 0, true);
+                  }
+                  | extra VEC
+                  {
+                    $$ = $1;
+                    $$.vec = $2;
+                    $$.is_vectorial = true;
+                    $$.is_unsigned = $2.is_unsigned;
+                  }
+                  | I
+                  {
+                    $$ = gen_tmp_value("i", 32);
+                  }
+;
+
+%%
+
+int main(int argc, char **argv)
+{
+    
+    /* Argument parsing */
+    int opt;
+    while ((opt = getopt(argc, argv, "jstulbhwd")) != -1) {
+        switch (opt) {
+        case 'j': is_jump = true; break;
+        case 's': is_stop = true; break;
+        case 't': no_track_regs = true; break;
+        case 'u': mem_unsigned = true; break;
+        case 'b': mem_size = MEM_BYTE; break;
+        case 'h': mem_size = MEM_HALF; break;
+        case 'w': mem_size = MEM_WORD; break;
+        case 'd': mem_size = MEM_DOUBLE; break;
+        default:
+            fprintf(stderr, "Usage: %s [-nbhwd]\n", argv[0]);
+            exit(EXIT_FAILURE);
+        }
+    }
+
+    /* Emit fake jump dependency */
+    if (is_jump)
+        OUT("SET_JUMP_FLAG(dc);\n");
+
+    /* Emit stop instruction */
+    if (is_stop) {
+        OUT("tcg_gen_movi_i32(GPR[0], 24);\n");
+        t_hex_value tmp = gen_tmp_value("0", 32);
+        OUT("gen_helper_handle_trap(cpu_env, ", &tmp, ");\n");
+    }
+
+    /* Start the parsing procedure */
+    yyparse();
+
+    if (error_count != 0) {
+        printf("Parsing generated %d errors!\n", error_count);
+        return 1;
+    }
+    return 0;
+}
diff --git a/target/hexagon/generator/semantics/semantics_struct.h b/target/hexagon/generator/semantics/semantics_struct.h
new file mode 100644
index 0000000000..1748fc5690
--- /dev/null
+++ b/target/hexagon/generator/semantics/semantics_struct.h
@@ -0,0 +1,118 @@
+/*
+ * Semantics struct header
+ *
+ * Copyright (c) 2017-2019 Comsecuris UG (haftungsbeschraenkt)
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef SEMANTICS_STRUCT_H
+#define SEMANTICS_STRUCT_H
+
+enum reg_type {GENERAL_PURPOSE, CONTROL, SYSTEM};
+
+/* Semantic Records */
+typedef struct t_hex_reg
+{
+    char id;
+    bool is_const;
+    enum reg_type type;
+    int offset;
+} t_hex_reg;
+
+typedef struct t_hex_tmp
+{
+    int index;
+} t_hex_tmp;
+
+enum imm_union_tag {VARIABLE, VALUE, QEMU_TMP, IMM_PC, IMM_CONSTEXT};
+
+typedef struct t_hex_imm
+{
+    union {
+        char id;
+        uint64_t value;
+        uint64_t index;
+    };
+    enum imm_union_tag type;
+} t_hex_imm;
+
+typedef struct t_hex_pre
+{
+    char id;
+    bool is_zeroone;
+    bool is_bit_iter;
+} t_hex_pre;
+
+enum rvalue_extra_type {EA_T, LPCFG_T, LC_T, SA_T, WIDTH_T, OFFSET_T,
+                        SHAMT_T, ADDR_T, SUMR_T, SUMI_T, CTRL_T, TMPR_T,
+                        TMPI_T, X0_T, X1_T, Y0_T, Y1_T, PROD0_T, PROD1_T,
+                        MAX_T, MIN_T, TMP_T};
+
+typedef struct t_hex_extra
+{
+    int index;
+    enum rvalue_extra_type type;
+    bool temp;
+} t_hex_extra;
+
+enum iterable_type {NO_ITER, I_ITER, I2_ITER, IPLUS1_ITER, IPLUS4_ITER,
+                    I2PLUS1_ITER};
+
+typedef struct t_hex_vec
+{
+    int index;
+    int width;
+    bool is_unsigned;
+    bool is_zeroone;
+    enum iterable_type iter_type;
+} t_hex_vec;
+
+typedef struct t_hex_range
+{
+    int begin;
+    int end;
+} t_hex_range;
+
+enum rvalue_union_tag {REGISTER, TEMP, IMMEDIATE, PREDICATE, EXTRA};
+
+typedef struct t_hex_value
+{
+    union {
+        t_hex_reg reg;
+        t_hex_tmp tmp;
+        t_hex_imm imm;
+        t_hex_pre pre;
+        t_hex_extra extra;
+    };
+    enum rvalue_union_tag type;
+    unsigned bit_width;
+    bool is_unsigned;
+    bool is_dotnew;
+    bool is_optnew;
+    bool is_vectorial;
+    bool is_range;
+    bool is_symbol;
+    t_hex_vec vec;
+    t_hex_range range;
+} t_hex_value;
+
+#endif /* SEMANTICS_STRUCT_H */
diff --git a/target/hexagon/generator/sub-instructions.csv b/target/hexagon/generator/sub-instructions.csv
new file mode 100644
index 0000000000..c872616d7d
--- /dev/null
+++ b/target/hexagon/generator/sub-instructions.csv
@@ -0,0 +1,47 @@
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,0,0,0,0,j,j,j,j,s,s,s,s,d,d,d,d,Rd = memw(Rs+#u4:2)
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,0,0,0,1,j,j,j,j,s,s,s,s,d,d,d,d,Rd = memub(Rs+#u4:0)
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,0,0,1,0,0,j,j,j,s,s,s,s,d,d,d,d,Rd = memh(Rs+#u3:1)
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,0,0,1,0,1,j,j,j,s,s,s,s,d,d,d,d,Rd = memuh(Rs+#u3:1)
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,0,0,1,1,0,j,j,j,s,s,s,s,d,d,d,d,Rd = memb(Rs+#u3:0)
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,0,0,1,1,1,1,0,j,j,j,j,j,d,d,d,d,Rd = memw(r29+#u5:2)
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,0,0,1,1,1,1,1,0,j,j,j,j,j,d,d,d,Rdd = memd(r29+#u5:3)
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,0,0,1,1,1,1,1,1,0,0,-,-,-,0,-,-,deallocframe
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,0,0,1,1,1,1,1,1,0,1,-,-,-,0,-,-,dealloc_return
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,0,0,1,1,1,1,1,1,0,1,-,-,-,1,0,0,if (P0) dealloc_return
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,0,0,1,1,1,1,1,1,0,1,-,-,-,1,0,1,if (!P0) dealloc_return
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,0,0,1,1,1,1,1,1,0,1,-,-,-,1,1,0,if (P0.new) dealloc_return:nt
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,0,0,1,1,1,1,1,1,0,1,-,-,-,1,1,1,if (!P0.new) dealloc_return:nt
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,0,0,1,1,1,1,1,1,1,1,-,-,-,0,-,-,jumpr R31
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,0,0,1,1,1,1,1,1,1,1,-,-,-,1,0,0,if (P0) jumpr R31
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,0,0,1,1,1,1,1,1,1,1,-,-,-,1,0,1,if (!P0) jumpr R31
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,0,0,1,1,1,1,1,1,1,1,-,-,-,1,1,0,if (P0.new) jumpr:nt R31
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,0,0,1,1,1,1,1,1,1,1,-,-,-,1,1,1,if (!P0.new) jumpr:nt R31
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,0,1,0,0,j,j,j,j,s,s,s,s,t,t,t,t,memw(Rs+#u4:2) = Rt
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,0,1,0,1,j,j,j,j,s,s,s,s,t,t,t,t,memb(Rs+#u4:0) = Rt
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,0,1,1,0,0,j,j,j,s,s,s,s,t,t,t,t,memh(Rs+#u3:1) = Rt
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,0,1,1,0,1,0,0,j,j,j,j,j,t,t,t,t,memw(r29+#u5:2) = Rt
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,0,1,1,0,1,0,1,j,j,j,j,j,j,t,t,t,memd(r29+#s6:3) = Rtt
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,0,1,1,1,0,0,0,I,s,s,s,s,j,j,j,j,memw(Rs+#u4:2) = #U1
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,0,1,1,1,0,0,1,I,s,s,s,s,j,j,j,j,memb(Rs+#u4) = #U1
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,0,1,1,1,1,1,0,j,j,j,j,j,-,-,-,-,allocframe(#u5:3)
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,1,0,0,0,0,j,j,j,j,j,j,j,x,x,x,x,"Rx = add(Rx,#s7)"
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,1,0,0,1,0,0,0,0,s,s,s,s,d,d,d,d,Rd = Rs
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,1,0,0,0,1,0,j,j,j,j,j,j,d,d,d,d,Rd = #u6
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,1,0,0,1,1,0,1,-,-,0,-,-,d,d,d,d,Rd = #-1
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,1,0,0,1,1,0,1,-,-,1,1,0,d,d,d,d,if (P0) Rd = #0
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,1,0,0,1,1,0,1,-,-,1,1,1,d,d,d,d,if (!P0) Rd = #0
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,1,0,0,1,1,0,1,-,-,1,0,0,d,d,d,d,if (P0.new) Rd = #0
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,1,0,0,1,1,0,1,-,-,1,0,1,d,d,d,d,if (!P0.new) Rd = #0
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,1,0,0,0,1,1,j,j,j,j,j,j,d,d,d,d,"Rd = add(r29,#u6:2)"
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,1,0,0,1,1,0,0,0,s,s,s,s,x,x,x,x,"Rx = add(Rx,Rs)"
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,1,0,0,1,1,0,0,1,s,s,s,s,-,-,j,j,"P0 = cmp.eq(Rs,#u2)"
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,1,0,0,1,1,1,-,1,s,s,s,s,0,d,d,d,"Rdd = combine(#0,Rs)"
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,1,0,0,1,1,1,-,1,s,s,s,s,1,d,d,d,"Rdd = combine(Rs,#0)"
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,1,0,0,1,1,1,-,0,-,I,I,j,j,d,d,d,"Rdd = combine(#u2,#U2)"
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,1,0,0,1,0,0,0,1,s,s,s,s,d,d,d,d,"Rd = add(Rs,#1)"
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,1,0,0,1,0,0,1,1,s,s,s,s,d,d,d,d,"Rd = add(Rs,#-1)"
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,1,0,0,1,0,1,0,0,s,s,s,s,d,d,d,d,Rd = sxth(Rs)
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,1,0,0,1,0,1,0,1,s,s,s,s,d,d,d,d,Rd = sxtb(Rs)
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,1,0,0,1,0,1,1,0,s,s,s,s,d,d,d,d,Rd = zxth(Rs)
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,1,0,0,1,0,0,1,0,s,s,s,s,d,d,d,d,"Rd = and(Rs,#1)"
+-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,-,1,0,0,1,0,1,1,1,s,s,s,s,d,d,d,d,"Rd = and(Rs,#255)"
diff --git a/target/hexagon/helper.c b/target/hexagon/helper.c
new file mode 100644
index 0000000000..5245428404
--- /dev/null
+++ b/target/hexagon/helper.c
@@ -0,0 +1,40 @@
+/*
+ * Hexagon helper routines.
+ *
+ * Copyright (c) 2017-2019 Comsecuris UG (haftungsbeschraenkt)
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "qemu/osdep.h"
+#include "cpu.h"
+#include "exec/exec-all.h"
+#include "qemu/host-utils.h"
+#include "exec/log.h"
+
+void hexagon_cpu_do_interrupt(CPUState *cs)
+{
+}
+
+bool hexagon_cpu_exec_interrupt(CPUState *cs, int interrupt_request)
+{
+    return false;
+}
diff --git a/target/hexagon/helper.h b/target/hexagon/helper.h
new file mode 100644
index 0000000000..bda65c7366
--- /dev/null
+++ b/target/hexagon/helper.h
@@ -0,0 +1,4 @@
+DEF_HELPER_2(raise_exception, void, env, i32)
+DEF_HELPER_2(handle_trap, void, env, i32)
+DEF_HELPER_3(divu, i32, env, i32, i32)
+DEF_HELPER_2(mod, i32, i32, i32)
diff --git a/target/hexagon/hexagon-semi.c b/target/hexagon/hexagon-semi.c
new file mode 100644
index 0000000000..030354f453
--- /dev/null
+++ b/target/hexagon/hexagon-semi.c
@@ -0,0 +1,616 @@
+/*
+ * Hexagon emulation for qemu: main translation routines.
+ *
+ * Copyright (c) 2017-2019 Comsecuris UG (haftungsbeschraenkt)
+ *
+ * Based on target/arm/arm-semi.c which is
+ *  Copyright (c) 2005, 2007 CodeSourcery.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "qemu/osdep.h"
+#include "cpu.h"
+#include "qemu.h"
+
+#define HEXAGON_SEMI_HEAP_SIZE (128 * 1024 * 1024)
+
+#define TARGET_SYS_OPEN        0x001
+#define TARGET_SYS_CLOSE       0x002
+#define TARGET_SYS_WRITEC      0x003
+#define TARGET_SYS_WRITE0      0x004
+#define TARGET_SYS_WRITE       0x005
+#define TARGET_SYS_READ        0x006
+#define TARGET_SYS_READC       0x007
+#define TARGET_SYS_ISTTY       0x009
+#define TARGET_SYS_SEEK        0x00a
+#define TARGET_SYS_FLEN        0x00c
+#define TARGET_SYS_TMPNAM      0x00d
+#define TARGET_SYS_REMOVE      0x00e
+#define TARGET_SYS_RENAME      0x00f
+#define TARGET_SYS_CLOCK       0x010
+#define TARGET_SYS_TIME        0x011
+#define TARGET_SYS_SYSTEM      0x012
+#define TARGET_SYS_ERRNO       0x013
+#define TARGET_SYS_GET_CMDLINE 0x015
+#define TARGET_SYS_HEAPINFO    0x016
+#define TARGET_SYS_EXIT        0x018
+#define TARGET_SYS_SYNCCACHE   0x019
+#define TARGET_SYS_FTELL       0x100
+#define TARGET_SYS_FSTAT       0x101
+#define TARGET_SYS_STATVFS     0x102
+#define TARGET_SYS_STAT        0x103
+#define TARGET_SYS_GETCWD      0x104
+#define TARGET_SYS_ACCESS      0x105
+#define TARGET_SYS_FCNTL       0x106
+#define TARGET_SYS_GETOD       0x107
+#define TARGET_SYS_OPENDIR     0x180
+#define TARGET_SYS_CLOSEDIR    0x181
+#define TARGET_SYS_MKDIR       0x183
+#define TARGET_SYS_RMDIR       0x184
+#define TARGET_SYS_FTRUNC      0x186
+
+#define GET_ARG(n) do {                                 \
+    if (get_user_u32(arg ## n, args + (n) * 4)) {   \
+        return -1;                                  \
+    }                                               \
+} while (0)
+
+#define SET_ARG(n, val)                                 \
+     put_user_u32(val, args + (n) * 4)
+
+static int open_modeflags[12] = {
+    O_RDONLY,
+    O_RDONLY | O_BINARY,
+    O_RDWR,
+    O_RDWR | O_BINARY,
+    O_WRONLY | O_CREAT | O_TRUNC,
+    O_WRONLY | O_CREAT | O_TRUNC | O_BINARY,
+    O_RDWR | O_CREAT | O_TRUNC,
+    O_RDWR | O_CREAT | O_TRUNC | O_BINARY,
+    O_WRONLY | O_CREAT | O_APPEND,
+    O_WRONLY | O_CREAT | O_APPEND | O_BINARY,
+    O_RDWR | O_CREAT | O_APPEND,
+    O_RDWR | O_CREAT | O_APPEND | O_BINARY
+};
+
+target_ulong do_hexagon_semihosting(CPUHexagonState *env)
+{
+    HexagonCPU *cpu = hexagon_env_get_cpu(env);
+    CPUState *cs = CPU(cpu);
+    target_ulong args;
+    target_ulong arg0, arg1, arg2;
+    char * s;
+    int nr;
+    uint32_t ret, len;
+    TaskState *ts = cs->opaque;
+
+    nr = env->gpr[0];
+    args = env->gpr[1];
+
+    switch (nr) {
+    case TARGET_SYS_OPEN:
+        GET_ARG(0);
+        GET_ARG(1);
+        GET_ARG(2);
+        s = lock_user_string(arg0);
+        if (!s) {
+            /* FIXME - should this error code be -TARGET_EFAULT ? */
+            return (uint32_t)-1;
+        }
+        if (arg1 >= 12) {
+            unlock_user(s, arg0, 0);
+            return (uint32_t)-1;
+        }
+        if (strcmp(s, ":tt") == 0) {
+            int result_fileno = arg1 < 4 ? STDIN_FILENO : STDOUT_FILENO;
+            unlock_user(s, arg0, 0);
+            return result_fileno;
+        }
+        /*
+        if (use_gdb_syscalls()) {
+            ret = hexagon_gdb_syscall(cpu, hexagon_semi_cb, "open,%s,%x,1a4", arg0,
+                                  (int)arg2+1, gdb_open_modeflags[arg1]);
+        } else {
+            ret = set_swi_errno(ts, open(s, open_modeflags[arg1], 0644));
+        }
+        */
+        ret = open(s, open_modeflags[arg1], 0644);
+        unlock_user(s, arg0, 0);
+        return ret;
+    case TARGET_SYS_CLOSE:
+        GET_ARG(0);
+        /*
+        if (use_gdb_syscalls()) {
+            return hexagon_gdb_syscall(cpu, hexagon_semi_cb, "close,%x", arg0);
+        } else {
+        }
+        */
+        return close(arg0);
+    case TARGET_SYS_WRITEC:
+        {
+          char c;
+
+          if (get_user_u8(c, args))
+              /* FIXME - should this error code be -TARGET_EFAULT ? */
+              return (uint32_t)-1;
+          /* Write to debug console.  stderr is near enough.  */
+          /*
+          if (use_gdb_syscalls()) {
+                return hexagon_gdb_syscall(cpu, hexagon_semi_cb, "write,2,%x,1", args);
+          } else {
+                return write(STDERR_FILENO, &c, 1);
+          }
+          */
+          return write(STDERR_FILENO, &c, 1);
+        }
+    case TARGET_SYS_WRITE0:
+        if (!(s = lock_user_string(args)))
+            /* FIXME - should this error code be -TARGET_EFAULT ? */
+            return (uint32_t)-1;
+        len = strlen(s);
+        /*
+        if (use_gdb_syscalls()) {
+            return hexagon_gdb_syscall(cpu, hexagon_semi_cb, "write,2,%x,%x",
+                                   args, len);
+        } else {
+            ret = write(STDERR_FILENO, s, len);
+        }
+        */
+        ret = write(STDERR_FILENO, s, len);
+        unlock_user(s, args, 0);
+        return ret;
+    case TARGET_SYS_WRITE:
+        GET_ARG(0);
+        GET_ARG(1);
+        GET_ARG(2);
+        len = arg2;
+        /*
+        if (use_gdb_syscalls()) {
+            hexagon_semi_syscall_len = len;
+            return hexagon_gdb_syscall(cpu, hexagon_semi_cb, "write,%x,%x,%x",
+                                   arg0, arg1, len);
+        } else {
+        */
+            s = lock_user(VERIFY_READ, arg1, len, 1);
+            if (!s) {
+                /* FIXME - should this error code be -TARGET_EFAULT ? */
+                return (uint32_t)-1;
+            }
+            ret = write(arg0, s, len);
+            unlock_user(s, arg1, 0);
+            if (ret == (uint32_t)-1)
+                return -1;
+            return len - ret;
+        //}
+    case TARGET_SYS_READ:
+        GET_ARG(0);
+        GET_ARG(1);
+        GET_ARG(2);
+        len = arg2;
+        /*
+        if (use_gdb_syscalls()) {
+            hexagon_semi_syscall_len = len;
+            return hexagon_gdb_syscall(cpu, hexagon_semi_cb, "read,%x,%x,%x",
+                                   arg0, arg1, len);
+        } else {
+        */
+            s = lock_user(VERIFY_WRITE, arg1, len, 0);
+            if (!s) {
+                /* FIXME - should this error code be -TARGET_EFAULT ? */
+                return (uint32_t)-1;
+            }
+            do {
+                ret = read(arg0, s, len);
+            } while (ret == -1 && errno == EINTR);
+            unlock_user(s, arg1, len);
+            if (ret == (uint32_t)-1)
+                return -1;
+            return len - ret;
+        //}
+    case TARGET_SYS_READC:
+        ret = fgetc(stdin);
+        return ret;
+    case TARGET_SYS_ISTTY:
+        GET_ARG(0);
+        /*
+        if (use_gdb_syscalls()) {
+            return hexagon_gdb_syscall(cpu, hexagon_semi_cb, "isatty,%x", arg0);
+        } else {
+            return isatty(arg0);
+        }
+        */
+        return isatty(arg0);
+    case TARGET_SYS_SEEK:
+        GET_ARG(0);
+        GET_ARG(1);
+        /*
+        if (use_gdb_syscalls()) {
+            return hexagon_gdb_syscall(cpu, hexagon_semi_cb, "lseek,%x,%x,0",
+                                   arg0, arg1);
+        }  else {
+        */
+            ret = lseek(arg0, arg1, SEEK_SET);
+            if (ret == (uint32_t)-1)
+              return -1;
+            return 0;
+        //}
+    case TARGET_SYS_FLEN:
+        GET_ARG(0);
+        /*
+        if (use_gdb_syscalls()) {
+            return hexagon_gdb_syscall(cpu, hexagon_semi_flen_cb, "fstat,%x,%x",
+                                   arg0, hexagon_flen_buf(cpu));
+        } else {
+        */
+            struct stat buf;
+            ret = fstat(arg0, &buf);
+            if (ret == (uint32_t)-1)
+                return -1;
+            return buf.st_size;
+        //}
+    case TARGET_SYS_TMPNAM:
+        /* XXX: Not implemented.  */
+        return -1;
+    case TARGET_SYS_REMOVE:
+        GET_ARG(0);
+        GET_ARG(1);
+        /*
+        if (use_gdb_syscalls()) {
+            ret = hexagon_gdb_syscall(cpu, hexagon_semi_cb, "unlink,%s",
+                                  arg0, (int)arg1+1);
+        } else {
+        */
+            s = lock_user_string(arg0);
+            if (!s) {
+                /* FIXME - should this error code be -TARGET_EFAULT ? */
+                return (uint32_t)-1;
+            }
+            ret =  remove(s);
+            unlock_user(s, arg0, 0);
+        //}
+        return ret;
+    case TARGET_SYS_RENAME:
+        GET_ARG(0);
+        GET_ARG(1);
+        GET_ARG(2);
+        /*
+        if (use_gdb_syscalls()) {
+            return hexagon_gdb_syscall(cpu, hexagon_semi_cb, "rename,%s,%s",
+                                   arg0, (int)arg1+1, arg2, (int)arg3+1);
+        } else {
+        */
+            char *s2;
+            s = lock_user_string(arg0);
+            s2 = lock_user_string(arg2);
+            if (!s || !s2)
+                /* FIXME - should this error code be -TARGET_EFAULT ? */
+                ret = (uint32_t)-1;
+            else
+                ret = rename(s, s2);
+            if (s2)
+                unlock_user(s2, arg2, 0);
+            if (s)
+                unlock_user(s, arg0, 0);
+            return ret;
+        //}
+    case TARGET_SYS_CLOCK:
+        return clock() / (CLOCKS_PER_SEC / 100);
+    case TARGET_SYS_TIME:
+        return time(NULL);
+    case TARGET_SYS_SYSTEM:
+        GET_ARG(0);
+        GET_ARG(1);
+        /*
+        if (use_gdb_syscalls()) {
+            return hexagon_gdb_syscall(cpu, hexagon_semi_cb, "system,%s",
+                                   arg0, (int)arg1+1);
+        } else {
+        */
+            s = lock_user_string(arg0);
+            if (!s) {
+                /* FIXME - should this error code be -TARGET_EFAULT ? */
+                return (uint32_t)-1;
+            }
+            ret = system(s);
+            unlock_user(s, arg0, 0);
+            return ret;
+        //}
+    case TARGET_SYS_GET_CMDLINE:
+        {
+            /* Build a command-line from the original argv.
+             *
+             * The inputs are:
+             *     * arg0, pointer to a buffer of at least the size
+             *               specified in arg1.
+             *     * arg1, size of the buffer pointed to by arg0 in
+             *               bytes.
+             *
+             * The outputs are:
+             *     * arg0, pointer to null-terminated string of the
+             *               command line.
+             *     * arg1, length of the string pointed to by arg0.
+             */
+
+            char *output_buffer;
+            size_t input_size;
+            size_t output_size = 0;
+            size_t string_length = 0;
+            int status = 0;
+            GET_ARG(0);
+            GET_ARG(1);
+            input_size = arg1;
+            /* Compute the size of the output string.  */
+            unsigned int i;
+            unsigned int argc = (ts->info->arg_end - ts->info->arg_start) / (TARGET_LONG_BITS / 8);
+            for(i = 0; i < argc; i++) {
+                string_length = strlen((char *)g2h(ts->info->arg_strings) + output_size);
+                output_size += string_length + 1;
+            }
+
+            if (!output_size) {
+                /* We special-case the "empty command line" case (argc==0).
+                   Just provide the terminating 0. */
+                output_size = 1;
+            }
+
+            if (output_size > input_size) {
+                 /* Not enough space to store command-line arguments.  */
+                return -1;
+            }
+
+            /* Adjust the command-line length.  */
+            if (SET_ARG(1, output_size - 1)) {
+                /* Couldn't write back to argument block */
+                return -1;
+            }
+
+            /* Lock the buffer on the ARM side.  */
+            output_buffer = lock_user(VERIFY_WRITE, arg0, output_size, 0);
+            if (!output_buffer) {
+                return -1;
+            }
+
+            /* Copy the command-line arguments.  */
+#if !defined(CONFIG_USER_ONLY)
+            pstrcpy(output_buffer, output_size, cmdline);
+#else
+            if (output_size == 1) {
+                /* Empty command-line.  */
+                output_buffer[0] = '\0';
+                goto out;
+            }
+
+            if (copy_from_user(output_buffer, ts->info->arg_strings,
+                               output_size)) {
+                status = -1;
+                goto out;
+            }
+
+            /* Separate arguments by white spaces. */
+            for (i = 0; i < output_size - 1; i++) {
+                if (output_buffer[i] == 0) {
+                    output_buffer[i] = ' ';
+                }
+            }
+
+            /* Hexagon puts a trailing whitespace before the terminator */
+            output_buffer[output_size - 1] = ' ';
+            output_buffer[output_size] = '\0';
+        out:
+#endif
+            /* Unlock the buffer on the ARM side.  */
+            unlock_user(output_buffer, arg0, output_size);
+
+            return status;
+        }
+    case TARGET_SYS_HEAPINFO:
+        {
+            target_ulong retvals[4];
+            target_ulong limit;
+            int i;
+
+            GET_ARG(0);
+
+#ifdef CONFIG_USER_ONLY
+            /* Some C libraries assume the heap immediately follows .bss, so
+               allocate it using sbrk.  */
+            if (!ts->heap_limit) {
+                abi_ulong ret;
+
+                ts->heap_base = do_brk(0);
+                limit = ts->heap_base + HEXAGON_SEMI_HEAP_SIZE;
+                /* Try a big heap, and reduce the size if that fails.  */
+                for (;;) {
+                    ret = do_brk(limit);
+                    if (ret >= limit) {
+                        break;
+                    }
+                    limit = (ts->heap_base >> 1) + (limit >> 1);
+                }
+                ts->heap_limit = limit;
+            }
+
+            retvals[0] = ts->heap_base;
+            retvals[1] = ts->heap_limit;
+            retvals[2] = 0; /* XXX: hexagon-sim puts the stack_base to 0 */
+            retvals[3] = 0; /* Stack limit.  */
+#else
+            limit = ram_size;
+            /* TODO: Make this use the limit of the loaded application.  */
+            retvals[0] = limit / 2;
+            retvals[1] = limit;
+            retvals[2] = limit; /* Stack base */
+            retvals[3] = 0; /* Stack limit.  */
+#endif
+
+            for (i = 0; i < ARRAY_SIZE(retvals); i++) {
+                bool fail;
+
+                fail = put_user_u32(retvals[i], arg0 + i * 4);
+
+                if (fail) {
+                    /* Couldn't write back to argument block */
+                    return -1;
+                }
+            }
+            /* HEAPINFO does not clobber r0 */
+            return env->gpr[0];
+        }
+    case TARGET_SYS_EXIT:
+        gdb_exit(env, args);
+        exit(args);
+    case TARGET_SYS_SYNCCACHE:
+        /* We are not emulating caches, just return */
+        return 0;
+    case 0xcd:
+        /* This syscall is called inside the free function */
+        return 0;
+    case TARGET_SYS_FTELL:
+        GET_ARG(0);
+        ret = lseek(arg0, 0, SEEK_CUR);
+        return ret;
+    case TARGET_SYS_FSTAT:
+        return 0;
+    case TARGET_SYS_STATVFS:
+        return 0;
+    case TARGET_SYS_STAT:
+        return 0;
+    case TARGET_SYS_GETCWD:
+        {
+            GET_ARG(0);
+            GET_ARG(1);
+            len = arg1;
+
+            s = lock_user(VERIFY_WRITE, arg0, len, 0);
+            if (!s) {
+                /* FIXME - should this error code be -TARGET_EFAULT ? */
+                return (uint32_t)-1;
+            }
+
+            char * ret = getcwd(s, arg1);
+
+            if(!arg1 && !ret)
+                return -1;
+
+            unlock_user(s, arg1, len);
+            return arg1;
+        }
+    case TARGET_SYS_ACCESS:
+        GET_ARG(0);
+        GET_ARG(1);
+        s = lock_user_string(arg0);
+        if (!s) {
+            /* FIXME - should this error code be -TARGET_EFAULT ? */
+            return (uint32_t)-1;
+        }
+        if (arg1 > 4) {
+            unlock_user(s, arg0, 0);
+            return (uint32_t)-1;
+        }
+        ret = access(s, arg1);
+        unlock_user(s, arg0, 0);
+        return ret;
+    case TARGET_SYS_FCNTL:
+        GET_ARG(0);
+        GET_ARG(1);
+        GET_ARG(2);
+        return fcntl(arg0, arg1, arg2);
+    case TARGET_SYS_GETOD:
+        {
+            GET_ARG(0);
+
+            s = lock_user(VERIFY_WRITE, arg0, sizeof(struct timeval), 0);
+            if (!s) {
+                /* FIXME - should this error code be -TARGET_EFAULT ? */
+                return (uint32_t)-1;
+            }
+
+            gettimeofday((struct timeval *)s, NULL);
+
+            unlock_user(s, arg0, sizeof(struct timeval));
+            return 0;
+        }
+    case TARGET_SYS_OPENDIR:
+        {
+            GET_ARG(0);
+            GET_ARG(1);
+            DIR *dir;
+            s = lock_user_string(arg0);
+            if (!s) {
+                /* FIXME - should this error code be -TARGET_EFAULT ? */
+                return (uint32_t)-1;
+            }
+            dir = opendir(s);
+            if (!dir)
+                return -1;
+
+            /* TODO: Copy information in new buffer before returning it */
+
+            unlock_user(s, arg0, 0);
+            return 0;
+        }
+    case TARGET_SYS_CLOSEDIR:
+        return 0;
+    case TARGET_SYS_MKDIR:
+            /* Create a folder
+             *
+             * The inputs are:
+             *     * r1, contains the string of the folder name
+             *     * r2, contains the mode parameter
+             *
+             * The outputs are:
+             *     * 0, contains the return code
+             */
+        s = lock_user_string(env->gpr[1]);
+        int mode = env->gpr[2];
+        if (!s) {
+            /* FIXME - should this error code be -TARGET_EFAULT ? */
+            return (uint32_t)-1;
+        }
+        if (mode >= 12) {
+            unlock_user(s, env->gpr[1], 0);
+            return (uint32_t)-1;
+        }
+        ret = mkdir(s, 0644);
+        unlock_user(s, env->gpr[1], 0);
+        return ret;
+    case TARGET_SYS_RMDIR:
+            /* Delete a folder
+             *
+             * The inputs are:
+             *     * r1, contains the string of the folder name
+             *
+             * The outputs are:
+             *     * 0, contains the return code
+             */
+        s = lock_user_string(env->gpr[1]);
+        if (!s) {
+            /* FIXME - should this error code be -TARGET_EFAULT ? */
+            return (uint32_t)-1;
+        }
+        ret = rmdir(s);
+        unlock_user(s, env->gpr[1], 0);
+        return ret;
+    case TARGET_SYS_FTRUNC:
+        GET_ARG(0);
+        GET_ARG(1);
+        ret = ftruncate(arg0, arg1);
+        return ret;
+    default:
+        fprintf(stderr, "qemu: Unsupported SemiHosting SWI 0x%02x\n", nr);
+        cpu_dump_state(cs, stderr, fprintf, 0);
+        abort();
+    }
+}
diff --git a/target/hexagon/op_helper.c b/target/hexagon/op_helper.c
new file mode 100644
index 0000000000..a3e384a94d
--- /dev/null
+++ b/target/hexagon/op_helper.c
@@ -0,0 +1,132 @@
+/*
+ * Hexagon helper routines.
+ *
+ * Copyright (c) 2017-2019 Comsecuris UG (haftungsbeschraenkt)
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "qemu/osdep.h"
+#include "cpu.h"
+#include "exec/helper-proto.h"
+#include "qemu/host-utils.h"
+#include "exec/exec-all.h"
+#include "exec/cpu_ldst.h"
+#include "decoder.h"
+
+#define SYSCALL  0
+#define CPU_DUMP 1
+#define PUTS     2
+#define READN    3
+#define WRITEN   4
+#define EXCEPT   5
+#define READ     6
+#define WRITE    7
+#define STACK    8
+#define FWRITE   9
+#define EXIT    10
+
+void helper_raise_exception(CPUHexagonState *env, uint32_t index)
+{
+    CPUState *cs = CPU(hexagon_env_get_cpu(env));
+    cs->exception_index = index;
+    fprintf(stderr, "Raised exception number %d!", index);
+    cpu_dump_state(cs, stderr, fprintf, 0);
+    exit(EXIT_SUCCESS);
+}
+
+void helper_handle_trap(CPUHexagonState *env, uint32_t index)
+{
+    // TODO: Switch to semi-hosting syscalls style
+    CPUState *cs = CPU(hexagon_env_get_cpu(env));
+    FILE *out = 0;
+    switch(index) {
+        case CPU_DUMP:
+            cpu_dump_state(cs, stderr, fprintf, 0);
+            break;
+        case SYSCALL:
+            cs->exception_index = EXCP_TRAP_INSN;
+            cpu_loop_exit(cs);
+            break;
+        case PUTS:
+            puts((char *)g2h(env->gpr[0]));
+            break;
+        case READN:
+        {
+            int scanned = scanf("\n%d", &env->gpr[0]);
+            assert(scanned == 1);
+            break;
+        }
+        case WRITEN:
+            fprintf(stderr, "DEBUG:%d\n", env->gpr[28]);
+            break;
+        case EXCEPT:
+            helper_raise_exception(env, env->gpr_new[0]);
+            break;
+        case READ:
+            env->gpr[0] = read(STDIN_FILENO, (void *)g2h(env->gpr[0]), env->gpr[1]);
+            break;
+        case WRITE:
+            env->gpr[0] = write(STDOUT_FILENO, (void *)g2h(env->gpr[0]), env->gpr[1]);
+            break;
+        case STACK:
+            fprintf(stderr, "STACK TRACE:\n");
+            for (int i = 0; i < 4; i++) {
+                fprintf(stderr, "%#8.8x: ", env->gpr[29] + 4 * (4 * i));
+                for (int j = 0; j < 4; j++)
+                    fprintf(stderr, "%#8.8x ", *((unsigned int *)g2h(env->gpr[29] + 4 * (4 * i + j))));
+                fprintf(stderr, "\n");
+            }
+            break;
+        case FWRITE:
+            out = fopen("output", "ab");
+            fwrite((void *)g2h(env->gpr[0]), env->gpr[1], 1, out);
+            fclose(out);
+            break;
+        case EXIT:
+            exit(EXIT_SUCCESS);
+            break;
+        default:
+            assert(false && "Unhandled trap0 argument!");
+    }
+}
+
+static inline int div_prepare(CPUHexagonState *env, uint32_t x, uint32_t y)
+{
+    if (y == 0) {
+        helper_raise_exception(env, EXCP_HW_EXCP);
+        return 0;
+    }
+    return 1;
+}
+
+uint32_t helper_divu(CPUHexagonState *env, uint32_t x, uint32_t y)
+{
+    if (!div_prepare(env, x, y)) {
+        return 0;
+    }
+    return x / y;
+}
+
+uint32_t helper_mod(uint32_t x, uint32_t y)
+{
+    return x % y;
+}
diff --git a/target/hexagon/translate.c b/target/hexagon/translate.c
new file mode 100644
index 0000000000..e52c097b11
--- /dev/null
+++ b/target/hexagon/translate.c
@@ -0,0 +1,647 @@
+/*
+ * Hexagon emulation for qemu: main translation routines.
+ *
+ * Copyright (c) 2017-2019 Comsecuris UG (haftungsbeschraenkt)
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "qemu/osdep.h"
+#include "cpu.h"
+#include "decoder.h"
+#include "disas/disas.h"
+#include "exec/exec-all.h"
+#include "tcg-op.h"
+#include "tcg.h"
+#include "exec/helper-proto.h"
+#include "exec/cpu_ldst.h"
+#include "exec/helper-gen.h"
+#include "exec/translator.h"
+
+#include "trace-tcg.h"
+#include "exec/log.h"
+
+#define LOG_DIS(...) qemu_log_mask(CPU_LOG_TB_IN_ASM, ## __VA_ARGS__)
+#define EXTRACT_FIELD(src, start, end) \
+    (((src) >> start) & ((1 << (end - start + 1)) - 1))
+#define EXTRACT_FIELD_2(src, start, end, start2, end2) \
+    (EXTRACT_FIELD(src, start2, end2) << (end - start + 1)) | \
+    (EXTRACT_FIELD(src, start, end))
+
+//#define DUMP_EVERY_INST
+
+TCGv GPR[32];
+TCGv CR[32];
+TCGv SR[64];
+TCGv GPR_new[32];
+TCGv CR_new[32];
+TCGv PC_written;
+TCGv PC_trace;
+TCGv SA[2];
+TCGv LC[2];
+TCGv LPCFG;
+
+#include "exec/gen-icount.h"
+
+static const char *general_regnames[] =
+{
+    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
+    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
+    "r16", "r17", "r18", "r19", "r20", "r21", "r22", "r23",
+    "r24", "r25", "r26", "r27", "r28", "r29", "r30", "r31",
+};
+
+static const char *general_regnames_new[] =
+{
+    "r0.new", "r1.new", "r2.new", "r3.new", "r4.new", "r5.new", "r6.new",
+    "r7.new", "r8.new", "r9.new", "r10.new", "r11.new", "r12.new", "r13.new",
+    "r14.new", "r15.new", "r16.new", "r17.new", "r18.new", "r19.new",
+    "r20.new", "r21.new", "r22.new", "r23.new", "r24.new", "r25.new",
+    "r26.new", "r27.new", "r28.new", "r29.new", "r30.new", "r31.new",
+};
+
+static const char *control_regnames[] =
+{
+    "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7",
+    "c8", "c9", "c10", "c11", "c12", "c13", "c14", "c15",
+    "c16", "c17", "c18", "c19", "c20", "c21", "c22", "c23",
+    "c24", "c25", "c26", "c27", "c28", "c29", "c30", "c31",
+};
+
+static const char *control_regnames_new[] =
+{
+    "c0.new", "c1.new", "c2.new", "c3.new", "c4.new", "c5.new", "c6.new",
+    "c7.new", "c8.new", "c9.new", "c10.new", "c11.new", "c12.new", "c13.new",
+    "c14.new", "c15.new", "c16.new", "c17.new", "c18.new", "c19.new",
+    "c20.new", "c21.new", "c22.new", "c23.new", "c24.new", "c25.new",
+    "c26.new", "c27.new", "c28.new", "c29.new", "c30.new", "c31.new",
+};
+
+static const char *system_regnames[] =
+{
+    "s0", "s1", "s2", "s3", "s4", "s5", "s6", "s7",
+    "s8", "s9", "s10", "s11", "s12", "s13", "s14", "s15",
+    "s16", "s17", "s18", "s19", "s20", "s21", "s22", "s23",
+    "s24", "s25", "s26", "s27", "s28", "s29", "s30", "s31",
+    "s32", "s33", "s34", "s35", "s36", "s37", "s38", "s39",
+    "s40", "s41", "s42", "s43", "s44", "s45", "s46", "s47",
+    "s48", "s49", "s50", "s51", "s52", "s53", "s54", "s55",
+    "s56", "s57", "s58", "s59", "s60", "s61", "s62", "s63",
+};
+
+static const char *hwloop_regnames[] =
+{
+    "sa0", "sa1", "lc0", "lc1", "lpcfg",
+};
+
+static int first_sub_type[] =  {0, 0, 1, 4, 4, 4, 4, 4, 0, 1, 2, 2, 0, 1, 3};
+static int last_sub_type[] = {0, 1, 1, 4, 0, 1, 2, 3, 2, 2, 2, 3, 3, 3, 3};
+
+static void clear_d_reg_helper(d_reg_list list)
+{
+    if (list == NULL)
+        return;
+    if (list->next == NULL)
+        free(list);
+    else
+        clear_d_reg_helper(list->next);
+}
+
+static inline void clear_destination_reg(DisasContext *dc)
+{
+    regs_t *regs = &(dc->regs);
+    d_reg_list *list = &regs->destination;
+    clear_d_reg_helper(*list);
+    *list = NULL;
+}
+
+static inline void extend_destination_reg(d_reg_list* list, d_reg_list ext)
+{
+    if (ext != 0) {
+        /* Copy only the first destination register,
+           if there are two it means that the destination is a 64bit register */
+        //assert(ext->next == NULL && "Destination list contains more than 1 node!");
+        clear_d_reg_helper(ext->next);
+        ext->next = *list;
+        *list = ext;
+    }
+}
+
+static inline void regs_append(DisasContext *dc, regs_t regs) {
+    // If no output reg has been written add -1 to the list
+    if (regs.destination == NULL)
+        push_destination_reg(&regs.destination, -1);
+    (dc->regs).written |= regs.written;
+    (dc->regs).written |= regs.conditional;
+    (dc->regs).conditional |= regs.conditional;
+    extend_destination_reg(&(dc->regs.destination), regs.destination);
+    // If the predicate has been written note it in the dc
+    if ((dc->regs).written & (uint64_t)1 << (CR_P + 32))
+        dc->is_pre_written = true;
+}
+
+static inline uint8_t compute_collapse(DisasContext *dc, int placed) {
+    uint8_t written_regs = 0;
+    for (int i = 0; i < placed; i++)
+        written_regs |= (dc->ordered[i])->written;
+    return written_regs;
+}
+
+static inline int add_solved_deps(DisasContext *dc,
+                                  int *placed,
+                                  uint8_t written_regs) {
+    int i = 0;
+    for (i = 0; i <= dc->i; i++) {
+        // Check if all the read registers have been written //
+        if (dc->original[i] != NULL) {
+            uint8_t needed_regs = (dc->original[i])->read &
+                                  ~(dc->original[i])->written;
+            if ((needed_regs & written_regs) == needed_regs) {
+                dc->ordered[*placed] = dc->original[i];
+                (*placed)++;
+                dc->original[i] = NULL;
+            }
+        }
+    }
+    return i - 1;
+}
+
+static inline void print_op(TCGOp *op) {
+    if (op == 0) {
+        LOG_DIS("NULL");
+        return;
+    }
+    TCGOpcode c = op->opc;
+    TCGOpDef *def = &tcg_op_defs[c];
+    LOG_DIS("%s\n", def->name);
+}
+
+static inline void reorder_ops(DisasContext *dc) {
+    //for (int i = dc->i; i >= 0; i--) {
+    //    deps_t *to_move = dc->ordered[i];
+    //    tcg_op_move_range_after(to_move->begin, to_move->end, dc->packet_first_op);
+    //}
+    for (int i = 0; i <= dc->i; i++) {
+        deps_t *to_move = dc->ordered[i];
+        qemu_log("from: %p ", to_move->begin);
+        qemu_log("to: %p\n", to_move->end);
+    }
+    TCGOp *pos = dc->packet_first_op;
+    for (int i = 0; i <= dc->i; i++) {
+        deps_t *to_move = dc->ordered[i];
+        tcg_op_move_range_after(to_move->begin, to_move->end, pos);
+        pos = to_move->end;
+    }
+}
+
+static inline void solve_dependencies(DisasContext *dc) {
+    bool ordering_needed = false;
+    int placed = 0, order = 0;
+    uint8_t written_regs = 0;
+
+    for(int i = 0; i <= dc->i; i++)
+        dc->original[i] = &(dc->deps[i]);
+
+    while (placed <= dc->i) {
+        // Update collapse of written regs 
+        written_regs = compute_collapse(dc, placed);
+        // Add instructions whose deps are already solved 
+        order = add_solved_deps(dc, &placed, written_regs);
+        if (order != placed - 1) {
+            ordering_needed = true;
+        }
+    }
+
+    // Reorder only if needed
+    if (ordering_needed) {
+        reorder_ops(dc);
+    }
+}
+
+static inline void handle_packet_begin(DisasContext *dc)
+{
+   LOG_DIS("{ ");
+   dc->new_packet = false;
+}
+
+static inline void handle_packet_end(DisasContext *dc)
+{
+    LOG_DIS(" }");
+
+    solve_dependencies(dc);
+
+    /* Commit temporary registers to CPU registers */
+    for (int i = 0; i < 32; i++) {
+        if (GET_USED_REG(dc->regs, i))
+            tcg_gen_mov_tl(GPR[i], GPR_new[i]);
+    }
+    for (int i = 0; i < 32; i++) {
+        if (i != CR_PC && GET_USED_REG(dc->regs, (i + 32)))
+            tcg_gen_mov_tl(CR[i], CR_new[i]);
+    }
+
+    // Clear temp registers
+    for (int i = 0; i < 32; i++) {
+        if (GET_USED_REG(dc->regs, i))
+            tcg_gen_movi_tl(GPR_new[i], 0);
+    }
+    for (int i = 0; i < 32; i++) {
+        if (i != CR_PC && GET_USED_REG(dc->regs, (i + 32)))
+            tcg_gen_movi_tl(CR_new[i], 0);
+    }
+
+    /* Detect if CR_PC has been written */
+    if (GET_USED_REG(dc->regs, (CR_PC + 32))) {
+        dc->pc_written = true;
+        // Emit control flow runtime handler
+        // If pc has not been written increment PC
+        TCGv tmp = tcg_temp_new_i32();
+        TCGv zero = tcg_const_i32(0);
+        TCGv pc = tcg_const_i32(dc->instruction_pc);
+        tcg_gen_addi_i32(tmp, pc, 4);
+        tcg_gen_movcond_i32(TCG_COND_GT, CR[CR_PC], PC_written, zero, CR[CR_PC], tmp);
+        tcg_gen_movi_i32(PC_written, 0);
+    }
+
+    /* Inject initialization for conditional registers */
+    bool first_move = true;
+    TCGOp *begin_op = NULL;
+    for (int i = 0; i < 32; i++) {
+        if (GET_COND_REG(dc->regs, i)) {
+            tcg_gen_mov_tl(GPR_new[i], GPR[i]);
+            if (first_move) {
+                begin_op = tcg_last_op();
+                first_move = false;
+            }
+        }
+    }
+    for (int i = 0; i < 32; i++) {
+        if (i != CR_PC && GET_COND_REG(dc->regs, (i + 32))) {
+            tcg_gen_mov_tl(CR_new[i], CR[i]);
+            if (first_move) {
+                begin_op = tcg_last_op();
+                first_move = false;
+            }
+        }
+    }
+
+    /* Mark the end of the register initialization sequence */
+    TCGOp *end_op = tcg_last_op();
+
+    if (begin_op != NULL)
+        tcg_op_move_range_after(begin_op, end_op, dc->packet_first_op);
+
+    clear_destination_reg(dc);
+    memset(&dc->regs, 0, sizeof(regs_t));
+    memset(&dc->deps, 0, 4 * sizeof(deps_t));
+    memset(&dc->original, 0, 4 * sizeof(deps_t *));
+    memset(&dc->ordered, 0, 4 * sizeof(deps_t *));
+    dc->is_pre_written = false;
+    dc->i = -1;
+
+    /* Handle hardware loops */
+    if (dc->endloop[0] || dc->endloop[1]) {
+        if (dc->endloop[0] && dc->endloop[1])
+            endloop01();
+        else if (dc->endloop[0]) {
+            LOG_DIS(" :endloop0");
+            endloop0();
+        }
+        else if (dc->endloop[1]) {
+            LOG_DIS(" :endloop1");
+            endloop1();
+        }
+        dc->pc_written = true;
+        // Emit control flow runtime handler
+        // If pc has not been written increment PC
+        TCGv tmp = tcg_temp_new_i32();
+        TCGv zero = tcg_const_i32(0);
+        TCGv pc = tcg_const_i32(dc->instruction_pc);
+        tcg_gen_addi_i32(tmp, pc, 4);
+        tcg_gen_movcond_i32(TCG_COND_GT, CR[CR_PC], PC_written, zero, CR[CR_PC], tmp);
+        tcg_gen_movi_tl(PC_written, 0);
+    }
+    dc->endloop[0] = false;
+    dc->endloop[1] = false;
+};
+
+static inline void decode_packet(DisasContext *dc, CPUState *cs, uint32_t ir)
+{
+    if (dc->new_packet) {
+        /* Set the beginning of the packet list */
+        dc->packet_first_op = tcg_last_op();
+    }
+
+    /* Update the PC at each instruction */
+    tcg_gen_movi_tl(PC_trace, dc->instruction_pc);
+
+    dc->i++;
+    /* Instruction begin */
+    dc->deps[dc->i].begin = tcg_last_op();
+
+    dc->ir = ir;
+    LOG_DIS("%8.8x\t", dc->ir);
+    bool packet_end = false;
+    /* TODO: Assert that we have at most 4 instructions in a packet */
+    uint8_t parse_bits = EXTRACT_FIELD(ir, 14, 15);
+    uint8_t iclass_bits = EXTRACT_FIELD(ir, 28, 31);
+    uint32_t insn = 0, first_insn = 0, last_insn = 0;
+    uint32_t last_sub = 0, first_sub = 0;
+    /* Handle constant extenders (they provide the upper 26 bits) */
+    switch (parse_bits) {
+        case 0x1:
+            break;
+        /* endloop */
+        case 0x2:
+            if (dc->i == 0)
+              dc->endloop[0] = true;
+            if (dc->i == 1)
+              dc->endloop[1] = true;
+            break;
+        /* End of packet */
+        case 0x3:
+            packet_end = true;
+            break;
+        /* Duplex */
+        case 0x0:
+            dc->duplex = true;
+            packet_end = true;
+            break;
+        default:
+            cpu_abort(CPU(dc->cpu),
+                    "Hexagon: illegal value for ParseBits=%x\n", parse_bits);
+    }
+    if (parse_bits != 0x0 && iclass_bits == 0x0) {
+        dc->extender_present = true;
+        dc->const_ext = EXTRACT_FIELD_2(ir, 0, 13, 16, 27);
+        dc->const_ext <<= 6;
+        if (dc->new_packet) {
+            LOG_DIS("\t");
+            handle_packet_begin(dc);
+        } else
+            LOG_DIS("\t  ");
+        LOG_DIS("immext(#%" PRIu32 ")\n", dc->const_ext);
+        dc->deps[dc->i].end = tcg_last_op();
+        /* TODO: Assert that packet does not contain only an immext */
+        return;
+    }
+    if (dc->duplex) {
+        iclass_bits = EXTRACT_FIELD_2(ir, 13, 13, 29, 31);
+        assert(iclass_bits < 0xf && "Illegal value for ICLASS bits!\n");
+        /* Craft slot 1 sub-instruction */
+        first_sub = (ir >> 16) & 0x1fff;
+        first_sub |= (first_sub_type[iclass_bits] << 13);
+        first_insn = sub_decode(first_sub);
+        LOG_DIS("%d ", first_insn);
+        /* Craft slot 0 sub-instruction */
+        last_sub = ir & 0x1fff;
+        last_sub |= (last_sub_type[iclass_bits] << 13);
+        last_insn = sub_decode(last_sub);
+        LOG_DIS("%d\t", last_insn);
+    } else {
+        insn = decode(ir);
+        LOG_DIS("%d\t", insn);
+    }
+    if (dc->new_packet) {
+        handle_packet_begin(dc);
+    }
+    else
+        LOG_DIS("  ");
+    if (dc->duplex) {
+        dc->ir = first_sub;
+        regs_t new_regs = sub_execute(first_insn, dc);
+        regs_append(dc, new_regs);
+        LOG_DIS(" ");
+        dc->ir = last_sub;
+        /* Constant extender must be used only by sub-instruction in slot 1 */
+        if (dc->extender_present) {
+            dc->extender_present = false;
+        }
+        new_regs = sub_execute(last_insn, dc);
+        regs_append(dc, new_regs);
+        dc->duplex = false;
+    } else {
+        regs_t new_regs = execute(insn, dc);
+        regs_append(dc, new_regs);
+    }
+
+    /* Reset Constant Extender */
+    if (dc->extender_present) {
+        dc->extender_present = false;
+        dc->const_ext = 0;
+    }
+
+#ifdef DUMP_EVERY_INST
+            /* Inject CPU dump */
+        	TCGv_i32 tmp_0 = tcg_const_i32(1);
+        	gen_helper_handle_trap(cpu_env, tmp_0);
+        	tcg_temp_free_i32(tmp_0);
+
+            /* Inject stack trace */
+        	TCGv_i32 tmp_1 = tcg_const_i32(8);
+        	gen_helper_handle_trap(cpu_env, tmp_1);
+        	tcg_temp_free_i32(tmp_1);
+#endif
+
+    /* Instruction end */
+    dc->deps[dc->i].end = tcg_last_op();
+
+    if (packet_end) {
+        handle_packet_end(dc);
+        dc->new_packet = true;
+
+    }
+    /* If instruction is a trap0 or if pc has been written, close block */
+    if (ir == 0x5400c000 || dc->pc_written) {
+        dc->block_end = true;
+        dc->pc_written = false;
+    }
+    LOG_DIS("\n");
+
+};
+
+/* generate intermediate code for basic block 'tb'.  */
+void gen_intermediate_code(CPUState *cs, struct TranslationBlock *tb)
+{
+    CPUHexagonState *env = cs->env_ptr;
+    HexagonCPU *cpu = hexagon_env_get_cpu(env);
+    uint32_t pc_start;
+    struct DisasContext ctx = { 0 };
+    struct DisasContext *dc = &ctx;
+    int num_insns;
+    int max_insns;
+    uint32_t insn;
+    uint8_t parse_bits;
+
+    pc_start = tb->pc;
+    dc->cpu = cpu;
+    dc->tb = tb;
+    dc->old_pc = pc_start;
+    dc->instruction_pc = pc_start;
+    dc->pc = pc_start;
+    dc->new_packet = true;
+    dc->i = -1;
+
+    if (pc_start & 3) {
+        cpu_abort(cs, "Hexagon: unaligned PC=%x\n", pc_start);
+    }
+
+    num_insns = 0;
+    max_insns = tb_cflags(tb) & CF_COUNT_MASK;
+    if (max_insns == 0) {
+    max_insns = CF_COUNT_MASK;
+    }
+    if (max_insns > TCG_MAX_INSNS) {
+        max_insns = TCG_MAX_INSNS;
+    }
+
+    gen_tb_start(tb);
+    do
+    {
+        if (dc->new_packet) {
+            /* Lookahead to find the next packet address */
+            target_ulong pc_iter = dc->instruction_pc;
+            insn = cpu_ldl_code(env, pc_iter);
+            parse_bits = EXTRACT_FIELD(insn, 14, 15);
+            while (parse_bits != 0x3 && parse_bits != 0x0) {
+                insn = cpu_ldl_code(env, pc_iter);
+                parse_bits = EXTRACT_FIELD(insn, 14, 15);
+                pc_iter += 4;
+            }
+            if (pc_iter == dc->instruction_pc)
+                pc_iter += 4;
+            dc->npc = pc_iter;
+
+            /* Emit an instruction start only when a packet begins */
+            tcg_gen_insn_start(dc->pc);
+            num_insns++;
+            dc->pc = dc->instruction_pc;
+        }
+
+        /* Pretty disas.  */
+        LOG_DIS("%8.8x:\t", dc->instruction_pc);
+
+        /* Fetch instructions from memory and decode them */
+        insn = cpu_ldl_code(env, dc->instruction_pc);
+        decode_packet(dc, cs, insn);
+        dc->old_pc = dc->instruction_pc;
+        dc->instruction_pc += 4;
+    } while (!dc->block_end);
+
+    /* Use the hash table to find the next TB */
+    tcg_gen_exit_tb(NULL, 0);
+    gen_tb_end(tb, num_insns);
+
+    tb->size = dc->instruction_pc - pc_start;
+    tb->icount = num_insns;
+}
+
+void hexagon_cpu_dump_state(CPUState *cs, FILE *f, fprintf_function cpu_fprintf,
+                       int flags)
+{
+    CPUHexagonState *env = cs->env_ptr;
+    int i = 0;
+
+    cpu_fprintf(f, "\n\nIN: PC=%x %s\n",
+                env->pc_trace, lookup_symbol(env->pc_trace));
+    for (i = 0; i < 32; i++) {
+        cpu_fprintf(f, "r%2.2d=%8.8x ", i, env->gpr[i]);
+        if ((i + 1) % 4 == 0)
+            cpu_fprintf(f, "\n");
+        }
+    cpu_fprintf(f, "LC0=%8.8x LC1=%8.8x SA0=%8.8x SA1=%8.8x\n", env->lc[0],
+                                                                env->lc[1],
+                                                                env->sa[0],
+                                                                env->sa[1]);
+    cpu_fprintf(f, "LPCFG=%8.8x GP=%8.8x ", env->lpcfg, env->cr[11]);
+    for (i = 0; i < 4; i++) {
+        int8_t p = (env->cr[CR_P] & (0xff << 8 * i)) >> 8 * i;
+        cpu_fprintf(f, "p%2.2d=%x ", i, (char) p & 0xff);
+    }
+    cpu_fprintf(f, "\nPC_written=%x ", env->pc_written);
+    cpu_fprintf(f, "evb=%x ", env->sr[16]);
+    cpu_fprintf(f, "PC=%x\n", env->cr[9]);
+}
+
+void hexagon_tcg_init(void)
+{
+    int i;
+
+    for (i = 0; i < ARRAY_SIZE(GPR); i++) {
+        GPR[i] = tcg_global_mem_new(cpu_env,
+                offsetof(CPUHexagonState, gpr[i]),
+                general_regnames[i]);
+    }
+
+    for (i = 0; i < ARRAY_SIZE(CR); i++) {
+        CR[i] = tcg_global_mem_new_i32(cpu_env,
+                offsetof(CPUHexagonState, cr[i]),
+                control_regnames[i]);
+    }
+
+	for (i = 0; i < ARRAY_SIZE(SR); i++) {
+        SR[i] = tcg_global_mem_new_i32(cpu_env,
+                offsetof(CPUHexagonState, sr[i]),
+                system_regnames[i]);
+    }
+
+    for (i = 0; i < ARRAY_SIZE(GPR_new); i++) {
+        GPR_new[i] = tcg_global_mem_new(cpu_env,
+                offsetof(CPUHexagonState, gpr_new[i]),
+                general_regnames_new[i]);
+    }
+
+    for (i = 0; i < ARRAY_SIZE(CR_new); i++) {
+        CR_new[i] = tcg_global_mem_new(cpu_env,
+                offsetof(CPUHexagonState, cr_new[i]),
+                control_regnames_new[i]);
+    }
+
+    PC_written = tcg_global_mem_new(cpu_env,
+                                    offsetof(CPUHexagonState, pc_written),
+                                    "pc_written");
+
+    PC_trace = tcg_global_mem_new(cpu_env,
+                                  offsetof(CPUHexagonState, pc_trace),
+                                  "pc_trace");
+
+    for (i = 0; i < ARRAY_SIZE(SA); i++) {
+        SA[i] = tcg_global_mem_new(cpu_env,
+                offsetof(CPUHexagonState, sa[i]),
+                hwloop_regnames[i]);
+    }
+
+    for (i = 0; i < ARRAY_SIZE(LC); i++) {
+        LC[i] = tcg_global_mem_new(cpu_env,
+                offsetof(CPUHexagonState, lc[i]),
+                hwloop_regnames[i+2]);
+    }
+
+    LPCFG = tcg_global_mem_new(cpu_env,
+                               offsetof(CPUHexagonState, lpcfg),
+                               hwloop_regnames[4]);
+
+}
+
+void restore_state_to_opc(CPUHexagonState *env, TranslationBlock *tb,
+                          target_ulong *data)
+{
+}
diff --git a/tcg/tcg.c b/tcg/tcg.c
index f27b22bd3c..ea3bb8e866 100644
--- a/tcg/tcg.c
+++ b/tcg/tcg.c
@@ -2202,6 +2202,35 @@ TCGOp *tcg_emit_op(TCGOpcode opc)
     return op;
 }
 
+/* Insert the range between begin and end right before pos */
+void tcg_op_move_range_after(TCGOp *begin, TCGOp *end, TCGOp *pos) {
+    TCGOp *op;
+    struct TCGOpHead range;
+
+    assert(begin != NULL && end != NULL && pos != NULL &&
+           "Moving range with invalid arguments");
+
+    /* If pos == begin there is nothing to do */
+    if(pos == begin)
+        return;
+    
+    /* Sanity check: pos must not be between begin and end */
+    range.tqh_first = begin;
+    range.tqh_last = &end;
+    QTAILQ_FOREACH(op, &range, link) {
+        if (op == end)
+            break;
+        assert(op != pos && "Range contains target position");
+    }
+
+    /* Remove the range from the list */
+    QTAILQ_REMOVE_RANGE(&tcg_ctx->ops, begin, end, link);
+
+    /* Insert it before pos */
+    QTAILQ_INSERT_RANGE_AFTER(&tcg_ctx->ops, pos, begin, end, link);
+
+}
+
 TCGOp *tcg_op_insert_before(TCGContext *s, TCGOp *old_op,
                             TCGOpcode opc, int nargs)
 {
diff --git a/tcg/tcg.h b/tcg/tcg.h
index f9f12378e9..0355781c4d 100644
--- a/tcg/tcg.h
+++ b/tcg/tcg.h
@@ -1072,6 +1072,7 @@ TCGOp *tcg_emit_op(TCGOpcode opc);
 void tcg_op_remove(TCGContext *s, TCGOp *op);
 TCGOp *tcg_op_insert_before(TCGContext *s, TCGOp *op, TCGOpcode opc, int narg);
 TCGOp *tcg_op_insert_after(TCGContext *s, TCGOp *op, TCGOpcode opc, int narg);
+void tcg_op_move_range_after(TCGOp *begin, TCGOp *end, TCGOp *pos);
 
 void tcg_optimize(TCGContext *s);
 
diff --git a/tests/tcg/hexagon/.gitignore b/tests/tcg/hexagon/.gitignore
new file mode 100644
index 0000000000..b734650a3c
--- /dev/null
+++ b/tests/tcg/hexagon/.gitignore
@@ -0,0 +1,4 @@
+*.tst
+*.o
+pmu_statsfile.txt
+trunc_test_file.txt
diff --git a/tests/tcg/hexagon/Makefile b/tests/tcg/hexagon/Makefile
new file mode 100644
index 0000000000..7e5af7289d
--- /dev/null
+++ b/tests/tcg/hexagon/Makefile
@@ -0,0 +1,111 @@
+-include ../../../config-host.mak
+
+SIM = qemu-hexagon
+REF = hexagon-sim
+
+CC := hexagon-clang
+C_CFLAGS := -O1
+ASM_CFLAGS := -O0
+LDFLAGS := -static -nostdlib
+REFFLAGS := -t trace.log
+
+TSRC_PATH = $(SRC_PATH)/tests/tcg/hexagon
+
+CRT        = crt.o
+#TESTCASES += test_vcmp.tst
+TESTCASES += test_abs.tst
+TESTCASES += test_add.tst
+TESTCASES += test_andp.tst
+TESTCASES += test_bitcnt.tst
+TESTCASES += test_bitsplit.tst
+TESTCASES += test_call.tst
+TESTCASES += test_clobber.tst
+TESTCASES += test_cmp.tst
+TESTCASES += test_cmpy.tst
+TESTCASES += test_djump.tst
+TESTCASES += test_dotnew.tst
+TESTCASES += test_dstore.tst
+TESTCASES += test_ext.tst
+TESTCASES += test_fibonacci.tst
+TESTCASES += test_hello.tst
+TESTCASES += test_hl.tst
+TESTCASES += test_hwloops.tst
+TESTCASES += test_jmp.tst
+TESTCASES += test_lsr.tst
+TESTCASES += test_mem.tst
+TESTCASES += test_mpyi.tst
+TESTCASES += test_packet.tst
+TESTCASES += test_reorder.tst
+TESTCASES += test_round.tst
+TESTCASES += test_sys_access.tst
+TESTCASES += test_sys_clock.tst
+TESTCASES += test_sys_close.tst
+TESTCASES += test_sys_cmdline.tst
+TESTCASES += test_sys_flen.tst
+TESTCASES += test_sys_ftell.tst
+TESTCASES += test_sys_ftrunc.tst
+TESTCASES += test_sys_getcwd.tst
+TESTCASES += test_sys_gettimeofday.tst
+TESTCASES += test_sys_heapinfo.tst
+TESTCASES += test_sys_istty.tst
+TESTCASES += test_sys_mkdir.tst
+TESTCASES += test_sys_open.tst
+TESTCASES += test_sys_opendir.tst
+TESTCASES += test_sys_read.tst
+TESTCASES += test_sys_readc.tst
+TESTCASES += test_sys_rmdir.tst
+TESTCASES += test_sys_seek.tst
+TESTCASES += test_vavgw.tst
+TESTCASES += test_vcmpb.tst
+TESTCASES += test_vcmpw.tst
+TESTCASES += test_vcmpy.tst
+TESTCASES += test_vlsrw.tst
+TESTCASES += test_vmaxh.tst
+TESTCASES += test_vminh.tst
+TESTCASES += test_vpmpyh.tst
+TESTCASES += test_vspliceb.tst
+
+all: build
+
+%.o: $(TSRC_PATH)/%.c
+	$(CC) $(C_CFLAGS) -c $< -o $@
+
+%.o: $(TSRC_PATH)/%.s
+	$(CC) $(ASM_CFLAGS) -c $< -o $@
+
+%.tst: %.o $(CRT)
+	$(CC) $(LDFLAGS) $(NOSTDFLAGS) $(CRT) $(CRT_STANDALONE) $< -o $@
+
+build: $(TESTCASES)
+
+check: $(TESTCASES:test_%.tst=check_%)
+
+check_%: test_%.tst test_file.txt
+	@echo "Running test: "$<
+	@rm -rf opendir_test_folder mkdir_test_folder rmdir_test_folder
+	@if [ "$<" = "test_sys_readc.tst" ]; then\
+		echo "#\n" | $(SIM) $(SIMFLAGS) $<; \
+	 else \
+	 	$(SIM) $(SIMFLAGS) $<; \
+	 fi;
+
+reference: $(TESTCASES:test_%.tst=reference_%)
+
+reference_%: test_%.tst test_file.txt
+	@echo "Running reference test: "$<
+	@rm -rf opendir_test_folder mkdir_test_folder rmdir_test_folder
+	@if [ "$<" = "test_sys_readc.tst" ]; then\
+		echo "#\n" | $(REF) $(SIMFLAGS) $<; \
+	 else \
+	 	$(REF) $(REFFLAGS) $<; \
+		grep "r01\s*:\s*0x00000000.*r03\s*:\s*0xdeadb00b" trace.log; \
+	 fi;
+
+test_file.txt:
+	@echo "Creating test files"
+	@echo "Thank you Fabrice!" > test_file.txt
+
+clean:
+	$(RM) -fr $(TESTCASES) $(CRT) $(HELPER) *.core trunc_test_file.txt \
+    trace.log opendir_test_folder mkdir_test_folder rmdir_test_folder \
+	pmu_statsfile.txt test_file.txt
diff --git a/tests/tcg/hexagon/crt.s b/tests/tcg/hexagon/crt.s
new file mode 100644
index 0000000000..f888faed3d
--- /dev/null
+++ b/tests/tcg/hexagon/crt.s
@@ -0,0 +1,47 @@
+    .text
+    .globl init
+init:
+    {
+        allocframe(r29,#0):raw
+    }
+    {
+        r0=#256
+    }
+    {
+        evb=r0
+    }
+    {
+        dealloc_return
+    }
+
+    .space 240
+
+EventVector:
+    { rte }
+    { rte }
+    { rte }
+    { rte }
+    { rte }
+    { rte }
+    { rte }
+    { rte }
+    { rte }
+    { rte }
+
+    .globl pass
+pass:
+    { r0=#24 }
+    { 
+        r1 = #0
+        r3 = #3735924747
+    }
+    { trap0(#0) }
+
+    .globl fail
+fail:
+    { r0=#24 }
+    {
+        r1 = #1
+        r3 = #3735924747
+    }
+    { trap0(#0) }
diff --git a/tests/tcg/hexagon/test_abs.s b/tests/tcg/hexagon/test_abs.s
new file mode 100644
index 0000000000..b9f72f5394
--- /dev/null
+++ b/tests/tcg/hexagon/test_abs.s
@@ -0,0 +1,20 @@
+# Purpose: test example, verify the soundness of the abs operation
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+	{
+		r1=#-2
+		r2=#2
+	}
+	{
+		r3=abs(r1)
+	}
+    {
+        p0 = cmp.eq(r3, r2); if (p0.new) jump:t pass
+        jump fail
+    }
diff --git a/tests/tcg/hexagon/test_add.s b/tests/tcg/hexagon/test_add.s
new file mode 100644
index 0000000000..92d7adc9a4
--- /dev/null
+++ b/tests/tcg/hexagon/test_add.s
@@ -0,0 +1,20 @@
+# Purpose: test example, verify the soundness of the add operation
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+	{
+		r1=#0
+		r2=#0
+	}
+	{
+		r3=add(r2,r3)
+	}
+    {
+        p0 = cmp.eq(r3, #0); if (p0.new) jump:t pass
+        jump fail
+    }
diff --git a/tests/tcg/hexagon/test_andp.s b/tests/tcg/hexagon/test_andp.s
new file mode 100644
index 0000000000..f596be375c
--- /dev/null
+++ b/tests/tcg/hexagon/test_andp.s
@@ -0,0 +1,22 @@
+# Purpose: test a multiple predicate AND combination
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+    {
+        r0=#0
+        r1=#1
+    }
+	{
+        p0=cmp.gt(r0,r1)
+        p0=cmp.gt(r0,r1)
+        p0=cmp.gt(r1,r0)
+    }
+    {
+        if (!p0) jump:t pass
+        jump fail
+    }
diff --git a/tests/tcg/hexagon/test_bitcnt.s b/tests/tcg/hexagon/test_bitcnt.s
new file mode 100644
index 0000000000..8d9d5b431e
--- /dev/null
+++ b/tests/tcg/hexagon/test_bitcnt.s
@@ -0,0 +1,42 @@
+# Purpose: test example, verify the soundness of the cl[01] operations
+# 
+# the number 0x000001aa has 23 leading zeroes
+# they become 55 when considered as 64 bit register
+# and it has 1 trailing zero
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+	{
+		r0=#426
+        r1=#0
+    }
+	{
+        r2=cl0(r0)
+	}
+    {
+        p0 = cmp.eq(r2, #23); if (p0.new) jump:t test2
+        jump fail
+    }
+
+test2:
+	{
+        r2=cl0(r1:0)
+	}
+    {
+        p0 = cmp.eq(r2, #55); if (p0.new) jump:t test3
+        jump fail
+    }
+
+test3:
+	{
+        r2=ct0(r0)
+	}
+    {
+        p0 = cmp.eq(r2, #1); if (p0.new) jump:t pass
+        jump fail
+    }
diff --git a/tests/tcg/hexagon/test_bitsplit.s b/tests/tcg/hexagon/test_bitsplit.s
new file mode 100644
index 0000000000..c2bb28d80d
--- /dev/null
+++ b/tests/tcg/hexagon/test_bitsplit.s
@@ -0,0 +1,25 @@
+# Purpose: test example, verify the soundness of the bitsplit operation
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+	{
+		r1=#187
+	}
+	{
+		r3:2=bitsplit(r1, #3)
+	}
+    {
+        p0 = cmp.eq(r2, #3); if (p0.new) jump:t test2
+        jump fail
+    }
+
+test2:
+    {
+        p0 = cmp.eq(r3, #23); if (p0.new) jump:t pass
+        jump fail
+    }
diff --git a/tests/tcg/hexagon/test_call.s b/tests/tcg/hexagon/test_call.s
new file mode 100644
index 0000000000..32ddd77c34
--- /dev/null
+++ b/tests/tcg/hexagon/test_call.s
@@ -0,0 +1,59 @@
+// Purpose: test function calls and duplex instructions. The string "Hello there, I'm a test string!" with the first letter replaced with a capital L should be printed out.
+
+    .text
+	.globl	test
+test:                                   // @test
+	{
+		jumpr r31
+		memb(r0+#0)=#76
+	}
+.Lfunc_end0:
+.Ltmp0:
+	.size	test, .Ltmp0-test
+
+	.globl	_start
+_start:                                 // @_start
+    {
+        call init
+    }
+	{
+		call test
+		r0=##dummy_buffer
+		allocframe(#0)
+	}
+	{
+		call write
+	}
+    {
+        jump pass
+    }
+	{
+		r31:30=deallocframe(r30):raw
+	}
+.Lfunc_end1:
+.Ltmp1:
+	.size	_start, .Ltmp1-_start
+write:                                  // @write
+	{
+		r2=##dummy_buffer
+	}
+	{ r0=r2; }
+	{
+		r2=#256
+	}
+	{ r1=r2; }
+	{ trap0(#7); }
+	{
+		jumpr r31
+	}
+.Lfunc_end2:
+.Ltmp2:
+	.size	write, .Ltmp2-write
+
+	.type	dummy_buffer,@object    // @dummy_buffer
+	.data
+	.globl	dummy_buffer
+	.p2align	3
+dummy_buffer:
+	.string	"Hello there, I'm a test string!\n\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
+	.size	dummy_buffer, 256
diff --git a/tests/tcg/hexagon/test_clobber.s b/tests/tcg/hexagon/test_clobber.s
new file mode 100644
index 0000000000..85a78422eb
--- /dev/null
+++ b/tests/tcg/hexagon/test_clobber.s
@@ -0,0 +1,32 @@
+# Purpose: demonstrate the succesful operation of the register save mechanism, in which the caller saves the registers that will be clobbered, and restores them after the call.
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+    {
+        r16=#47
+        r17=#155
+    }
+    {
+        memd(r29+#-16)=r17:16; allocframe(#8)
+    }
+    {
+        r16=#255
+        r17=#42
+    }
+    {
+        r17:16=memd(r29+#0); deallocframe
+    }
+	{
+		r3=add(r16,r17)
+	}
+    {
+        p0 = cmp.eq(r3, #202); if (p0.new) jump:t pass
+    }
+    {
+        jump fail
+    }
diff --git a/tests/tcg/hexagon/test_cmp.s b/tests/tcg/hexagon/test_cmp.s
new file mode 100644
index 0000000000..7f572b24c3
--- /dev/null
+++ b/tests/tcg/hexagon/test_cmp.s
@@ -0,0 +1,34 @@
+# Purpose: test a signed and unsigned comparison
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+    {
+        jump signed
+    }
+
+    .globl signed
+signed:
+	{
+        r0=#-2
+		r1=#0
+	}
+    {
+        p0 = cmp.lt(r0, r1); if (p0.new) jump:t unsigned
+        jump fail
+    }
+
+    .globl unsigned
+unsigned:
+	{
+        r0=#-2
+		r1=#0
+	}
+    {
+        p0 = cmp.gtu(r0, r1); if (p0.new) jump:t pass
+        jump fail
+    }
diff --git a/tests/tcg/hexagon/test_cmpy.s b/tests/tcg/hexagon/test_cmpy.s
new file mode 100644
index 0000000000..a76a184755
--- /dev/null
+++ b/tests/tcg/hexagon/test_cmpy.s
@@ -0,0 +1,29 @@
+# Purpose: test example, verify the soundness of the cmpy operation
+# 
+#                       3j+5 * 2j+4 = 22j+14
+# the complex multiply between  0x00030005 and 0x00020004 is 0x000000160000000e
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+	{
+		r0=#196613
+        r1=#131076
+    }
+	{
+        r3:2=cmpy(r0, r1):sat
+	}
+    {
+        p0 = cmp.eq(r2, #14); if (p0.new) jump:t test2
+        jump fail
+    }
+
+test2:
+    {
+        p0 = cmp.eq(r3, #22); if (p0.new) jump:t pass
+        jump fail
+    }
diff --git a/tests/tcg/hexagon/test_djump.s b/tests/tcg/hexagon/test_djump.s
new file mode 100644
index 0000000000..24b3dafa51
--- /dev/null
+++ b/tests/tcg/hexagon/test_djump.s
@@ -0,0 +1,19 @@
+# Purpose: show dual jumps actually work. This program features a packet where two jumps should (in theory) be performed if !P0. However, we correctly handle the situation by performing only the first one and ignoring the second one. This can be verified by checking that the CPU dump contains 0xDEADBEEF in R2.
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+    {
+        r1 = #255;
+    }
+    {
+        p0 = r1;
+    }
+	{
+        if (p0) jump:t pass
+        jump fail
+	}
diff --git a/tests/tcg/hexagon/test_dotnew.s b/tests/tcg/hexagon/test_dotnew.s
new file mode 100644
index 0000000000..ed26b32505
--- /dev/null
+++ b/tests/tcg/hexagon/test_dotnew.s
@@ -0,0 +1,37 @@
+// Purpose: test the .new operator while performing memory stores. In the final CPU dump R0 should contain 3, R1 should contain 2 and R2 should contain 1.
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+	{
+		r0=#1
+		memw(sp+#0)=r0.new
+	}
+	{
+		r1=#2
+		memw(sp+#4)=r1.new
+	}
+	{
+		r2=#3
+		memw(sp+#8)=r2.new
+	}
+	{
+		r0=memw(sp+#8)
+	}
+	{
+		r1=memw(sp+#4)
+	}
+	{
+		r2=memw(sp+#0)
+	}
+	{
+		r3=mpyi(r1,r2)
+	}
+    {
+        p0 = cmp.eq(r3, #2); if (p0.new) jump:t pass
+        jump fail
+    }
diff --git a/tests/tcg/hexagon/test_dstore.s b/tests/tcg/hexagon/test_dstore.s
new file mode 100644
index 0000000000..f204cd1b0c
--- /dev/null
+++ b/tests/tcg/hexagon/test_dstore.s
@@ -0,0 +1,24 @@
+# Purpose: test dual stores correctness. In this example the values 1 and 2 are both written on the top of the stack in a single packet. The value is then read back in R3, which should contain only the latest value written (2).
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+	{
+		r0=#1
+		r1=#2
+	}
+	{
+		memw(sp+#0)=r0
+		memw(sp+#0)=r1
+	}
+	{
+		r3=memw(sp+#0)
+	}
+    {
+        p0 = cmp.eq(r3, #2); if (p0.new) jump:t pass
+        jump fail
+    }
diff --git a/tests/tcg/hexagon/test_ext.s b/tests/tcg/hexagon/test_ext.s
new file mode 100644
index 0000000000..c22fe3d8ff
--- /dev/null
+++ b/tests/tcg/hexagon/test_ext.s
@@ -0,0 +1,16 @@
+// Purpose: test immediate extender instructions. In the CPU dump R0 should contain 0xDEADBEEF.
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+	{
+		r2=##-559038737
+	}
+    {
+        p0 = cmp.eq(r2, ##-559038737); if (p0.new) jump:t pass
+        jump fail
+    }
diff --git a/tests/tcg/hexagon/test_fibonacci.s b/tests/tcg/hexagon/test_fibonacci.s
new file mode 100644
index 0000000000..2d7f4944c3
--- /dev/null
+++ b/tests/tcg/hexagon/test_fibonacci.s
@@ -0,0 +1,33 @@
+# Purpose: computes the Fibonacci series up to a constant number.
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+	{
+		r2=#100
+	}
+	{
+		p0=cmp.gt(r2,#0); if (!p0.new) jump:nt .LBB0_3
+	}
+	{
+		r3=#0
+		r4=#1
+	}
+.LBB0_2:                                // %while.body
+	{
+		r5=r4
+	}
+	{
+		p0=cmp.gt(r2,r5); if (p0.new) jump:nt .LBB0_2
+		r4=add(r3,r4)
+		r3=r5
+	}
+.LBB0_3:                                // %while.end
+    {
+        p0 = cmp.eq(r3, #144); if (p0.new) jump:t pass
+        jump fail
+    }
diff --git a/tests/tcg/hexagon/test_hello.s b/tests/tcg/hexagon/test_hello.s
new file mode 100644
index 0000000000..cd34af15c7
--- /dev/null
+++ b/tests/tcg/hexagon/test_hello.s
@@ -0,0 +1,21 @@
+// Purpose: simple hello world program.
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+	{ r0=#4; }
+	{
+		r1=##.L.str
+	}
+	{ trap0(#0); }
+    {
+        jump pass
+    }
+
+.L.str:
+	.string	"Hello world!\n"
+	.size	.L.str, 14
diff --git a/tests/tcg/hexagon/test_hl.s b/tests/tcg/hexagon/test_hl.s
new file mode 100644
index 0000000000..1ce1581e44
--- /dev/null
+++ b/tests/tcg/hexagon/test_hl.s
@@ -0,0 +1,19 @@
+# Purpose: test example, verify the soundness of the high/low assignment
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+	{
+		r0.H=#42
+    }
+    {
+		r0.L=#69
+	}
+    {
+        p0 = cmp.eq(r0, #2752581); if (p0.new) jump:t pass
+        jump fail
+    }
diff --git a/tests/tcg/hexagon/test_hwloops.s b/tests/tcg/hexagon/test_hwloops.s
new file mode 100644
index 0000000000..67d8d96fc4
--- /dev/null
+++ b/tests/tcg/hexagon/test_hwloops.s
@@ -0,0 +1,24 @@
+// Purpose: simple C Program to test hardware loops. It should print numbers from 0 to 9.
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+	{
+		loop0(.LBB0_1,#10)
+		r2=#0
+	}
+.Ltmp0:                                 // Block address taken
+.LBB0_1:                                // %for.body
+                                        // =>This Inner Loop Header: Depth=1
+	{
+		r2=add(r2,#1)
+		nop
+	}:endloop0
+    {
+        p0 = cmp.eq(r2, #10); if (p0.new) jump:t pass
+        jump fail
+    }
diff --git a/tests/tcg/hexagon/test_jmp.s b/tests/tcg/hexagon/test_jmp.s
new file mode 100644
index 0000000000..c2607f4710
--- /dev/null
+++ b/tests/tcg/hexagon/test_jmp.s
@@ -0,0 +1,25 @@
+# Purpose: test example, verify the soundness of the add operation
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+	{
+		r1=#0
+		r2=#0
+	}
+	{
+		r3=add(r2,r3)
+	}
+    {
+        p0 = cmp.eq(r3, #0)
+    }
+    {
+        if (p0) jump:t pass
+    }
+    {
+        jump fail
+    }
diff --git a/tests/tcg/hexagon/test_lsr.s b/tests/tcg/hexagon/test_lsr.s
new file mode 100644
index 0000000000..7aec37202d
--- /dev/null
+++ b/tests/tcg/hexagon/test_lsr.s
@@ -0,0 +1,39 @@
+# Purpose: test the soundness of the lsr operation
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+	{
+		r0=#0xffff2168
+		r1=#0x7fffffff
+	}
+    {
+        r2=#0x19
+    }
+	{
+		r0&=lsr(r1, r2)
+	}
+    {
+        p0 = cmp.eq(r0, #0x28); if (p0.new) jump:t test2
+        jump fail
+    }
+
+test2:
+	{
+		r0=#0x0000000a
+		r1=#0x00000000
+	}
+    {
+        r2=#0xffffffff
+    }
+    {
+        r1:0=lsl(r1:0, r2)
+    }
+    {
+        p0 = cmp.eq(r0, #0x5); if (p0.new) jump:t pass
+        jump fail
+    }
diff --git a/tests/tcg/hexagon/test_mem.s b/tests/tcg/hexagon/test_mem.s
new file mode 100644
index 0000000000..977752b532
--- /dev/null
+++ b/tests/tcg/hexagon/test_mem.s
@@ -0,0 +1,78 @@
+# Purpose: verify the soundness of several memory loads and stores
+# 
+# First fill up a buffer with known patterns:
+# 0baabbccdd and 0x00112233, then test loads
+
+# Set the buffer parameters:
+# K = 0, I = 1; Length = 3
+# M0 = 0000 0000 0000001 00000000000000011 = 131075
+#     I(MSB) K    I(LSB)      Length
+#
+# C12 is CS0 and must be set to the start address of the circular buffer
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+    {
+        r1=#0
+        r0=#131075
+    }
+    {
+        m0 = r0
+    }
+    {
+        r0=##buffer
+    }
+	{
+        memw(r0) = #2864434397
+    }
+    {
+        r1=memb(r0++#1)
+    }
+    {
+        p0 = cmp.eq(r1, #4294967261); if (p0.new) jump:t test2
+        jump fail
+    }
+
+test2:
+    {
+        r1=memb(r0++#1)
+    }
+    {
+        p0 = cmp.eq(r1, #4294967244); if (p0.new) jump:t test3
+        jump fail
+    }
+
+test3:
+    {
+        r0 = ##buffer
+    }
+    {
+        c12 = r0
+    }
+    {
+        r3=memb(r0++#1:circ(M0))
+    }
+    {
+        r3=memb(r0++#1:circ(M0))
+    }
+    {
+        r3=memb(r0++#1:circ(M0))
+    }
+    {
+        r3=memb(r0++#1:circ(M0))
+    }
+    {
+        p0 = cmp.eq(r3, #4294967261); if (p0.new) jump:t pass
+        jump fail
+    }
+
+    .data
+    .globl buffer
+buffer:
+    .space 32
+    .size buffer, 32
diff --git a/tests/tcg/hexagon/test_mpyi.s b/tests/tcg/hexagon/test_mpyi.s
new file mode 100644
index 0000000000..2296faf209
--- /dev/null
+++ b/tests/tcg/hexagon/test_mpyi.s
@@ -0,0 +1,20 @@
+# Purpose: test a simple multiplication operation
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+	{
+		r1=#4
+		r2=#6
+	}
+	{
+		r3=mpyi(r1,r2)
+	}
+    {
+        p0 = cmp.eq(r3, #24); if (p0.new) jump:t pass
+        jump fail
+    }
diff --git a/tests/tcg/hexagon/test_packet.s b/tests/tcg/hexagon/test_packet.s
new file mode 100644
index 0000000000..b5da11314a
--- /dev/null
+++ b/tests/tcg/hexagon/test_packet.s
@@ -0,0 +1,24 @@
+# Purpose: test that writes of a register in a packet are performed only after that packet has finished its execution.
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+	{
+		r2=#4
+		r3=#6
+	}
+	{
+		memw(sp+#0)=r2
+	}
+	{
+		r3=memw(sp+#0)
+		r0=add(r2,r3)
+	}
+    {
+        p0 = cmp.eq(r0, #10); if (p0.new) jump:t pass
+        jump fail
+    }
diff --git a/tests/tcg/hexagon/test_reorder.s b/tests/tcg/hexagon/test_reorder.s
new file mode 100644
index 0000000000..7a3aa9b4cc
--- /dev/null
+++ b/tests/tcg/hexagon/test_reorder.s
@@ -0,0 +1,24 @@
+# Purpose: demonstrate handling of .new uses appearing before the associated definition. Here we perform a jump that skips the code resetting R2 from 0xDEADBEEF to 0, only if P0.new is true, but P0 is assigned to 1 (R4) in the next instruction in the packet. A successful run of the program will show R2 retaining the 0xDEADBEEF value in the CPU dump.
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+    { r2=#0xdeadbeef }
+    { r4=#1 }
+    {
+		if (p0.new) jump:nt skip
+	    p0=r4;
+	}
+
+fallthrough:
+	{ r2=#0 }
+
+skip:
+    {
+        p0 = cmp.eq(r2, #0xdeadbeef); if (p0.new) jump:t pass
+        jump fail
+    }
diff --git a/tests/tcg/hexagon/test_round.s b/tests/tcg/hexagon/test_round.s
new file mode 100644
index 0000000000..659b49022a
--- /dev/null
+++ b/tests/tcg/hexagon/test_round.s
@@ -0,0 +1,40 @@
+# Purpose: test example, verify the soundness of the cround operation
+# 106 = 0b1101010 with the comma at third digit is 12.5 which is crounded to 12
+# but rounded to 13
+
+# 0b1100,1000
+#    0b0,1000
+#   if x == 0b1,1000
+#       x+=1
+
+# x += (extract(x, u-1, 1) | ((x << shamt)>>shamt) == 0b0,1000)) << (u-1)
+# deposit(x, x, 0, u, u)
+
+# if 
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+	{
+		r1=#200
+	}
+	{
+        r2=round(r1, #4)
+	}
+    {
+        p0 = cmp.eq(r2, #13); if (p0.new) jump:t test2
+        jump fail
+    }
+
+test2:
+    {
+        r2=cround(r1, #4)
+    }
+    {
+        p0 = cmp.eq(r2, #12); if (p0.new) jump:t pass
+        jump fail
+    }
diff --git a/tests/tcg/hexagon/test_sys_access.s b/tests/tcg/hexagon/test_sys_access.s
new file mode 100644
index 0000000000..6c0123d214
--- /dev/null
+++ b/tests/tcg/hexagon/test_sys_access.s
@@ -0,0 +1,39 @@
+# Purpose: sys_access syscall test, the current file should be readable but not executable
+
+    .text
+    .globl _start
+_start:
+    {
+        call init
+    }
+# sys_open syscall
+    {
+        allocframe(r29,#16):raw
+    }
+    {
+        r0=##.L.str
+    }
+    {
+        r1=#4
+        memw(r29+#0)=r0
+    }
+    {
+        memw(r29+#4)=r1
+    }
+	{
+        r0=#261
+        r1=r29
+	}
+	{
+        trap0(#0)
+	}
+    {
+        p0 = cmp.eq(r0, #0); if (p0.new) jump:t pass
+        jump fail
+    }
+
+.data
+
+.L.str:
+	.string	"./test_sys_access.tst"
+	.size	.L.str, 19
diff --git a/tests/tcg/hexagon/test_sys_clock.s b/tests/tcg/hexagon/test_sys_clock.s
new file mode 100644
index 0000000000..9aed9cb982
--- /dev/null
+++ b/tests/tcg/hexagon/test_sys_clock.s
@@ -0,0 +1,20 @@
+# Purpose: sys_clock usage example, as a result of the syscall, the register r0 should
+# contain the number of centiseconds since the execution started.
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+	{
+        r0=#16;
+	}
+	{
+        trap0(#0);
+	}
+    {
+        p0 = !cmp.eq(r0, #-1); if (p0.new) jump:t pass
+        jump fail
+    }
diff --git a/tests/tcg/hexagon/test_sys_close.s b/tests/tcg/hexagon/test_sys_close.s
new file mode 100644
index 0000000000..0af8088dc7
--- /dev/null
+++ b/tests/tcg/hexagon/test_sys_close.s
@@ -0,0 +1,56 @@
+# Purpose: sys_close syscall test, on success, 0 is returned
+
+    .text
+    .globl _start
+    .set len, 20
+
+_start:
+    {
+        call init
+    }
+# sys_open syscall
+    {
+        allocframe(r29,#16):raw
+    }
+    {
+        r0=##.L.str
+    }
+    {
+        r1=#0
+        memw(r29+#0)=r0
+    }
+    {
+        r2=#len
+        memw(r29+#4)=r1
+    }
+    {
+        memw(r29+#8)=r2
+    }
+	{
+        r0=#1  
+        r1=r29
+	}
+	{
+        trap0(#0)
+	}
+# sys_close syscall
+    {
+        memw(r29+#0)=r0
+    }
+    {
+        r0=#2
+        r1=r29
+    }
+    {
+        trap0(#0)
+    }
+    {
+        p0 = cmp.eq(r0, #0); if (p0.new) jump:t pass
+        jump fail
+    }
+
+.data
+
+.L.str:
+	.string	"./test_sys_close.tst"
+	.size	.L.str, len
diff --git a/tests/tcg/hexagon/test_sys_cmdline.s b/tests/tcg/hexagon/test_sys_cmdline.s
new file mode 100644
index 0000000000..63275a93ba
--- /dev/null
+++ b/tests/tcg/hexagon/test_sys_cmdline.s
@@ -0,0 +1,55 @@
+# Purpose: sys_get_cmdline test, on success the command string is returned
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+# sys_get_cmdline syscall
+    {
+        allocframe(r29,#16):raw
+    }
+    {
+        r0=##.L.buf
+    }
+    {
+        r1=#33
+        memw(r29+#0)=r0
+    }
+    {
+        memw(r29+#4)=r1
+    }
+	{
+        r0=#21
+        r1=r29
+	}
+	{
+        trap0(#0)
+	}
+    {
+        p0 = cmp.eq(r0, #0); if (p0.new) jump:t print
+        jump fail
+    }
+
+print:
+    {
+        r0=#4
+        r1=##.L.buf
+    }
+    {
+        trap0(#0)
+    }
+    {
+        jump pass
+    }
+
+.data
+
+.L.str:
+	.string	"./test_sys_read.s"
+	.size	.L.str, 18
+
+.L.buf:
+    .skip 33
diff --git a/tests/tcg/hexagon/test_sys_fcntl.s b/tests/tcg/hexagon/test_sys_fcntl.s
new file mode 100644
index 0000000000..5fb7556a51
--- /dev/null
+++ b/tests/tcg/hexagon/test_sys_fcntl.s
@@ -0,0 +1,86 @@
+# Purpose: sys_fcntl syscall test, on success, the target command is executed
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+# sys_open syscall
+    {
+        allocframe(r29,#32):raw
+    }
+    {
+        r0=##.L.str
+    }
+    {
+        r1=#0
+        memw(r29+#0)=r0
+    }
+    {
+        r2=#18
+        memw(r29+#4)=r1
+    }
+    {
+        memw(r29+#8)=r2
+    }
+	{
+        r0=#1  
+        r1=r29
+	}
+	{
+        trap0(#0)
+	}
+# sys_fcntl syscall to duplicate a file descriptor
+    {
+        r1=#0x40404040
+        memw(r29+#0)=r1.new
+    }
+    {
+        r1=#0x41414141
+        memw(r29+#4)=r1.new
+    }
+    {
+        r1=#0x42424242
+        memw(r29+#8)=r1.new
+    }
+    {
+        r1=#0x43434343
+        memw(r29+#12)=r1.new
+    }
+# Parametri veri
+    {
+        memw(r29+#16)=r0
+    }
+    {
+        r1=#0
+        memw(r29+#20)=r1.new
+    }
+    {
+        r1=add(r29, #16);
+        memw(r29+#24)=r29;
+    }
+    {
+        r0=#262
+    }
+    {
+        trap0(#0)
+    }
+# compare the first read character, should be a hash symbol
+    {
+        r0=memb(##.L.buf)
+    }
+    {
+        p0 = cmp.eq(r0, #35); if (p0.new) jump:t pass
+        jump fail
+    }
+
+.data
+
+.L.str:
+	.string	"./test_sys_read.s"
+	.size	.L.str, 18
+
+.L.buf:
+    .skip 33
diff --git a/tests/tcg/hexagon/test_sys_flen.s b/tests/tcg/hexagon/test_sys_flen.s
new file mode 100644
index 0000000000..954bf24aae
--- /dev/null
+++ b/tests/tcg/hexagon/test_sys_flen.s
@@ -0,0 +1,53 @@
+# Purpose: sys_flen syscall test, on success, the file length is returned
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+# sys_open syscall
+    {
+        allocframe(r29,#16):raw
+    }
+    {
+        r0=##.L.str
+    }
+    {
+        r1=#0
+        memw(r29+#0)=r0
+    }
+    {
+        r2=#16
+        memw(r29+#4)=r1
+    }
+    {
+        memw(r29+#8)=r2
+    }
+	{
+        r0=#1  
+        r1=r29
+	}
+	{
+        trap0(#0)
+	}
+# sys_flen syscall
+    {
+        memw(r29+#0)=r0
+    }
+	{
+        r0=#12
+        r1=r29
+	}
+	{
+        trap0(#0)
+	}
+    {
+        p0 = cmp.eq(r0, #19); if (p0.new) jump:t pass
+        jump fail
+    }
+
+.L.str:
+	.string	"test_file.txt"
+	.size	.L.str, 13
diff --git a/tests/tcg/hexagon/test_sys_ftell.s b/tests/tcg/hexagon/test_sys_ftell.s
new file mode 100644
index 0000000000..78197f4072
--- /dev/null
+++ b/tests/tcg/hexagon/test_sys_ftell.s
@@ -0,0 +1,99 @@
+# Purpose: sys_ftell syscall test, on success, the position inside the file is returned
+
+    .text
+    .globl _start
+    .set len, 20
+
+_start:
+    {
+        call init
+    }
+# sys_open syscall
+    {
+        allocframe(r29,#16):raw
+    }
+    {
+        r0=##.L.str
+    }
+    {
+        r1=#0
+        memw(r29+#0)=r0
+    }
+    {
+        r2=#len
+        memw(r29+#4)=r1
+    }
+    {
+        memw(r29+#8)=r2
+    }
+	{
+        r0=#1  
+        r1=r29
+	}
+	{
+        trap0(#0)
+	}
+# Initial position should be 0
+    {
+        r28=r0
+        memw(r29+#0)=r0
+    }
+    {
+        r0=#256
+        r1=r29
+    }
+    {
+        trap0(#0)
+    }
+    {
+        p0 = cmp.eq(r0, #0); if (p0.new) jump:t test2
+        jump fail
+    }
+
+test2:
+# Read a single character through sys_read
+    {
+        memw(r29+#0)=r28
+    }
+    {
+        r1=##.L.buf1
+        memw(r29+#4)=r1.new;
+    }
+    {
+        r2=#1
+        memw(r29+#8)=r2.new;
+    }
+    {
+        r0=#6
+        r1=r29
+    }
+    {
+        trap0(#0)
+    }
+# Now the position should be 1
+    {
+        memw(r29+#0)=r28
+    }
+    {
+        r0=#256
+        r1=r29
+    }
+    {
+        trap0(#0)
+    }
+    {
+        p0 = cmp.eq(r0, #1); if (p0.new) jump:t pass
+        jump fail
+    }
+
+.data
+
+.L.str:
+	.string	"./test_sys_ftell.tst"
+	.size	.L.str, len
+
+.L.buf1:
+    .skip 4
+
+.L.buf2:
+    .skip 4
diff --git a/tests/tcg/hexagon/test_sys_ftrunc.s b/tests/tcg/hexagon/test_sys_ftrunc.s
new file mode 100644
index 0000000000..9552059792
--- /dev/null
+++ b/tests/tcg/hexagon/test_sys_ftrunc.s
@@ -0,0 +1,109 @@
+# Purpose: sys_trunc syscall test, on success, the target file should change its size
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+# Open a new file in write mode
+    {
+        allocframe(r29,#16):raw
+    }
+    {
+        r0=##.L.str
+    }
+    {
+        r1=#4
+        memw(r29+#0)=r0
+    }
+    {
+        r2=#22
+        memw(r29+#4)=r1
+    }
+    {
+        memw(r29+#8)=r2
+    }
+	{
+        r0=#1  
+        r1=r29
+	}
+	{
+        trap0(#0)
+	}
+# Extend the file to 64B
+    {
+        r28=r0
+        memw(r29+#0)=r0
+    }
+    {
+        r2=#64
+        memw(r29+#4)=r2.new
+    }
+    {
+        r0=#390
+        r1=r29
+    }
+    {
+        trap0(#0)
+    }
+# Check that file length is exactly 64B
+    {
+        memw(r29+#0)=r28
+    }
+	{
+        r0=#12
+        r1=r29
+	}
+	{
+        trap0(#0)
+	}
+    {
+        p0 = cmp.eq(r0, #64); if (p0.new) jump:t test2
+        jump fail
+    }
+
+test2:
+# Truncate the file to 12B
+    {
+        memw(r29+#0)=r28
+    }
+    {
+        r2=#12
+        memw(r29+#4)=r2.new
+    }
+    {
+        r0=#390
+        r1=r29
+    }
+    {
+        trap0(#0)
+    }
+# Check that file length is exactly 12B
+    {
+        memw(r29+#0)=r28
+    }
+	{
+        r0=#12
+        r1=r29
+	}
+	{
+        trap0(#0)
+	}
+    {
+        p0 = cmp.eq(r0, #12); if (p0.new) jump:t pass
+        jump fail
+    }
+
+.data
+
+.L.str:
+	.string	"./trunc_test_file.txt"
+	.size	.L.str, 22
+
+.L.buf1:
+    .skip 4
+
+.L.buf2:
+    .skip 4
diff --git a/tests/tcg/hexagon/test_sys_getcwd.s b/tests/tcg/hexagon/test_sys_getcwd.s
new file mode 100644
index 0000000000..a6a475dcb1
--- /dev/null
+++ b/tests/tcg/hexagon/test_sys_getcwd.s
@@ -0,0 +1,55 @@
+# Purpose: sys_getcwd test, on success the current working directory is returned
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+# sys_getcwd syscall
+    {
+        allocframe(r29,#16):raw
+    }
+    {
+        r0=##.L.buf
+    }
+    {
+        r1=#260
+        memw(r29+#0)=r0
+    }
+    {
+        memw(r29+#4)=r1
+    }
+	{
+        r0=#260
+        r1=r29
+	}
+	{
+        trap0(#0)
+	}
+    {
+        p0 = !cmp.eq(r0, #-1); if (p0.new) jump:t print
+        jump fail
+    }
+
+print:
+    {
+        r0=#4
+        r1=##.L.buf
+    }
+    {
+        trap0(#0)
+    }
+    {
+        jump pass
+    }
+
+.data
+
+.L.str:
+	.string	"./test_sys_getcwd.s"
+	.size	.L.str, 18
+
+.L.buf:
+    .skip 33
diff --git a/tests/tcg/hexagon/test_sys_gettimeofday.s b/tests/tcg/hexagon/test_sys_gettimeofday.s
new file mode 100644
index 0000000000..69abc123ad
--- /dev/null
+++ b/tests/tcg/hexagon/test_sys_gettimeofday.s
@@ -0,0 +1,34 @@
+# Purpose: sys_gettimeofday usage example, as a result of the syscall,
+# the date and time struct is returned
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+# sys_get_cmdline syscall
+    {
+        allocframe(r29,#16):raw
+    }
+    {
+        r0=##.L.buf
+        memw(r29+#0)=r0.new
+    }
+	{
+        r0=#263
+        r1=r29
+	}
+	{
+        trap0(#0)
+	}
+    {
+        p0 = !cmp.eq(r1, #0); if (p0.new) jump:t pass
+        jump fail
+    }
+
+.data
+
+.L.buf:
+    .skip 16
diff --git a/tests/tcg/hexagon/test_sys_heapinfo.s b/tests/tcg/hexagon/test_sys_heapinfo.s
new file mode 100644
index 0000000000..80e7676b7f
--- /dev/null
+++ b/tests/tcg/hexagon/test_sys_heapinfo.s
@@ -0,0 +1,33 @@
+# Purpose: sys_get_cmdline test, on success the command string is returned
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+# sys_get_cmdline syscall
+    {
+        allocframe(r29,#16):raw
+    }
+    {
+        r0=##.L.buf
+        memw(r29+#0)=r0.new
+    }
+	{
+        r0=#22
+        r1=r29
+	}
+	{
+        trap0(#0)
+	}
+    {
+        p0 = !cmp.eq(r0, #-1); if (p0.new) jump:t pass
+        jump fail
+    }
+
+.data
+
+.L.buf:
+    .skip 16
diff --git a/tests/tcg/hexagon/test_sys_istty.s b/tests/tcg/hexagon/test_sys_istty.s
new file mode 100644
index 0000000000..31d974dbae
--- /dev/null
+++ b/tests/tcg/hexagon/test_sys_istty.s
@@ -0,0 +1,102 @@
+# Purpose: sys_isatty syscall test, distinguish a tty from a file
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+# sys_open syscall
+    {
+        allocframe(r29,#16):raw
+    }
+    {
+        r0=##.L.str
+    }
+    {
+        r1=#0
+        memw(r29+#0)=r0
+    }
+    {
+        r2=#16
+        memw(r29+#4)=r1
+    }
+    {
+        memw(r29+#8)=r2
+    }
+	{
+        r0=#1  
+        r1=r29
+	}
+	{
+        trap0(#0)
+	}
+
+test1:
+# negative sys_isatty syscall
+    {
+        memw(r29+#0)=r0
+    }
+    {
+        r0=#9
+        r1=r29
+    }
+    {
+        trap0(#0)
+    }
+    {
+        p0 = cmp.eq(r0, #0); if (p0.new) jump:t test2
+        jump fail
+    }
+
+test2:
+# positive sys_isatty syscall
+    {
+        r0=##.L.tty
+    }
+    {
+        r1=#0
+        memw(r29+#0)=r0
+    }
+    {
+        r2=#16
+        memw(r29+#4)=r1
+    }
+    {
+        memw(r29+#8)=r2
+    }
+	{
+        r0=#1  
+        r1=r29
+	}
+	{
+        trap0(#0)
+	}
+    {
+        memw(r29+#0)=r0
+    }
+    {
+        r0=#9
+        r1=r29
+    }
+    {
+        trap0(#0)
+    }
+    {
+        p0 = cmp.eq(r0, #1); if (p0.new) jump:t pass
+        jump fail
+    }
+
+.data
+
+.L.str:
+	.string	"./test_sys_istty.s"
+	.size	.L.str, 18
+
+.L.tty:
+	.string	":tt"
+	.size	.L.str, 4
+
+.L.buf:
+    .skip 33
diff --git a/tests/tcg/hexagon/test_sys_mkdir.s b/tests/tcg/hexagon/test_sys_mkdir.s
new file mode 100644
index 0000000000..a3833c64e6
--- /dev/null
+++ b/tests/tcg/hexagon/test_sys_mkdir.s
@@ -0,0 +1,33 @@
+# Purpose: sys_mkdir syscall test, on success, a folder is created
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+# Create a new folder
+	{
+        r0=#387
+        r1=##.L.str
+	}
+	{
+        trap0(#0)
+	}
+    {
+        p0 = cmp.eq(r0, #0); if (p0.new) jump:t pass
+        jump fail
+    }
+
+.data
+
+.L.str:
+	.string	"./mkdir_test_folder"
+	.size	.L.str, 18
+
+.L.buf1:
+    .skip 4
+
+.L.buf2:
+    .skip 4
diff --git a/tests/tcg/hexagon/test_sys_open.s b/tests/tcg/hexagon/test_sys_open.s
new file mode 100644
index 0000000000..237a7b2117
--- /dev/null
+++ b/tests/tcg/hexagon/test_sys_open.s
@@ -0,0 +1,39 @@
+# Purpose: sys_open syscall test, on success, r0 contains a file handle
+
+    .text
+    .globl _start
+    .set len, 18
+
+_start:
+    {
+        call init
+    }
+    {
+        allocframe(r29,#24):raw
+    }
+    {
+        r0=##.L.str
+    }
+    {
+        r1=#0
+        memw(r29+#0)=r0; memw(r29+#4)=r1
+    }
+    {
+        r0=#len
+        memw(r29+#8)=r0
+    }
+	{
+        r0=#1  
+        r1=r29
+	}
+	{
+        trap0(#0)
+	}
+    {
+        p0 = !cmp.eq(r0, #-1); if (p0.new) jump:t pass
+        jump fail
+    }
+
+.L.str:
+	.string	"test_sys_open.tst"
+	.size	.L.str, len
diff --git a/tests/tcg/hexagon/test_sys_opendir.s b/tests/tcg/hexagon/test_sys_opendir.s
new file mode 100644
index 0000000000..8618181767
--- /dev/null
+++ b/tests/tcg/hexagon/test_sys_opendir.s
@@ -0,0 +1,81 @@
+# Purpose: sys_opendir syscall test, on success, a folder is first created then opened
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+# Create a new folder
+    {
+        allocframe(r29,#16):raw
+    }
+    {
+        r0=##.L.str
+    }
+    {
+        r1=#4
+        memw(r29+#0)=r0
+    }
+    {
+        r2=#16
+        memw(r29+#4)=r1
+    }
+    {
+        memw(r29+#8)=r2
+    }
+	{
+        r0=#387
+        r1=##.L.str
+	}
+    {
+        r2=#4
+        r3=#2
+    }
+	{
+        trap0(#0)
+	}
+    {
+        p0 = cmp.eq(r0, #0); if (p0.new) jump:t test2
+        jump fail
+    }
+
+test2:
+# Open a folder
+    {
+        allocframe(r29,#16):raw
+    }
+    {
+        r0=##.L.str
+    }
+    {
+        memw(r29+#0)=r0
+    }
+    {
+        r2=#16
+        memw(r29+#4)=r2.new
+    }
+	{
+        r0=#384
+        r1=r29
+	}
+	{
+        trap0(#0)
+	}
+    {
+        p0 = cmp.eq(r0, #0); if (p0.new) jump:t pass
+        jump fail
+    }
+
+.data
+
+.L.str:
+	.string	"./opendir_test_folder"
+	.size	.L.str, 18
+
+.L.buf1:
+    .skip 4
+
+.L.buf2:
+    .skip 4
diff --git a/tests/tcg/hexagon/test_sys_read.s b/tests/tcg/hexagon/test_sys_read.s
new file mode 100644
index 0000000000..025eced096
--- /dev/null
+++ b/tests/tcg/hexagon/test_sys_read.s
@@ -0,0 +1,70 @@
+# Purpose: sys_read syscall test, on success, the buffer is filled
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+# sys_open syscall
+    {
+        allocframe(r29,#16):raw
+    }
+    {
+        r0=##.L.str
+    }
+    {
+        r1=#0
+        memw(r29+#0)=r0
+    }
+    {
+        r2=#18
+        memw(r29+#4)=r1
+    }
+    {
+        memw(r29+#8)=r2
+    }
+	{
+        r0=#1  
+        r1=r29
+	}
+	{
+        trap0(#0)
+	}
+# sys_read syscall
+    {
+        memw(r29+#0)=r0
+    }
+    {
+        r1=##.L.buf
+        memw(r29+#4)=r1.new;
+    }
+    {
+        r2=#32
+        memw(r29+#8)=r2.new;
+    }
+    {
+        r0=#6
+        r1=r29
+    }
+    {
+        trap0(#0)
+    }
+# compare the first read character, should be a capital 'T'
+    {
+        r0=memb(##.L.buf)
+    }
+    {
+        p0 = cmp.eq(r0, #0x54); if (p0.new) jump:t pass
+        jump fail
+    }
+
+.data
+
+.L.str:
+	.string	"./test_file.txt"
+	.size	.L.str, 16
+
+.L.buf:
+    .skip 33
diff --git a/tests/tcg/hexagon/test_sys_readc.s b/tests/tcg/hexagon/test_sys_readc.s
new file mode 100644
index 0000000000..ad50ba7d14
--- /dev/null
+++ b/tests/tcg/hexagon/test_sys_readc.s
@@ -0,0 +1,22 @@
+# Purpose: sys_readc syscall test, on success, a single character is read
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+# sys_readc syscall
+    {
+        r0=#7
+        r1=#0
+    }
+    {
+        trap0(#0)
+    }
+# compare the first read character, should be a hash symbol
+    {
+        p0 = cmp.eq(r0, #35); if (p0.new) jump:t pass
+        jump fail
+    }
diff --git a/tests/tcg/hexagon/test_sys_rmdir.s b/tests/tcg/hexagon/test_sys_rmdir.s
new file mode 100644
index 0000000000..e5c249c46d
--- /dev/null
+++ b/tests/tcg/hexagon/test_sys_rmdir.s
@@ -0,0 +1,47 @@
+# Purpose: sys_rmdir syscall test, on success, a folder is first created then destroyed
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+# Create a new folder
+	{
+        r0=#387
+        r1=##.L.str
+	}
+	{
+        trap0(#0)
+	}
+    {
+        p0 = cmp.eq(r0, #0); if (p0.new) jump:t test2
+        jump fail
+    }
+
+test2:
+# Remove a folder
+	{
+        r0=#388
+        r1=##.L.str
+	}
+	{
+        trap0(#0)
+	}
+    {
+        p0 = cmp.eq(r0, #0); if (p0.new) jump:t pass
+        jump fail
+    }
+
+.data
+
+.L.str:
+	.string	"./rmdir_test_folder"
+	.size	.L.str, 18
+
+.L.buf1:
+    .skip 4
+
+.L.buf2:
+    .skip 4
diff --git a/tests/tcg/hexagon/test_sys_seek.s b/tests/tcg/hexagon/test_sys_seek.s
new file mode 100644
index 0000000000..67c9fe53a5
--- /dev/null
+++ b/tests/tcg/hexagon/test_sys_seek.s
@@ -0,0 +1,109 @@
+# Purpose: sys_seek syscall test, on success, the same character is read twice
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+# sys_open syscall
+    {
+        allocframe(r29,#16):raw
+    }
+    {
+        r0=##.L.str
+    }
+    {
+        r1=#0
+        memw(r29+#0)=r0
+    }
+    {
+        r2=#16
+        memw(r29+#4)=r1
+    }
+    {
+        memw(r29+#8)=r2
+    }
+	{
+        r0=#1  
+        r1=r29
+	}
+	{
+        trap0(#0)
+	}
+# Read a single character through sys_read
+    {
+        r28=r0
+        memw(r29+#0)=r0
+    }
+    {
+        r1=##.L.buf1
+        memw(r29+#4)=r1.new;
+    }
+    {
+        r2=#1
+        memw(r29+#8)=r2.new;
+    }
+    {
+        r0=#6
+        r1=r29
+    }
+    {
+        trap0(#0)
+    }
+# Use sys_seek to rewind the open file
+    {
+        memw(r29+#0)=r28
+    }
+    {
+        r1=#0
+        memw(r29+#4)=r1.new;
+    }
+    {
+        r0=#10
+        r1=r29
+    }
+    {
+        trap0(#0)
+    }
+# Read another character through sys_read
+    {
+        memw(r29+#0)=r28
+    }
+    {
+        r1=##.L.buf2
+        memw(r29+#4)=r1.new;
+    }
+    {
+        r2=#1
+        memw(r29+#8)=r2.new;
+    }
+    {
+        r0=#6
+        r1=r29
+    }
+    {
+        trap0(#0)
+    }
+# compare the two read characters, should be a hash symbol
+    {
+        r0=memb(##.L.buf1)
+        r1=memb(##.L.buf2)
+    }
+    {
+        p0 = cmp.eq(r0, r1); if (p0.new) jump:t pass
+        jump fail
+    }
+
+.data
+
+.L.str:
+	.string	"./test_sys_read.s"
+	.size	.L.str, 18
+
+.L.buf1:
+    .skip 4
+
+.L.buf2:
+    .skip 4
diff --git a/tests/tcg/hexagon/test_vavgw.s b/tests/tcg/hexagon/test_vavgw.s
new file mode 100644
index 0000000000..4236cb399c
--- /dev/null
+++ b/tests/tcg/hexagon/test_vavgw.s
@@ -0,0 +1,32 @@
+# Purpose: test example, verify the soundness of the vavgw operation
+# 
+# 0x00030001 averaged with 0x00010003 results 0x00020002
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+	{
+		r0=#3
+        r1=#1
+    }
+    {
+        r2=#1
+        r3=#3
+	}
+	{
+        r1:0=vavgw(r1:0, r3:2):crnd
+	}
+    {
+        p0 = cmp.eq(r0, #2); if (p0.new) jump:t test2
+        jump fail
+    }
+
+test2:
+    {
+        p0 = cmp.eq(r1, #2); if (p0.new) jump:t pass
+        jump fail
+    }
diff --git a/tests/tcg/hexagon/test_vcmp.s b/tests/tcg/hexagon/test_vcmp.s
new file mode 100644
index 0000000000..a11588b1c6
--- /dev/null
+++ b/tests/tcg/hexagon/test_vcmp.s
@@ -0,0 +1,17 @@
+# Purpose: test a simple multiplication operation
+
+    .text
+    .globl _start
+
+_start:
+	{
+		r5:4=#18446744073709551615
+		r7:6=#255
+	}
+    {
+        p0=vcmpb.eq(R5:4,R7:6)
+    }
+    {
+        p0 = cmp.eq(r3, #24); if (p0.new) jump:t pass
+        jump fail
+    }
diff --git a/tests/tcg/hexagon/test_vcmpb.s b/tests/tcg/hexagon/test_vcmpb.s
new file mode 100644
index 0000000000..21316b69b2
--- /dev/null
+++ b/tests/tcg/hexagon/test_vcmpb.s
@@ -0,0 +1,29 @@
+# Purpose: test example, verify the soundness of the vector compare bytes operation
+# 
+# Vector word comparison between 0x1234567887654321 and 0x1234567800000000 should result in 0x11110000
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+	{
+		r0=#305419896
+        r1=#2271560481
+    }
+    {
+        r2=#305419896
+        r3=#0
+    }
+	{
+        p2=vcmpb.eq(r1:0, r3:2)
+	}
+    {
+        r4=p2
+    }
+    {
+        p0 = cmp.eq(r4, #15); if (p0.new) jump:t pass
+        jump fail
+    }
diff --git a/tests/tcg/hexagon/test_vcmpw.s b/tests/tcg/hexagon/test_vcmpw.s
new file mode 100644
index 0000000000..86478a086b
--- /dev/null
+++ b/tests/tcg/hexagon/test_vcmpw.s
@@ -0,0 +1,26 @@
+# Purpose: test example, verify the soundness of the vector compare words operation
+# 
+# Vector word comparison between 0x1234567887654321 and 0x1234567800000000 should result in 0x11110000
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+	{
+		r0=#305419896
+        r1=#2271560481
+    }
+    {
+        r2=#305419896
+        r3=#0
+    }
+	{
+        p2=vcmpw.eq(r1:0, r3:2)
+	}
+    {
+        if (p2) jump:t pass
+        jump fail
+    }
diff --git a/tests/tcg/hexagon/test_vcmpy.s b/tests/tcg/hexagon/test_vcmpy.s
new file mode 100644
index 0000000000..7e9e850d7a
--- /dev/null
+++ b/tests/tcg/hexagon/test_vcmpy.s
@@ -0,0 +1,48 @@
+# Purpose: test example, verify the soundness of the vcmpy operation
+# this operation is a complex multiply and accumulate on vectors of two values
+# 
+#                       (3j+5 * 2j+4) + (4j+6 * 5j+2) = 22j+14
+# the complex multiply between  0x00030005 and 0x00020004 is 0x000000160000000e
+# the complex multiply between  0x00040006 and 0x00050002 is 0x000000160000000e
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+	{
+		r0=#196613
+        r1=#131076
+    }
+    {
+        r2=#262150
+        r3=#327682
+    }
+	{
+        r5:4=vcmpyr(r1:0, r3:2):sat
+        r7:6=vcmpyi(r1:0, r3:2):sat
+	}
+    {
+        p0 = cmp.eq(r4, #18); if (p0.new) jump:t test2
+        jump fail
+    }
+
+test2:
+    {
+        p0 = cmp.eq(r5, #-2); if (p0.new) jump:t test3
+        jump fail
+    }
+
+test3:
+    {
+        p0 = cmp.eq(r6, #38); if (p0.new) jump:t test4
+        jump fail
+    }
+
+test4:
+    {
+        p0 = cmp.eq(r7, #24); if (p0.new) jump:t pass
+        jump fail
+    }
diff --git a/tests/tcg/hexagon/test_vlsrw.s b/tests/tcg/hexagon/test_vlsrw.s
new file mode 100644
index 0000000000..02ca3fd038
--- /dev/null
+++ b/tests/tcg/hexagon/test_vlsrw.s
@@ -0,0 +1,23 @@
+# Purpose: test the soundness of the vlsrw operation
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+	{
+		r0=#0x00000001
+		r1=#0x00000001
+	}
+	{
+		r1:0=vlsrw(r1:0, #1)
+	}
+    {
+        r0 = add(r0, r1)
+    }
+    {
+        p0 = cmp.eq(r0, #0); if (p0.new) jump:t pass
+        jump fail
+    }
diff --git a/tests/tcg/hexagon/test_vmaxh.s b/tests/tcg/hexagon/test_vmaxh.s
new file mode 100644
index 0000000000..04fc6d56a9
--- /dev/null
+++ b/tests/tcg/hexagon/test_vmaxh.s
@@ -0,0 +1,34 @@
+# Purpose: test example, verify the soundness of the vrmaxh operation
+# 
+# the maximum between  0x0002000300010005 and 0x0003000200020007 is 0x0003000300020007
+#                      r1=0x00010003 r0=0x00010005 r3=0x00030002 r2=0x00020007
+#     result:          r1=0x00030003 r0=0x00020007
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+	{
+		r0=#65541
+        r1=#65539
+    }
+    {
+        r2=#131079
+        r3=#196610
+	}
+	{
+        r1:0=vmaxh(r1:0, r3:2)
+	}
+    {
+        p0 = cmp.eq(r0, #131079); if (p0.new) jump:t test2
+        jump fail
+    }
+
+test2:
+    {
+        p0 = cmp.eq(r1, #196611); if (p0.new) jump:t pass
+        jump fail
+    }
diff --git a/tests/tcg/hexagon/test_vminh.s b/tests/tcg/hexagon/test_vminh.s
new file mode 100644
index 0000000000..534afc1b58
--- /dev/null
+++ b/tests/tcg/hexagon/test_vminh.s
@@ -0,0 +1,34 @@
+# Purpose: test example, verify the soundness of the vrmaxh operation
+# 
+# the minimum between  0x0002000300010005 and 0x0003000200020007 is 0x0003000300020007
+#                      r1=0x00010003 r0=0x00010005 r3=0x00030002 r2=0x00020007
+#     result:          r1=0x00010002 r0=0x00010005
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+	{
+		r0=#65541
+        r1=#65539
+    }
+    {
+        r2=#131079
+        r3=#196610
+	}
+	{
+        r1:0=vminh(r1:0, r3:2)
+	}
+    {
+        p0 = cmp.eq(r0, #65541); if (p0.new) jump:t test2
+        jump fail
+    }
+
+test2:
+    {
+        p0 = cmp.eq(r1, #65538); if (p0.new) jump:t pass
+        jump fail
+    }
diff --git a/tests/tcg/hexagon/test_vpmpyh.s b/tests/tcg/hexagon/test_vpmpyh.s
new file mode 100644
index 0000000000..80cd13d333
--- /dev/null
+++ b/tests/tcg/hexagon/test_vpmpyh.s
@@ -0,0 +1,28 @@
+# Purpose: test example, verify the soundness of the vpmpyh operator
+# 
+# 0x01020304 vector polynomial multiplied with 0x04030201 results 0x000400060b060b04
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+	{
+        r0=#16909060
+        r1=#67305985
+    }
+	{
+        r1:0=vpmpyh(r0, r1)
+	}
+    {
+        p0 = cmp.eq(r0, #184945412); if (p0.new) jump:t test2
+        jump fail
+    }
+
+test2:
+    {
+        p0 = cmp.eq(r1, #262150); if (p0.new) jump:t pass
+        jump fail
+    }
diff --git a/tests/tcg/hexagon/test_vspliceb.s b/tests/tcg/hexagon/test_vspliceb.s
new file mode 100644
index 0000000000..a2e516a882
--- /dev/null
+++ b/tests/tcg/hexagon/test_vspliceb.s
@@ -0,0 +1,33 @@
+# Purpose: test example, verify the soundness of the vspliceb operation
+# the operation is a binary splice of two 64bit operators
+# 
+#                 vspliceb(0xffffffffffffffff,0x0000000000000000,5) = 0x000000000000001f 
+
+    .text
+    .globl _start
+
+_start:
+    {
+        call init
+    }
+	{
+		r0=#4294967295
+        r1=#4294967295
+    }
+    {
+        r2=#0
+        r3=#0
+    }
+	{
+        r5:4=vspliceb(r1:0, r3:2, #5)
+	}
+    {
+        p0 = cmp.eq(r4, #4294967295); if (p0.new) jump:t test2
+        jump fail
+    }
+
+test2:
+    {
+        p0 = cmp.eq(r5, #255); if (p0.new) jump:t pass
+        jump fail
+    }
-- 
2.17.1

